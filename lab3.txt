diff --git a/PXE/CommonLib.lib b/PXE/CommonLib.lib
new file mode 100644
index 0000000..765fdb2
Binary files /dev/null and b/PXE/CommonLib.lib differ
diff --git a/lab1.txt b/lab1.txt
new file mode 100644
index 0000000..21ac0b1
--- /dev/null
+++ b/lab1.txt
@@ -0,0 +1,40 @@
+diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
+index cec924b..a0b2154 100644
+--- a/postbuild/paths.cmd
++++ b/postbuild/paths.cmd
+@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
+ set PATH_TO_VM_TOOLS=__EMPTY__
+ set VOL_MOUNT_LETTER=__EMPTY__
+ 
++if _%COMPUTERNAME%_==_DESKTOP-KSBSOAV_ goto config_DESKTOP-KSBSOAV
+ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
+ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
+ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
+@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
+ 
+ goto end
+ 
++:config_DESKTOP-KSBSOAV
++
++SET PATH_TO_VM_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
++SET PXE_PATH="D:\Faculta\PSO\HAL9000\HAL9000\PXE"
++SET PATH_TO_LOG_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
++SET PATH_TO_VM_DISK="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
++goto end
++
+ :end
+\ No newline at end of file
+diff --git a/src/HAL9000/src/cmd_basic.c b/src/HAL9000/src/cmd_basic.c
+index 312b097..eb05dd8 100644
+--- a/src/HAL9000/src/cmd_basic.c
++++ b/src/HAL9000/src/cmd_basic.c
+@@ -27,6 +27,8 @@ CmdPrintVolumeInformation(
+ 
+ #pragma warning(push)
+ 
++//just some comments for lab 1
++
+ // warning C4717: '_CmdInfiniteRecursion': recursive on all control paths, function will cause runtime stack overflow
+ #pragma warning(disable:4717)
+ void
diff --git a/lab2.txt b/lab2.txt
new file mode 100644
index 0000000..4458b0b
--- /dev/null
+++ b/lab2.txt
@@ -0,0 +1,177 @@
+diff --git a/lab1.txt b/lab1.txt
+new file mode 100644
+index 0000000..21ac0b1
+--- /dev/null
++++ b/lab1.txt
+@@ -0,0 +1,40 @@
++diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
++index cec924b..a0b2154 100644
++--- a/postbuild/paths.cmd
+++++ b/postbuild/paths.cmd
++@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
++ set PATH_TO_VM_TOOLS=__EMPTY__
++ set VOL_MOUNT_LETTER=__EMPTY__
++ 
+++if _%COMPUTERNAME%_==_DESKTOP-KSBSOAV_ goto config_DESKTOP-KSBSOAV
++ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
++ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
++ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
++@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
++ 
++ goto end
++ 
+++:config_DESKTOP-KSBSOAV
+++
+++SET PATH_TO_VM_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
+++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
+++SET PXE_PATH="D:\Faculta\PSO\HAL9000\HAL9000\PXE"
+++SET PATH_TO_LOG_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
+++SET PATH_TO_VM_DISK="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
+++goto end
+++
++ :end
++\ No newline at end of file
++diff --git a/src/HAL9000/src/cmd_basic.c b/src/HAL9000/src/cmd_basic.c
++index 312b097..eb05dd8 100644
++--- a/src/HAL9000/src/cmd_basic.c
+++++ b/src/HAL9000/src/cmd_basic.c
++@@ -27,6 +27,8 @@ CmdPrintVolumeInformation(
++ 
++ #pragma warning(push)
++ 
+++//just some comments for lab 1
+++
++ // warning C4717: '_CmdInfiniteRecursion': recursive on all control paths, function will cause runtime stack overflow
++ #pragma warning(disable:4717)
++ void
+diff --git a/latex/design-documents/os-design.synctex(busy) b/latex/design-documents/os-design.synctex(busy)
+new file mode 100644
+index 0000000..c9d0399
+Binary files /dev/null and b/latex/design-documents/os-design.synctex(busy) differ
+diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
+index cec924b..a0b2154 100644
+--- a/postbuild/paths.cmd
++++ b/postbuild/paths.cmd
+@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
+ set PATH_TO_VM_TOOLS=__EMPTY__
+ set VOL_MOUNT_LETTER=__EMPTY__
+ 
++if _%COMPUTERNAME%_==_DESKTOP-KSBSOAV_ goto config_DESKTOP-KSBSOAV
+ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
+ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
+ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
+@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
+ 
+ goto end
+ 
++:config_DESKTOP-KSBSOAV
++
++SET PATH_TO_VM_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
++SET PXE_PATH="D:\Faculta\PSO\HAL9000\HAL9000\PXE"
++SET PATH_TO_LOG_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
++SET PATH_TO_VM_DISK="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
++goto end
++
+ :end
+\ No newline at end of file
+diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
+index be2588a..e2e3da6 100644
+--- a/src/HAL9000/headers/thread_internal.h
++++ b/src/HAL9000/headers/thread_internal.h
+@@ -36,7 +36,7 @@ typedef struct _THREAD
+     REF_COUNT               RefCnt;
+ 
+     struct _THREAD          *Self;
+-
++     
+     TID                     Id;
+     char*                   Name;
+ 
+diff --git a/src/HAL9000/src/cmd_basic.c b/src/HAL9000/src/cmd_basic.c
+index 312b097..eb05dd8 100644
+--- a/src/HAL9000/src/cmd_basic.c
++++ b/src/HAL9000/src/cmd_basic.c
+@@ -27,6 +27,8 @@ CmdPrintVolumeInformation(
+ 
+ #pragma warning(push)
+ 
++//just some comments for lab 1
++
+ // warning C4717: '_CmdInfiniteRecursion': recursive on all control paths, function will cause runtime stack overflow
+ #pragma warning(disable:4717)
+ void
+diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
+index b311f0c..bcc0096 100644
+--- a/src/HAL9000/src/thread.c
++++ b/src/HAL9000/src/thread.c
+@@ -10,9 +10,9 @@
+ #include "gdtmu.h"
+ #include "pe_exports.h"
+ 
+-#define TID_INCREMENT               4
++#define TID_INCREMENT               10
+ 
+-#define THREAD_TIME_SLICE           1
++#define THREAD_TIME_SLICE           4
+ 
+ extern void ThreadStart();
+ 
+@@ -29,6 +29,8 @@ typedef struct _THREAD_SYSTEM_DATA
+ {
+     LOCK                AllThreadsLock;
+ 
++    QWORD               TotalNrOfThreads ; 
++
+     _Guarded_by_(AllThreadsLock)
+     LIST_ENTRY          AllThreadsList;
+ 
+@@ -332,6 +334,8 @@ ThreadCreateEx(
+         return status;
+     }
+ 
++   // LOG("Thread created"); /////////////////////////////////////////////////////////////////////////
++
+     ProcessInsertThreadInList(Process, pThread);
+ 
+     // the reference must be done outside _ThreadInit
+@@ -802,20 +806,29 @@ _ThreadInit(
+     }
+     __finally
+     {
++
+         if (!SUCCEEDED(status))
+         {
+             if (NULL != pThread)
+             {
+                 _ThreadDereference(pThread);
+                 pThread = NULL;
++               
+             }
++            
+         }
+-
++        else
++        {
++            LOG("Thread 0x%X with name %s just started \n", pThread->Id, pThread->Name);
++        }
++       
+         *Thread = pThread;
+-
++        
+         LOG_FUNC_END;
+     }
+ 
++    
++
+     return status;
+ }
+ 
+@@ -1186,6 +1199,7 @@ _ThreadDestroy(
+ 
+     ASSERT(NULL != pThread);
+     ASSERT(NULL == Context);
++    LOG("Thread 0x%X with name %s was just destroyed \n", pThread->Id, pThread->Name);
+ 
+     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
+     RemoveEntryList(&pThread->AllList);
diff --git a/latex/design-documents/os-design.synctex(busy) b/latex/design-documents/os-design.synctex(busy)
new file mode 100644
index 0000000..c9d0399
Binary files /dev/null and b/latex/design-documents/os-design.synctex(busy) differ
diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
index cec924b..a0b2154 100644
--- a/postbuild/paths.cmd
+++ b/postbuild/paths.cmd
@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
 set PATH_TO_VM_TOOLS=__EMPTY__
 set VOL_MOUNT_LETTER=__EMPTY__
 
+if _%COMPUTERNAME%_==_DESKTOP-KSBSOAV_ goto config_DESKTOP-KSBSOAV
 if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
 if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
 if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
 
 goto end
 
+:config_DESKTOP-KSBSOAV
+
+SET PATH_TO_VM_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
+SET PXE_PATH="D:\Faculta\PSO\HAL9000\HAL9000\PXE"
+SET PATH_TO_LOG_FILE="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
+SET PATH_TO_VM_DISK="D:\Faculta\PSO\HAL9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
+goto end
+
 :end
\ No newline at end of file
diff --git a/src/.vs/HAL9000_WithoutApplications/v16/Preview/Solution.VC.db-shm b/src/.vs/HAL9000_WithoutApplications/v16/Preview/Solution.VC.db-shm
deleted file mode 100644
index 6166b0b..0000000
Binary files a/src/.vs/HAL9000_WithoutApplications/v16/Preview/Solution.VC.db-shm and /dev/null differ
diff --git a/src/.vs/HAL9000_WithoutApplications/v16/Preview/Solution.VC.db-wal b/src/.vs/HAL9000_WithoutApplications/v16/Preview/Solution.VC.db-wal
deleted file mode 100644
index 613c010..0000000
Binary files a/src/.vs/HAL9000_WithoutApplications/v16/Preview/Solution.VC.db-wal and /dev/null differ
diff --git a/src/.vs/HAL9000_WithoutApplications/v16/Preview/ipch/AutoPCH/45e49bfa6a5950bd/TEST_PRIORITY_DONATION.ipch b/src/.vs/HAL9000_WithoutApplications/v16/Preview/ipch/AutoPCH/45e49bfa6a5950bd/TEST_PRIORITY_DONATION.ipch
deleted file mode 100644
index f7b5812..0000000
Binary files a/src/.vs/HAL9000_WithoutApplications/v16/Preview/ipch/AutoPCH/45e49bfa6a5950bd/TEST_PRIORITY_DONATION.ipch and /dev/null differ
diff --git a/src/Ata/Ata.vcxproj b/src/Ata/Ata.vcxproj
index 050f968..5690626 100644
--- a/src/Ata/Ata.vcxproj
+++ b/src/Ata/Ata.vcxproj
@@ -23,9 +23,10 @@
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -36,7 +37,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -47,13 +48,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
@@ -67,7 +61,7 @@
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <OmitFramePointers>true</OmitFramePointers>
       <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -85,36 +79,16 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
+      <WarningLevel>Level3</WarningLevel>
       <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
       <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
     </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClInclude Include="headers\ata_base.h" />
diff --git a/src/Ata/headers/ata_operations.h b/src/Ata/headers/ata_operations.h
index be17854..fe7bb87 100644
--- a/src/Ata/headers/ata_operations.h
+++ b/src/Ata/headers/ata_operations.h
@@ -2,6 +2,7 @@
 
 #define ATA_NO_OF_BARS_USED     5
 
+SAL_SUCCESS
 STATUS
 AtaInitialize(
     IN                              PPCI_DEVICE_DESCRIPTION     PciDevice,
@@ -10,6 +11,7 @@ AtaInitialize(
     IN                              PDEVICE_OBJECT              Device
     );
 
+SAL_SUCCESS
 STATUS
 AtaReadWriteSectors(
     IN                              PATA_DEVICE                 Device,
diff --git a/src/Ata/headers/ata_registers.h b/src/Ata/headers/ata_registers.h
index 9291378..86df5a8 100644
--- a/src/Ata/headers/ata_registers.h
+++ b/src/Ata/headers/ata_registers.h
@@ -87,8 +87,6 @@ typedef enum _ATA_REGISTER
 // PRD (Physical Region Descriptor)
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
@@ -118,5 +116,6 @@ typedef union _PRD_ENTRY
 } PRD_ENTRY, *PPRD_ENTRY;
 STATIC_ASSERT(ATA_PRD_ENTRY_PREDEFINED_SIZE == sizeof(PRD_ENTRY));
 
-#pragma warning(pop)
-#pragma pack(pop)
+#pragma warning(default:4201)
+
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src/Ata/src/ata.c b/src/Ata/src/ata.c
index d2f0d82..3f7ca4e 100644
--- a/src/Ata/src/ata.c
+++ b/src/Ata/src/ata.c
@@ -3,6 +3,7 @@
 #include "ata_dispatch.h"
 #include "ata_operations.h"
 
+SAL_SUCCESS
 STATUS
 (__cdecl AtaDriverEntry)(
     INOUT       PDRIVER_OBJECT      Driver
@@ -44,7 +45,6 @@ STATUS
         LOG_FUNC_ERROR("IoGetPciDevicesMatchingClassAndSubclass", status);
         return status;
     }
-    ASSERT(noOfDevices == 0 || pPciDevices != NULL);
     LOGL("Found %d IDE devices\n", noOfDevices );
 
     Driver->DispatchFunctions[IRP_MJ_READ] = AtaDispatchReadWrite;
@@ -54,7 +54,6 @@ STATUS
     // lets try to initialize the device
     for (i = 0; i < noOfDevices; ++i)
     {
-        ASSERT(pPciDevices[i] != NULL);
 
         for (j = 0; j < 2; ++j)
         {
diff --git a/src/Ata/src/ata_dispatch.c b/src/Ata/src/ata_dispatch.c
index d32d920..c1735cc 100644
--- a/src/Ata/src/ata_dispatch.c
+++ b/src/Ata/src/ata_dispatch.c
@@ -62,6 +62,7 @@ _AtaCheckIOParameters(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl AtaDispatchReadWrite)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -155,6 +156,7 @@ STATUS
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl AtaDispatchDeviceControl)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
diff --git a/src/Ata/src/ata_operations.c b/src/Ata/src/ata_operations.c
index be3ca5f..c8bff33 100644
--- a/src/Ata/src/ata_operations.c
+++ b/src/Ata/src/ata_operations.c
@@ -45,6 +45,7 @@ _AtaWriteBuffer(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _AtaPrepareDmaTransfer(
     IN          PATA_DEVICE_REGISTERS                       AtaDevice,
@@ -55,6 +56,7 @@ _AtaPrepareDmaTransfer(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _AtaValidateTranslationPair(
     IN          PMDL_TRANSLATION_PAIR                       TranslationPair
@@ -309,6 +311,7 @@ _AtaWriteBuffer(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _AtaPrepareDmaTransfer(
     IN          PATA_DEVICE_REGISTERS                       AtaDevice,
@@ -469,6 +472,7 @@ _AtaPrepareDmaTransfer(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _AtaValidateTranslationPair(
     IN          PMDL_TRANSLATION_PAIR                       TranslationPair
@@ -521,6 +525,7 @@ _AtaWriteDmaRegisters(
     _AtaWriteRegister(AtaDevice, AtaRegisterBusStatus, (!WriteOperation * ATA_BUS_CMD_READ_BIT) );
 }
 
+SAL_SUCCESS
 STATUS
 AtaInitialize(
     IN                              PPCI_DEVICE_DESCRIPTION     PciDevice,
@@ -584,7 +589,6 @@ AtaInitialize(
     pDeviceExtension->DeviceRegisters.ControlBase = (WORD)((0 != ctrlAddress) ? (ctrlAddress + 2) : ATA_FIXED_CONTROL_ADDRESS[SecondaryChannel]);
     pDeviceExtension->DeviceRegisters.BusMasterBase = (WORD) busAddress;
     pDeviceExtension->DeviceRegisters.NoInterrupt = ATA_DCTRL_REG_NIEN;
-    pDeviceExtension->SecondaryChannel = SecondaryChannel;
     pDeviceExtension->Slave = Slave;
 
     LOG_TRACE_STORAGE("Base address: 0x%x\n", pDeviceExtension->DeviceRegisters.BaseRegister);
@@ -701,6 +705,7 @@ AtaInitialize(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 AtaReadWriteSectors(
     IN                                          PATA_DEVICE     Device,
diff --git a/src/CommonLib/CommonLib.vcxproj b/src/CommonLib/CommonLib.vcxproj
index b04eee7..6e5ae72 100644
--- a/src/CommonLib/CommonLib.vcxproj
+++ b/src/CommonLib/CommonLib.vcxproj
@@ -5,41 +5,22 @@
       <Configuration>DebugNoLocks</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="DebugNonNative|x64">
-      <Configuration>DebugNonNative</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
     <ProjectConfiguration Include="Debug|x64">
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseNoLocks|x64">
-      <Configuration>ReleaseNoLocks</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseNonNative|x64">
-      <Configuration>ReleaseNonNative</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="src\assert.c" />
     <ClCompile Include="src\bitmap.c" />
-    <ClCompile Include="src\checkin_queue.c" />
-    <ClCompile Include="src\cl_heap.c" />
     <ClCompile Include="src\common_lib.c" />
     <ClCompile Include="src\event.c" />
     <ClCompile Include="src\gs_checks.c" />
     <ClCompile Include="src\gs_utils.c" />
-    <ClCompile Include="src\hash_table.c" />
     <ClCompile Include="src\intutils.c" />
     <ClCompile Include="src\list.c" />
     <ClCompile Include="src\lock_common.c" />
-    <ClCompile Include="src\cl_memory.c" />
+    <ClCompile Include="src\memory.c" />
     <ClCompile Include="src\monlock.c" />
     <ClCompile Include="src\rec_rw_spinlock.c" />
     <ClCompile Include="src\ref_cnt.c" />
@@ -47,43 +28,32 @@
     <ClCompile Include="src\rw_spinlock.c" />
     <ClCompile Include="src\seh.c" />
     <ClCompile Include="src\spinlock.c" />
-    <ClCompile Include="src\cl_string.c" />
-    <ClCompile Include="src\stack_dynamic.c" />
-    <ClCompile Include="src\stack_interface.c" />
+    <ClCompile Include="src\string.c" />
     <ClCompile Include="src\strutils.c" />
     <ClCompile Include="src\time.c" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="headers\seh.h" />
-    <ClInclude Include="headers\stack_dynamic.h" />
-    <ClInclude Include="headers\stack_internal.h" />
     <ClInclude Include="inc\assert.h" />
     <ClInclude Include="inc\base.h" />
     <ClInclude Include="inc\bitmap.h" />
-    <ClInclude Include="inc\checkin_queue.h" />
-    <ClInclude Include="inc\cl_heap.h" />
     <ClInclude Include="inc\common_lib.h" />
     <ClInclude Include="inc\data_type.h" />
     <ClInclude Include="inc\event.h" />
     <ClInclude Include="inc\gs_utils.h" />
-    <ClInclude Include="inc\hash_table.h" />
     <ClInclude Include="inc\intutils.h" />
     <ClInclude Include="inc\list.h" />
     <ClInclude Include="inc\lock_common.h" />
-    <ClInclude Include="inc\cl_memory.h" />
+    <ClInclude Include="inc\memory.h" />
     <ClInclude Include="inc\monlock.h" />
-    <ClInclude Include="inc\native\memory.h" />
-    <ClInclude Include="inc\native\string.h" />
     <ClInclude Include="inc\rec_rw_spinlock.h" />
     <ClInclude Include="inc\ref_cnt.h" />
     <ClInclude Include="inc\rw_spinlock.h" />
     <ClInclude Include="inc\sal_interface.h" />
     <ClInclude Include="inc\sal_intrinsic.h" />
-    <ClInclude Include="inc\slist.h" />
     <ClInclude Include="inc\spinlock.h" />
-    <ClInclude Include="inc\stack_interface.h" />
     <ClInclude Include="inc\status.h" />
-    <ClInclude Include="inc\cl_string.h" />
+    <ClInclude Include="inc\string.h" />
     <ClInclude Include="inc\strutils.h" />
     <ClInclude Include="inc\time.h" />
     <ClInclude Include="inc\va_list.h" />
@@ -106,60 +76,24 @@
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
-    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.props" />
+    <Import Project="..\..\tools\vsyasm\vsyasm.props" />
   </ImportGroup>
   <ImportGroup Label="Shared">
   </ImportGroup>
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <LinkIncremental>false</LinkIncremental>
@@ -169,30 +103,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <LinkIncremental>false</LinkIncremental>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'">
-    <LinkIncremental>false</LinkIncremental>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'">
-    <LinkIncremental>false</LinkIncremental>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'">
     <LinkIncremental>false</LinkIncremental>
     <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
@@ -201,21 +111,13 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'">
-    <LinkIncremental>false</LinkIncremental>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level4</WarningLevel>
       <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;DEBUG;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <CompileAsManaged>false</CompileAsManaged>
       <TreatWarningAsError>true</TreatWarningAsError>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
@@ -227,7 +129,7 @@
       <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
       <EnablePREfast>true</EnablePREfast>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
@@ -235,7 +137,6 @@
       <OmitFramePointers>true</OmitFramePointers>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <SDLCheck>true</SDLCheck>
-      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
     </ClCompile>
     <Link>
       <SubSystem>Console</SubSystem>
@@ -244,7 +145,7 @@
       <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
     </Link>
     <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+      <Command>..\..\postbuild\post_hv.cmd $(ProjectName) "$(SolutionDir)" $(PlatformName) $(ConfigurationName) $(ProjectName)  $(TargetName) $(TargetExt)</Command>
     </PostBuildEvent>
     <YASM>
       <Debug>true</Debug>
@@ -252,160 +153,17 @@
       <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
     </YASM>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>MaxSpeed</Optimization>
-      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <OpenMPSupport>false</OpenMPSupport>
-      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
-      <EnablePREfast>true</EnablePREfast>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <SDLCheck>true</SDLCheck>
-      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>
-      </WholeProgramOptimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>
-      </AdditionalDependencies>
-      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
-    </Link>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-    <YASM>
-      <Debug>true</Debug>
-      <Defines>
-      </Defines>
-      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
-    </YASM>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>MaxSpeed</Optimization>
-      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;CL_NO_RUNTIME_CHECKS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <OpenMPSupport>false</OpenMPSupport>
-      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
-      <EnablePREfast>true</EnablePREfast>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <SDLCheck>true</SDLCheck>
-      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>
-      </WholeProgramOptimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>
-      </AdditionalDependencies>
-      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
-    </Link>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-    <YASM>
-      <Debug>true</Debug>
-      <Defines>CL_NO_RUNTIME_CHECKS</Defines>
-      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
-    </YASM>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;CL_NO_RUNTIME_CHECKS;DEBUG;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <OpenMPSupport>false</OpenMPSupport>
-      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
-      <EnablePREfast>true</EnablePREfast>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OmitFramePointers>true</OmitFramePointers>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <SDLCheck>true</SDLCheck>
-      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>
-      </AdditionalDependencies>
-      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
-    </Link>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-    <YASM>
-      <Debug>true</Debug>
-      <Defines>DEBUG;CL_NO_RUNTIME_CHECKS</Defines>
-      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
-    </YASM>
-  </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'">
     <ClCompile>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level4</WarningLevel>
       <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;DEBUG;_DEBUG;_CONSOLE;_COMMONLIB_NO_LOCKS_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;_CONSOLE;_COMMONLIB_NO_LOCKS_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <CompileAsManaged>false</CompileAsManaged>
       <TreatWarningAsError>true</TreatWarningAsError>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
       <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <ControlFlowGuard>false</ControlFlowGuard>
@@ -413,7 +171,7 @@
       <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
       <EnablePREfast>true</EnablePREfast>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
@@ -429,52 +187,11 @@
       <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
     </Link>
     <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>MaxSpeed</Optimization>
-      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;NDEBUG;_CONSOLE;_COMMONLIB_NO_LOCKS_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <OpenMPSupport>false</OpenMPSupport>
-      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
-      <EnablePREfast>true</EnablePREfast>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization />
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>
-      </AdditionalDependencies>
-      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
-    </Link>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+      <Command>..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
-    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.targets" />
+    <Import Project="..\..\tools\vsyasm\vsyasm.targets" />
   </ImportGroup>
 </Project>
\ No newline at end of file
diff --git a/src/CommonLib/CommonLib.vcxproj.filters b/src/CommonLib/CommonLib.vcxproj.filters
index 2282215..9504b0b 100644
--- a/src/CommonLib/CommonLib.vcxproj.filters
+++ b/src/CommonLib/CommonLib.vcxproj.filters
@@ -25,14 +25,17 @@
     <Filter Include="Header Files\headers\runtime checks">
       <UniqueIdentifier>{a14b0037-6d17-433d-bef5-efde9061f28f}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Header Files\inc\native">
-      <UniqueIdentifier>{16fd42b3-a65e-40e4-893a-6d88facc2eb1}</UniqueIdentifier>
-    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="src\ref_cnt.c">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="src\memory.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\string.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="src\strutils.c">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -72,39 +75,18 @@
     <ClCompile Include="src\intutils.c">
       <Filter>Source Files</Filter>
     </ClCompile>
-    <ClCompile Include="src\hash_table.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="src\cl_string.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="src\cl_memory.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="src\gs_checks.c">
+    <ClCompile Include="src\seh.c">
       <Filter>Source Files\runtime checks</Filter>
     </ClCompile>
-    <ClCompile Include="src\gs_utils.c">
+    <ClCompile Include="src\gs_checks.c">
       <Filter>Source Files\runtime checks</Filter>
     </ClCompile>
     <ClCompile Include="src\rtc_checks.c">
       <Filter>Source Files\runtime checks</Filter>
     </ClCompile>
-    <ClCompile Include="src\seh.c">
+    <ClCompile Include="src\gs_utils.c">
       <Filter>Source Files\runtime checks</Filter>
     </ClCompile>
-    <ClCompile Include="src\stack_dynamic.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="src\stack_interface.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="src\cl_heap.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="src\checkin_queue.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="inc\va_list.h">
@@ -122,6 +104,9 @@
     <ClInclude Include="inc\list.h">
       <Filter>Header Files\inc</Filter>
     </ClInclude>
+    <ClInclude Include="inc\memory.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
     <ClInclude Include="inc\ref_cnt.h">
       <Filter>Header Files\inc</Filter>
     </ClInclude>
@@ -131,6 +116,9 @@
     <ClInclude Include="inc\status.h">
       <Filter>Header Files\inc</Filter>
     </ClInclude>
+    <ClInclude Include="inc\string.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
     <ClInclude Include="inc\strutils.h">
       <Filter>Header Files\inc</Filter>
     </ClInclude>
@@ -173,39 +161,6 @@
     <ClInclude Include="inc\gs_utils.h">
       <Filter>Header Files\inc</Filter>
     </ClInclude>
-    <ClInclude Include="inc\hash_table.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\native\memory.h">
-      <Filter>Header Files\inc\native</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\native\string.h">
-      <Filter>Header Files\inc\native</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\cl_string.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\cl_memory.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\slist.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="headers\stack_dynamic.h">
-      <Filter>Header Files\headers</Filter>
-    </ClInclude>
-    <ClInclude Include="headers\stack_internal.h">
-      <Filter>Header Files\headers</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\stack_interface.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\cl_heap.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\checkin_queue.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <YASM Include="src\_gs_checks.yasm">
diff --git a/src/CommonLib/headers/seh.h b/src/CommonLib/headers/seh.h
index 6c0d144..9e9eb04 100644
--- a/src/CommonLib/headers/seh.h
+++ b/src/CommonLib/headers/seh.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
@@ -187,4 +185,4 @@ typedef struct _DISPATCHER_CONTEXT
     DWORD Fill0;
 } DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;
 
-#pragma warning(pop)
+#pragma warning(default:4201)
diff --git a/src/CommonLib/inc/assert.h b/src/CommonLib/inc/assert.h
index 30daa8e..69dda43 100644
--- a/src/CommonLib/inc/assert.h
+++ b/src/CommonLib/inc/assert.h
@@ -1,8 +1,6 @@
 #pragma once
 
-C_HEADER_START
-
-#include "native/string.h"
+#include "string.h"
 
 //******************************************************************************
 // Function:     FUNC_AssertFunction
@@ -24,13 +22,11 @@ typedef FUNC_AssertFunction*        PFUNC_AssertFunction;
 
 // The ASSERT macros validate a specified condition, in case the
 // condition does not hold the registered FUNC_AssertFunction is called
-#ifndef ASSERT
 #define ASSERT(Cond)                ASSERT_INFO((Cond),"")
-#endif // ASSERT
 
 #define ASSERT_INFO(Cond,Msg,...)   if((Cond)){} else                                                                                                    \
                                     {                                                                                                                    \
-                                        AssertInfo( "[ASSERT][%s][%d]Condition: (" ## #Cond ## ") failed\n" ##Msg, cl_strrchr(__FILE__, '\\') + 1, __LINE__, __VA_ARGS__ );      \
+                                        AssertInfo( "[ASSERT][%s][%d]Condition: (" ## #Cond ## ") failed\n" ##Msg, strrchr(__FILE__, '\\') + 1, __LINE__, __VA_ARGS__ );      \
                                     }
 
 #define NOT_REACHED                 __pragma(warning(suppress: 4127)) ASSERT(FALSE)
@@ -49,15 +45,8 @@ AssertSetFunction(
 #ifndef _COMMONLIB_NO_LOCKS_
 REQUIRES_EXCL_LOCK(m_assertLock)
 RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_assertLock)
-
-#ifndef COMMONLIB_LIB_IMPL
-// Warning C28285 For function 'AssertFreeLock' 'return' syntax error
-// This is suppressed only for external projects because they have no idea who m_assertLock is
-#pragma warning(suppress: 28285)
-#endif
 void
 AssertFreeLock(
     void
     );
-#endif // _COMMONLIB_NO_LOCKS_
-C_HEADER_END
+#endif // _COMMONLIB_NO_LOCKS_
\ No newline at end of file
diff --git a/src/CommonLib/inc/base.h b/src/CommonLib/inc/base.h
index 4dd47a8..b17021c 100644
--- a/src/CommonLib/inc/base.h
+++ b/src/CommonLib/inc/base.h
@@ -1,15 +1,10 @@
 #pragma once
 
-C_HEADER_START
 #include "data_type.h"
 
-#ifndef UNREFERENCED_PARAMETER
 #define UNREFERENCED_PARAMETER(x)   (x);
-#endif // UNREFERENCED_PARAMETER
 
-#ifndef NOTHING
 #define NOTHING                     ;
-#endif // NOTHING
 
 #define MAX_PATH                    260
 
@@ -19,21 +14,17 @@ C_HEADER_START
 #define TB_SIZE                     (1024*GB_SIZE)
 
 #define PAGE_SIZE                   0x1000
-
-#ifndef PAGE_SHIFT
 #define PAGE_SHIFT                  12
-#endif // PAGE_SHIFT
 
 #define SHADOW_STACK_SIZE                   0x20
 
 #define BITS_PER_BYTE                       8
 #define BITS_FOR_STRUCTURE(x)               (BITS_PER_BYTE*sizeof(x))
-#define CREATE_BIT_MASK_FOR_N_BITS(n)       (((n) >= 64) ? MAX_QWORD : (((1ULL << (n)) - 1)))
 
 // The difference between these 2 is the following one:
 // IsFlagOn succeeds if at LEAST a flag is set
 // IsBooleanFlagOn succeeds if ALL flags are set
-#define IsFlagOn(x,f)                       (0!=((x)&(f)))
+#define IsFlagOn(x,f)                       (0!=((x)&(f)))    
 #define IsBooleanFlagOn(x,f)                ((f)==((x)&(f)))
 
 #define BooleanToInteger(x)                 (!!(x))
@@ -50,8 +41,8 @@ C_HEADER_START
 
 // E.g: AlignAddressLower(0x1001,0x1000)   = 0x1000
 //      AlignAddressUpper(0x1001,0x1000)   = 0x2000
-#define AlignAddressLower(addr,alig)        ((QWORD)(addr)&~((QWORD)(alig)-1))
-#define AlignAddressUpper(addr,alig)        AlignAddressLower(((QWORD)(addr)+(alig)-1), (alig))
+#define AlignAddressLower(addr,alig)        ((QWORD)(addr)&~((alig)-1))
+#define AlignAddressUpper(addr,alig)        (((QWORD)(addr)+(alig)-1)&(~((QWORD)(alig)-1)))
 #define IsAddressAligned(addr,alig)         (0==(((QWORD)(addr))&(((QWORD)(alig))-1)))
 
 #define AddressOffset(addr,alig)            ((QWORD)(addr)&((alig)-1))
@@ -73,32 +64,25 @@ C_HEADER_START
 
 // The stack must be aligned at 0x10 bytes - this must be done before
 // the return address is pushed on the stack => the RA is aligned at 0x8 bytes
-//
+// 
 // push arg3
 // push arg2
 // push arg1
-// push arg0
+// push arg0   
 // call func  <-  rsp is 0x10 aligned
 
 // func:
 // mov  edi, edi  <- rsp is 0x8 aligned
-#define IS_STACK_ALIGNED                    IsAddressAligned((PBYTE)_AddressOfReturnAddress()+sizeof(PVOID),NATURAL_ALIGNMENT)
-#define CHECK_STACK_ALIGNMENT               ASSERT_INFO(IS_STACK_ALIGNED, "RSP at 0x%X\n", _AddressOfReturnAddress())
+#define CHECK_STACK_ALIGNMENT               ASSERT_INFO(IsAddressAligned((PBYTE)_AddressOfReturnAddress()+sizeof(PVOID),NATURAL_ALIGNMENT), "RSP at 0x%X\n", _AddressOfReturnAddress())
 #define GET_RETURN_ADDRESS                  *((PVOID*)_AddressOfReturnAddress())
 
-#ifndef CONTAINING_RECORD
 #define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                   (BYTE*)(address) - \
                                                   (QWORD)(&((type *)0)->field)))
-#endif // CONTAINING_RECORD
 
-#ifndef ARRAYSIZE
 #define ARRAYSIZE(A)                            (sizeof(A)/sizeof((A)[0]))
-#endif // ARRAYSIZE
 
-#ifndef FIELD_OFFSET
 #define FIELD_OFFSET(type, field)               ((QWORD)&(((type *)0)->field))
-#endif // FIELD_OFFSET
 
 #define SECTOR_SIZE                             512
 
@@ -122,5 +106,4 @@ typedef BOOLEAN         INTR_STATE;
 //    and if p + ps in [b, b + s]
 // Because ps and s are positive the actual check done is only for
 // p >= b and p + ps <= b + s
-#define CHECK_BOUNDS(p,ps,b,s)      ((((QWORD)(b) <= (QWORD)(p)) )&& (((QWORD)(p) + (QWORD)(ps) ) <= ((QWORD)(b)+(QWORD)(s))))
-C_HEADER_END
+#define CHECK_BOUNDS(p,ps,b,s)      ((((QWORD)(b) <= (QWORD)(p)) )&& (((QWORD)(p) + (QWORD)(ps) ) <= ((QWORD)(b)+(QWORD)(s))))
\ No newline at end of file
diff --git a/src/CommonLib/inc/bitmap.h b/src/CommonLib/inc/bitmap.h
index b19d20f..6a8b1f7 100644
--- a/src/CommonLib/inc/bitmap.h
+++ b/src/CommonLib/inc/bitmap.h
@@ -1,7 +1,5 @@
 #pragma once
 
-C_HEADER_START
-
 #pragma pack(push,16)
 typedef struct _BITMAP
 {
@@ -125,6 +123,4 @@ BitmapScanFromToAndFlip(
     IN          DWORD       FirstInvalidBitIndex,
     IN          DWORD       ConsecutiveBits,
     IN          BOOLEAN     Set
-);
-
-C_HEADER_END
\ No newline at end of file
+);
\ No newline at end of file
diff --git a/src/CommonLib/inc/checkin_queue.h b/src/CommonLib/inc/checkin_queue.h
deleted file mode 100644
index a4dc1b7..0000000
--- a/src/CommonLib/inc/checkin_queue.h
+++ /dev/null
@@ -1,90 +0,0 @@
-#pragma once
-
-C_HEADER_START
-typedef struct _CHECKIN_QUEUE
-{
-    volatile BOOLEAN*       Array;
-
-    DWORD                   NumberOfThreads;
-
-    DWORD                   BufferSize;
-} CHECKIN_QUEUE, * PCHECKIN_QUEUE;
-
-//******************************************************************************
-// Function:     CheckinQueueInit
-// Description:  Pre-Initializes a checkin_queue. No other CheckinQueue* function
-//               can be used before this function is called. The function returns
-//               the needed Buffer size for the internal queue.
-// Returns:      DWORD - The size(in bytes) of the buffer needed for the internal
-//               queue.
-// Parameter:    OUT       PCHECKIN_QUEUE      Queue
-// Parameter:    IN        DWORD               NumberOfThreads
-//******************************************************************************
-DWORD
-CheckinQueuePreInit(
-    OUT       PCHECKIN_QUEUE      Queue,
-    IN        DWORD               NumberOfThreads
-);
-
-//******************************************************************************
-// Function:     CheckinQueueInit
-// Description:  Initializes a checkin_queue.  The checking_queue must be pre-
-//               initialized before by calling CheckinQueuePreInit.
-//               An already allocated array with exactly BufferSize bytes,
-//               returned by the CheckinQueuePreInit function, has to be passed
-//               to this function.
-// Returns:      void
-// Parameter:    INOUT       PCHECKIN_QUEUE      Queue
-// Parameter:    IN          PBYTE               QueueBuffer
-//******************************************************************************
-void
-CheckinQueueInit(
-    INOUT     PCHECKIN_QUEUE      Queue,
-    IN        PBYTE               QueueBuffer
-);
-
-//******************************************************************************
-// Function:     CheckinQueueUninit
-// Description:  Un-initializes the CheckinQueue structure, the memory allocated
-//               for the queue must be de-allocated outside of this function
-//               as from here the reference to the allocated memory zone is lost.
-// Returns:      void
-// Parameter:    INOUT       PCHECKIN_QUEUE      Queue
-//******************************************************************************
-void
-CheckinQueueUninit(
-    INOUT     PCHECKIN_QUEUE      Queue
-);
-
-//******************************************************************************
-// Function:     CheckinQueueMarkPresence
-// Description:  Waits a very little until it can mark a single presence in the
-//               queue. The marking is done atomically.
-// Returns:      void
-// Parameter:    INOUT       PCHECKIN_QUEUE       Queue
-//******************************************************************************
-void
-CheckinQueueMarkPresence(
-    INOUT       PCHECKIN_QUEUE       Queue
-);
-
-//******************************************************************************
-// Function:     CheckinQueueWaitOn
-// Description:  Spins until all threads or CPUs marked there presence inside
-//               the queue or if WaitAll is false, it waits for
-//               NumberOfCheckinsToWait presences. If this number is higher than
-//               the length of the queue, it will wait until the full queue is
-//               marked as present.
-// Returns:      void
-// Parameter:    IN          PCHECKIN_QUEUE      Queue
-// Parameter:    IN          BOOLEAN             WaitAll
-// Parameter:    IN_OPT      DWORD               NumberOfCheckinsToWait
-//******************************************************************************
-void
-CheckinQueueWaitOn(
-    IN          PCHECKIN_QUEUE      Queue,
-    IN          BOOLEAN             WaitAll,
-    IN_OPT      DWORD               NumberOfCheckinsToWait
-);
-
-C_HEADER_END
diff --git a/src/CommonLib/inc/common_lib.h b/src/CommonLib/inc/common_lib.h
index e11aea3..9be84da 100644
--- a/src/CommonLib/inc/common_lib.h
+++ b/src/CommonLib/inc/common_lib.h
@@ -1,27 +1,12 @@
 #pragma once
 
-#ifdef __cplusplus
-#define C_HEADER_START      extern "C" {
-#else
-#define C_HEADER_START
-#endif
-
-#ifdef __cplusplus
-#define C_HEADER_END        }
-#else
-#define C_HEADER_END
-#endif
-
-
-C_HEADER_START
-
 // basic includes
 #include "base.h"
 #include "sal_interface.h"
 #include "status.h"
 #include "va_list.h"
 #include "intutils.h"
-#include "native/memory.h"
+#include "memory.h"
 #include "assert.h"
 
 #pragma pack(push,16)
@@ -48,6 +33,4 @@ typedef struct _COMMON_LIB_INIT
 STATUS
 CommonLibInit(
     IN      PCOMMON_LIB_INIT        InitSettings
-    );
-
-C_HEADER_END
\ No newline at end of file
+    );
\ No newline at end of file
diff --git a/src/CommonLib/inc/data_type.h b/src/CommonLib/inc/data_type.h
index f0b476f..4bea1d5 100644
--- a/src/CommonLib/inc/data_type.h
+++ b/src/CommonLib/inc/data_type.h
@@ -1,12 +1,5 @@
 #pragma once
 
-C_HEADER_START
-
-#pragma warning(push)
-
-// warning C4142: 'DWORD': benign redefinition of type
-#pragma warning(disable:4142)
-
 #ifndef TRUE
 #define TRUE                        ( 1 == 1 )
 #endif
@@ -52,21 +45,10 @@ typedef BYTE                BOOLEAN;
 // VMX operation
 typedef BYTE                VMX_RESULT;
 
-#ifndef CL_DO_NOT_DEFINE_PHYSICAL_ADDRESS
 // physical memory address
 typedef PVOID               PHYSICAL_ADDRESS;
-#endif // CL_DO_NOT_DEFINE_PHYSICAL_ADDRESS
 
 typedef volatile BYTE       VOL_BYTE;
 typedef volatile WORD       VOL_WORD;
 typedef volatile DWORD      VOL_DWORD;
-typedef volatile QWORD      VOL_QWORD;
-
-#ifndef _WCHAR_T_DEFINED
-typedef unsigned short WCHAR;
-#define _WCHAR_T_DEFINED
-#endif  /* _WCHAR_T_DEFINED */
-
-#pragma warning(pop)
-
-C_HEADER_END
+typedef volatile QWORD      VOL_QWORD;
\ No newline at end of file
diff --git a/src/CommonLib/inc/event.h b/src/CommonLib/inc/event.h
index 056409d..0d34e35 100644
--- a/src/CommonLib/inc/event.h
+++ b/src/CommonLib/inc/event.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 typedef enum _EVENT_TYPE
 {
     EventTypeNotification,
@@ -9,8 +8,6 @@ typedef enum _EVENT_TYPE
     EventTypeReserved
 } EVENT_TYPE, *PEVENT_TYPE;
 
-#pragma warning(push)
-
 // nonstandard extension used : nameless struct/union
 #pragma warning(disable:4201)
 typedef struct _EVENT
@@ -18,7 +15,7 @@ typedef struct _EVENT
     volatile BYTE       State;
     EVENT_TYPE          EventType;
 } EVENT, *PEVENT;
-#pragma warning(pop)
+#pragma warning(default:4201)
 
 //******************************************************************************
 // Function:     EvtInitialize
@@ -85,4 +82,3 @@ BOOLEAN
 EvtIsSignaled(
     INOUT   EVENT*          Event
     );
-C_HEADER_END
diff --git a/src/CommonLib/inc/gs_utils.h b/src/CommonLib/inc/gs_utils.h
index 50c04a2..84d3288 100644
--- a/src/CommonLib/inc/gs_utils.h
+++ b/src/CommonLib/inc/gs_utils.h
@@ -1,10 +1,8 @@
 #pragma once
 
-C_HEADER_START
 void
 GSNotifyStackChange(
     IN  PVOID       OldStackBase,
     IN  PVOID       NewStackBase,
     IN  DWORD       StackSize
     );
-C_HEADER_END
diff --git a/src/CommonLib/inc/intutils.h b/src/CommonLib/inc/intutils.h
index a0327a7..b618b88 100644
--- a/src/CommonLib/inc/intutils.h
+++ b/src/CommonLib/inc/intutils.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 // concatenate two BYTEs to make WORD
 #define BYTES_TO_WORD(x,y)                  ((((WORD)(x))<<8)| \
                                               ((WORD)(y)))
@@ -23,13 +22,8 @@ C_HEADER_START
 #define QWORD_HIGH(x)                       (((QWORD)(x))>>32)
 #define QWORD_LOW(x)                        (((QWORD)(x))&MAX_DWORD)
 
-#ifndef max
 #define max(a,b)                            ((a)>(b)?(a):(b))
-#endif // max
-
-#ifndef min
 #define min(a,b)                            ((a)<(b)?(a):(b))
-#endif // min
 
 #define ntohd(x)    ((DWORD)                            \
                     ((((x) >> 24) & 0x0000'00FF)    |   \
@@ -47,4 +41,3 @@ CalculatePercentage(
     IN      QWORD       WholeValue,
     IN      WORD        HundredsOfPercentage
     );
-C_HEADER_END
diff --git a/src/CommonLib/inc/list.h b/src/CommonLib/inc/list.h
index c8d0a52..8a662ef 100644
--- a/src/CommonLib/inc/list.h
+++ b/src/CommonLib/inc/list.h
@@ -27,26 +27,20 @@
 //
 // Iteration is a typical situation where it is necessary to convert from a
 // LIST_ENTRY structure back to its enclosing structure. Here's an example
-// where the fooList is iterated and all the elements whose SomeData field
-// equal DataToSearch are deleted:
+// using fooList:
 //
-// LIST_ITERATOR it;
-// ListIteratorInit(&fooList, &it);
-//
-// PLIST_ENTRY pEntry;
-// while ((pEntry = ListIteratorNext(&it)) != NULL)
-// {
+// for (PLIST_ENTRY pEntry = fooList.Flink;
+//      pEntry != &fooList;
+//      pEntry = pEntry->Flink)
+//  {
 //      PFOO pFoo = CONTAINING_RECORD(pEntry, FOO, Element);
-//      if (pFoo->SomeData == DataToSearch) RemoveEntryList(pEntry);
-// }
+//  }
 //
 // The interface for this list is inspired by the LIST_ENTRY implementation
 // from Microsoft. If you're familiar with those LIST_ENTRY structures, you
 // should find this easy to use.
 //******************************************************************************
 
-C_HEADER_START
-
 #define INVALID_LIST_SIZE       MAX_DWORD
 
 #pragma pack(push,16)
@@ -57,13 +51,6 @@ typedef struct _LIST_ENTRY
 } LIST_ENTRY, *PLIST_ENTRY;
 #pragma pack(pop)
 
-typedef struct _LIST_ITERATOR
-{
-    PLIST_ENTRY                 ListHead;
-
-    PLIST_ENTRY                 CurrentEntry;
-} LIST_ITERATOR, *PLIST_ITERATOR;
-
 typedef
 STATUS
 (__cdecl FUNC_ListFunction) (
@@ -86,8 +73,7 @@ typedef
 INT64
 (__cdecl FUNC_CompareFunction) (
     IN      PLIST_ENTRY     FirstElem,
-    IN      PLIST_ENTRY     SecondElem,
-    IN_OPT  PVOID           Context
+    IN      PLIST_ENTRY     SecondElem
     );
 
 typedef FUNC_CompareFunction*   PFUNC_CompareFunction;
@@ -158,7 +144,7 @@ RemoveHeadList(
     );
 
 //******************************************************************************
-// Function:     RemoveTailList
+// Function:     RemoveHeadList
 // Description:  Removes the tail of the linked list
 // Returns:      PLIST_ENTRY - pointer to the entry removed; If the list was
 //               empty it returns a pointer to the list head
@@ -208,8 +194,7 @@ void
 InsertOrderedList(
     INOUT   PLIST_ENTRY             ListHead,
     INOUT   PLIST_ENTRY             Entry,
-    IN      PFUNC_CompareFunction   CompareFunction,
-    IN_OPT  PVOID                   Context
+    IN      PFUNC_CompareFunction   CompareFunction
     );
 
 //******************************************************************************
@@ -276,19 +261,5 @@ PLIST_ENTRY
 ListSearchForElement(
     IN      PLIST_ENTRY             ListHead,
     IN      PLIST_ENTRY             ElementToSearchFor,
-    IN      BOOLEAN                 IsListOrdered,
-    IN      PFUNC_CompareFunction   CompareFunction,
-    IN_OPT  PVOID                   Context
-    );
-
-void
-ListIteratorInit(
-    IN      PLIST_ENTRY         List,
-    OUT     PLIST_ITERATOR      ListIterator
-    );
-
-PLIST_ENTRY
-ListIteratorNext(
-    INOUT   PLIST_ITERATOR      ListIterator
-    );
-C_HEADER_END
+    IN      PFUNC_CompareFunction   CompareFunction
+    );
\ No newline at end of file
diff --git a/src/CommonLib/inc/lock_common.h b/src/CommonLib/inc/lock_common.h
index a2221a2..a052192 100644
--- a/src/CommonLib/inc/lock_common.h
+++ b/src/CommonLib/inc/lock_common.h
@@ -1,7 +1,5 @@
 #pragma once
 
-C_HEADER_START
-
 #ifndef _COMMONLIB_NO_LOCKS_
 #include "spinlock.h"
 #include "monlock.h"
@@ -115,4 +113,3 @@ LockSystemInit(
     IN      BOOLEAN             MonitorSupport
     );
 #endif // _COMMONLIB_NO_LOCKS_
-C_HEADER_END
diff --git a/src/CommonLib/inc/memory.h b/src/CommonLib/inc/memory.h
new file mode 100644
index 0000000..0f48ca4
--- /dev/null
+++ b/src/CommonLib/inc/memory.h
@@ -0,0 +1,90 @@
+#pragma once
+
+//******************************************************************************
+// Function:        memset
+// Description:     Sets bytes in a memory area to a value.
+// Returns:         void
+// Parameter:       OUT PVOID address    - Address at which to set memory
+// Parameter:       IN  BYTE value       - Value which to set
+// Parameter:       IN  DWORD size       - Number of bytes to set
+//******************************************************************************
+_At_buffer_( address, i, size, _Post_satisfies_( ((PBYTE)address)[i] == value ))
+void
+memset( 
+    OUT_WRITES_BYTES_ALL(size)  PVOID address, 
+    IN                          BYTE value, 
+    IN                          DWORD size 
+    );
+
+#define memzero(addr,size)      memset((addr),0,(size))
+
+//******************************************************************************
+// Function:     memcpy
+// Description:  This function does not guarantee proper handling of overlapped
+//               memory regions. Use memmove in those cases.
+// Returns:      void
+// Parameter:    OUT PVOID Destination
+// Parameter:    IN PVOID Source
+// Parameter:    IN QWORD Count
+//******************************************************************************
+_At_buffer_(Destination,i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+memcpy(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             PVOID   Source,
+    IN                          QWORD   Count
+    );
+
+//******************************************************************************
+// Function:     memmove
+// Description:  Executes slower than memcpy but it can be used for overlapped
+//               memory regions.
+// Returns:      void
+// Parameter:    OUT PVOID Destination
+// Parameter:    IN PVOID Source
+// Parameter:    IN QWORD Count
+//******************************************************************************
+_At_buffer_(Destination, i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+memmove(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             PVOID   Source,
+    IN                          QWORD   Count
+    );
+
+
+//******************************************************************************
+// Function:        memcmp
+// Description:     Compares two memory regions.
+// Returns:         int - 0 if equal, not 0 if different
+// Parameter:       IN PVOID ptr1 - pointer to first memory region
+// Parameter:       IN PVOID ptr2 - pointer to second memory region
+// Parameter:       IN DWORD size - size of region to compare
+//******************************************************************************
+int 
+memcmp(
+    IN_READS_BYTES(size)    PVOID ptr1,
+    IN_READS_BYTES(size)    PVOID ptr2,
+    IN                      DWORD size
+    );
+
+
+//******************************************************************************
+// Function:     memscan
+// Description:  Scans a memory region in search for a different value than the
+//               one received as input.
+// Returns:      int - Index of first byte found different from value. If the
+//               whole buffer contains only value then the return value will be
+//               the size of the buffer.
+// Parameter:    PVOID buffer
+// Parameter:    IN DWORD size
+// Parameter:    IN BYTE value
+//******************************************************************************
+int
+memscan(
+    IN_READS_BYTES(size)    PVOID buffer,
+    IN                      DWORD size,
+    IN                      BYTE  value
+    );
\ No newline at end of file
diff --git a/src/CommonLib/inc/monlock.h b/src/CommonLib/inc/monlock.h
index d89f2a4..0cc59a7 100644
--- a/src/CommonLib/inc/monlock.h
+++ b/src/CommonLib/inc/monlock.h
@@ -1,11 +1,8 @@
 #pragma once
 
-C_HEADER_START
 #define MONITOR_FILTER_SIZE     64
 
 #pragma pack(push,16)
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 typedef struct _MONITOR_LOCK
@@ -17,7 +14,7 @@ typedef struct _MONITOR_LOCK
     };
 } MONITOR_LOCK, *PMONITOR_LOCK;
 
-#pragma warning(pop)
+#pragma warning(default:4201)
 #pragma pack(pop)
 
 void
@@ -47,5 +44,4 @@ void
 MonitorLockRelease(
     INOUT       PMONITOR_LOCK       Lock,
     IN          INTR_STATE          OldIntrState
-    );
-C_HEADER_END
+    );
\ No newline at end of file
diff --git a/src/CommonLib/inc/native/memory.h b/src/CommonLib/inc/native/memory.h
index 59f1788..ab578e6 100644
--- a/src/CommonLib/inc/native/memory.h
+++ b/src/CommonLib/inc/native/memory.h
@@ -2,13 +2,9 @@
 
 #include "cl_memory.h"
 
-#ifndef CL_NON_NATIVE
-
-#define memset              cl_memset
-#define memzero             cl_memzero
-#define memcpy              cl_memcpy
-#define memmove             cl_memmove
-#define memcmp              cl_memcmp
-#define rmemcmp             cl_rmemcmp
-#define memscan             cl_memscan
-#endif // CL_NON_NATIVE
+#define memset          cl_memset
+#define memzero         cl_memzero
+#define memcpy          cl_memcpy
+#define memmove         cl_memmove
+#define memcmp          cl_memcmp
+#define memscan         cl_memscan
diff --git a/src/CommonLib/inc/native/string.h b/src/CommonLib/inc/native/string.h
index 7986638..c8b7fcd 100644
--- a/src/CommonLib/inc/native/string.h
+++ b/src/CommonLib/inc/native/string.h
@@ -2,22 +2,15 @@
 
 #include "cl_string.h"
 
-#ifndef CL_NON_NATIVE
-
-#define strcmp                  cl_strcmp
-#define stricmp                 cl_stricmp
-#define strncmp                 cl_strncmp
-#define strchr                  cl_strchr
-#define strrchr                 cl_strrchr
-#define strcpy                  cl_strcpy
-#define strncpy                 cl_strncpy
-#define strlen                  cl_strlen
-#define strlen_s                cl_strlen_s
-#define snprintf                cl_snprintf
-#define sprintf                 cl_sprintf
-#define vsnprintf               cl_vsnprintf
-#define strtok_s                cl_strtok_s
-#define strcelem                cl_strcelem
-#define strtrim                 cl_strtrim
-
-#endif // CL_NON_NATIVE
+#define strcmp          cl_strcmp           
+#define stricmp         cl_stricmp          
+#define strncmp         cl_strncmp          
+#define strnicmp        cl_strnicmp
+#define strchr          cl_strchr
+#define strrchr         cl_strrchr
+#define strcpy          cl_strcpy
+#define strncpy         cl_strncpy
+#define snprintf        cl_snprintf
+#define sprintf         cl_sprintf
+#define vsnprintf       cl_vsnprintf
+#define strtok_s        cl_strtok_s
\ No newline at end of file
diff --git a/src/CommonLib/inc/rec_rw_spinlock.h b/src/CommonLib/inc/rec_rw_spinlock.h
index 14bfb66..00af3d5 100644
--- a/src/CommonLib/inc/rec_rw_spinlock.h
+++ b/src/CommonLib/inc/rec_rw_spinlock.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 #include "rw_spinlock.h"
 
 #pragma pack(push,16)
@@ -38,7 +37,7 @@ _When_(Exclusive, ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Spinlock))
 _When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RecRwSpinlockAcquire(
-    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    INOUT   PREC_RW_SPINLOCK    Spinlock,
     OUT     INTR_STATE*         IntrState,
     IN      BOOLEAN             Exclusive
     );
@@ -50,11 +49,10 @@ _When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_REENTRANT_LOCK
 _When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RecRwSpinlockRelease(
-    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    INOUT   PREC_RW_SPINLOCK    Spinlock,
     IN      INTR_STATE          IntrState,
     IN      BOOLEAN             Exclusive
     );
 
 #define RecRwSpinlockReleaseShared(Lck,Intr)      RecRwSpinlockRelease((Lck),(Intr),FALSE)
-#define RecRwSpinlockReleaseExclusive(Lck,Intr)   RecRwSpinlockRelease((Lck),(Intr),TRUE)
-C_HEADER_END
+#define RecRwSpinlockReleaseExclusive(Lck,Intr)   RecRwSpinlockRelease((Lck),(Intr),TRUE)
\ No newline at end of file
diff --git a/src/CommonLib/inc/ref_cnt.h b/src/CommonLib/inc/ref_cnt.h
index 0072769..37a1079 100644
--- a/src/CommonLib/inc/ref_cnt.h
+++ b/src/CommonLib/inc/ref_cnt.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 //******************************************************************************
 // Function:     FUNC_FreeFunction
 // Description:  Function called when the ReferenceCount of the object reaches 0
@@ -69,5 +68,4 @@ SIZE_SUCCESS
 DWORD
 RfcDereference(
     INOUT   REF_COUNT*              Object
-    );
-C_HEADER_END
+    );
\ No newline at end of file
diff --git a/src/CommonLib/inc/rw_spinlock.h b/src/CommonLib/inc/rw_spinlock.h
index 48918a6..b1194b8 100644
--- a/src/CommonLib/inc/rw_spinlock.h
+++ b/src/CommonLib/inc/rw_spinlock.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 #pragma pack(push,16)
 typedef struct _RW_SPINLOCK
 {
@@ -22,7 +21,7 @@ _When_(Exclusive, ACQUIRES_EXCL_AND_NON_REENTRANT_LOCK(*Spinlock))
 _When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RwSpinlockAcquire(
-    INOUT   RW_SPINLOCK     *Spinlock,
+    INOUT   PRW_SPINLOCK    Spinlock,
     OUT     INTR_STATE*     IntrState,
     IN      BOOLEAN         Exclusive
     );
@@ -34,11 +33,10 @@ _When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_NON_REENTRANT_
 _When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RwSpinlockRelease(
-    INOUT   RW_SPINLOCK     *Spinlock,
+    INOUT   PRW_SPINLOCK    Spinlock,
     IN      INTR_STATE      IntrState,
     IN      BOOLEAN         Exclusive
     );
 
 #define RwSpinlockReleaseShared(Lck,Intr)      RwSpinlockRelease((Lck),(Intr),FALSE)
-#define RwSpinlockReleaseExclusive(Lck,Intr)   RwSpinlockRelease((Lck),(Intr),TRUE)
-C_HEADER_END
+#define RwSpinlockReleaseExclusive(Lck,Intr)   RwSpinlockRelease((Lck),(Intr),TRUE)
\ No newline at end of file
diff --git a/src/CommonLib/inc/sal_interface.h b/src/CommonLib/inc/sal_interface.h
index 940103b..872f055 100644
--- a/src/CommonLib/inc/sal_interface.h
+++ b/src/CommonLib/inc/sal_interface.h
@@ -1,17 +1,14 @@
 #pragma once
 
-C_HEADER_START
 #include <sal.h>
 
+#define SAL_SUCCESS                                 _Success_(SUCCEEDED(return))
 #define PTR_SUCCESS                                 _Success_(NULL != return)
 #define SIZE_SUCCESS                                _Success_(MAX_DWORD != return)
 #define BOOL_SUCCESS                                _Success_(TRUE == return)
 
 // The IN arguments must always be constants :)
-#ifndef IN
 #define IN                                          _In_ const
-#endif // IN
-
 #define IN_Z                                        _In_z_ const
 #define IN_OPT                                      _In_opt_ const
 #define IN_OPT_Z                                    _In_opt_z_ const
@@ -30,10 +27,7 @@ C_HEADER_START
 #define INOUT_UPDATES_TO(x,y)                       _Inout_updates_to_((x),(y))
 #define INOUT_UPDATES_ALL(x)                        _Inout_updates_all_((x))
 
-#ifndef OUT
 #define OUT                                         _Out_
-#endif // OUT
-
 #define OUT_Z                                       __out_z
 #define OUT_PTR                                     _Outptr_
 #define OUT_PTR_MAYBE_NULL                          _Outptr_result_maybenull_
@@ -70,5 +64,4 @@ C_HEADER_START
 // return types
 #define RET_NOT_NULL                                _Ret_notnull_
 
-#include "sal_intrinsic.h"
-C_HEADER_END
+#include "sal_intrinsic.h"
\ No newline at end of file
diff --git a/src/CommonLib/inc/sal_intrinsic.h b/src/CommonLib/inc/sal_intrinsic.h
index 3d0d68f..6cfbb17 100644
--- a/src/CommonLib/inc/sal_intrinsic.h
+++ b/src/CommonLib/inc/sal_intrinsic.h
@@ -1,18 +1,6 @@
 #pragma once
 
-C_HEADER_START
-#ifndef CL_NON_NATIVE
-#pragma warning(push)
-
-// warning C4391: incorrect return type for intrinsic function
-#pragma warning(disable:4391)
-
 // annotations for some intrinsics
-PVOID
-_AddressOfReturnAddress(
-    void
-    );
-
 void
 __cpuid(
     OUT_WRITES_ALL(4)    int cpuInfo[4],
@@ -49,17 +37,12 @@ __movsq(
 _Success_(return == 0)
 VMX_RESULT
 __vmx_vmread(
-    IN   DWORD  Field,
+    IN   QWORD  Field,
     OUT  QWORD* FieldValue
     );
 
-_Success_(return == 0)
-VMX_RESULT
-__vmx_vmwrite(
-    IN   DWORD  Field,
-    IN   QWORD  FieldValue
-    );
-
+// warning C4391: incorrect return type for intrinsic function
+#pragma warning(disable:4391)
 PVOID
 __readcr2(
     void
@@ -83,7 +66,7 @@ __writecr8(
 
 BYTE
 _InterlockedExchange8(
-    INOUT _Interlocked_operand_
+    INOUT _Interlocked_operand_ 
         BYTE volatile * _Target,
     IN  BYTE _Value
     );
@@ -95,9 +78,9 @@ _InterlockedIncrement(
 
 BYTE
 _InterlockedCompareExchange8(
-    INOUT _Interlocked_operand_
-        BYTE volatile * _Destination,
-    IN  BYTE _Exchange,
+    INOUT _Interlocked_operand_ 
+        BYTE volatile * _Destination, 
+    IN  BYTE _Exchange, 
     IN  BYTE _Comparand
     );
 
@@ -107,15 +90,15 @@ _InterlockedDecrement16(
     );
 
 DWORD _InterlockedCompareExchange(
-    INOUT _Interlocked_operand_
-        DWORD volatile * _Destination,
+    INOUT _Interlocked_operand_ 
+        DWORD volatile * _Destination, 
     IN  DWORD _Exchange,
     IN  DWORD _Comparand
     );
 
 WORD
 _InterlockedCompareExchange16(
-    INOUT _Interlocked_operand_
+    INOUT _Interlocked_operand_ 
         WORD volatile *Destination,
     IN  WORD ExChange,
     IN  WORD Comperand
@@ -123,7 +106,7 @@ _InterlockedCompareExchange16(
 
 WORD
 _InterlockedOr16(
-    INOUT _Interlocked_operand_
+    INOUT _Interlocked_operand_ 
         WORD volatile *Destination,
     IN  WORD Value
     );
@@ -133,29 +116,8 @@ _InterlockedIncrement16(
     INOUT _Interlocked_operand_ WORD volatile *Destination
     );
 
-DWORD
+DWORD 
 _InterlockedDecrement(
     INOUT _Interlocked_operand_ DWORD volatile * _Addend
     );
-
-_Success_(return == TRUE)
-BOOLEAN
-_rdrand16_step(
-    OUT WORD*       Value
-    );
-
-_Success_(return == TRUE)
-BOOLEAN
-_rdrand32_step(
-    OUT DWORD*      Value
-    );
-
-_Success_(return == TRUE)
-BOOLEAN
-_rdrand64_step(
-    OUT QWORD*      Value
-    );
-
-#pragma warning(pop)
-#endif // CL_NON_NATIVE
-C_HEADER_END
+#pragma warning(default:4391)
\ No newline at end of file
diff --git a/src/CommonLib/inc/spinlock.h b/src/CommonLib/inc/spinlock.h
index 0d489d7..35bc0b1 100644
--- a/src/CommonLib/inc/spinlock.h
+++ b/src/CommonLib/inc/spinlock.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 #pragma pack(push,16)
 typedef struct _SPINLOCK
 {
@@ -78,4 +77,3 @@ SpinlockRelease(
     INOUT       PSPINLOCK       Lock,
     IN          INTR_STATE      OldIntrState
     );
-C_HEADER_END
diff --git a/src/CommonLib/inc/status.h b/src/CommonLib/inc/status.h
index 7f657ec..597aacf 100644
--- a/src/CommonLib/inc/status.h
+++ b/src/CommonLib/inc/status.h
@@ -1,366 +1,184 @@
 #pragma once
 
-C_HEADER_START
-
-// every error/warning status code has the MSB set to 1
-#define FAIL_MASK                                       (1UL << 31)
-
-#define ERROR_MASK                                      (0b11UL << 30)
-#define WARNING_MASK                                    (0b10UL << 30)
-#define INFO_MASK                                       (0b01UL << 30)
-
-#define CUSTOMER_BIT                                    (1UL << 29)
+// every error status code has the MSB set to 1
+#define FAIL_MASK                                       (1<<31)
+#define WARNING_MASK                                    (1<<30)
+#define INFO_MASK                                       (1<<29)
 
 // nothing over (1<<27) should be used
-#define GENERAL_MASK                                    (1UL<<27)
-#define INTRO_MASK                                      (1UL<<26)
-#define VMX_MASK                                        (1UL<<25)
-#define CPU_MASK                                        (1UL<<24)
-#define COMM_MASK                                       (1UL<<23)
-#define TIMER_MASK                                      (1UL<<22)
-#define HEAP_MASK                                       (1UL<<21)
-#define MEMORY_MASK                                     (1UL<<20)
-#define STORAGE_MASK                                    (1UL<<19)
-#define DISK_MASK                                       (1UL<<18)
-#define APIC_MASK                                       (1UL<<17)
-#define DEVICE_MASK                                     (1UL<<16)
-#define RESERVED_MASK                                   (1UL<<16)
+#define GENERAL_MASK                                    (1<<27)
+#define INTRO_MASK                                      (1<<26)
+#define VMX_MASK                                        (1<<25)
+#define CPU_MASK                                        (1<<24)
+#define COMM_MASK                                       (1<<23)
+#define TIMER_MASK                                      (1<<22)
+#define HEAP_MASK                                       (1<<21)
+#define MEMORY_MASK                                     (1<<20)
+#define STORAGE_MASK                                    (1<<19)
+#define DISK_MASK                                       (1<<18)
+#define APIC_MASK                                       (1<<17)
+#define DEVICE_MASK                                     (1<<16)
+#define RESERVED_MASK                                   (1<<16)
 // nothing under (1<<16) should be used
 
 // general errors
-#define CL_STATUS_UNSUPPORTED                              (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0001UL)
-#define CL_STATUS_INTERNAL_ERROR                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0002UL)
-#define CL_STATUS_UNSUCCESSFUL                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0003UL)
-#define CL_STATUS_ELEMENT_NOT_FOUND                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0004UL)
-#define CL_STATUS_ELEMENT_FOUND                            (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0005UL)
-#define CL_STATUS_LIST_EMPTY                               (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0006UL)
-#define CL_STATUS_ALREADY_INITIALIZED                      (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0007UL)
-#define CL_STATUS_ALREADY_INITIALIZED_HINT                 (INFO_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0008UL)
-#define CL_STATUS_INCOMPATIBLE_INTERFACE                   (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0009UL)
-#define CL_STATUS_INVALID_PARAMETER1                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0011UL)
-#define CL_STATUS_INVALID_PARAMETER2                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0012UL)
-#define CL_STATUS_INVALID_PARAMETER3                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0013UL)
-#define CL_STATUS_INVALID_PARAMETER4                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0014UL)
-#define CL_STATUS_INVALID_PARAMETER5                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0015UL)
-#define CL_STATUS_INVALID_PARAMETER6                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0016UL)
-#define CL_STATUS_INVALID_PARAMETER7                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0017UL)
-#define CL_STATUS_INVALID_PARAMETER8                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0018UL)
-#define CL_STATUS_INVALID_FILE_NAME                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0019UL)
-#define CL_STATUS_FILE_NOT_FOUND                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001AUL)
-#define CL_STATUS_FILE_TYPE_INVALID                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001BUL)
-#define CL_STATUS_TIME_INVALID                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001CUL)
-#define CL_STATUS_PATH_NOT_VALID                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001DUL)
-#define CL_STATUS_FILE_ALREADY_EXISTS                      (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001EUL)
-#define CL_STATUS_FILE_NOT_DIRECTORY                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001FUL)
-#define CL_STATUS_NO_MORE_OBJECTS                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0020UL)
-#define CL_STATUS_PARSE_FAILED                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0021UL)
-#define CL_STATUS_JOB_INTERRUPTED                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0022UL)
-#define CL_STATUS_INVALID_MZ_IMAGE                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0023UL)
-#define CL_STATUS_INVALID_IMAGE_SIZE                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0024UL)
-#define CL_STATUS_INVALID_PE_IMAGE                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0025UL)
-#define CL_STATUS_IMAGE_NOT_64_BIT                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0026UL)
-#define CL_STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE               (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0027UL)
-#define CL_STATUS_IMAGE_NOT_FULLY_LOADED                   (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0028UL)
-#define CL_STATUS_IMAGE_HAS_RELOCATIONS                    (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0029UL)
-#define CL_STATUS_NOT_IMPLEMENTED                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002AUL)
-#define CL_STATUS_INVALID_FUNCTION                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002BUL)
-#define CL_STATUS_INVALID_BUFFER                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002CUL)
-#define CL_STATUS_NOT_INITIALIZED                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002DUL)
-#define CL_STATUS_NO_HANDLING_REQUIRED                     (INFO_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002EUL)
-#define CL_STATUS_CONFLICTING_OPTIONS                      (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002FUL)
-#define CL_STATUS_ASSERTION_FAILURE                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0030UL)
-#define CL_STATUS_NO_DATA_AVAILABLE                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0031UL)
-#define CL_STATUS_LIMIT_REACHED                            (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0032UL)
-#define CL_STATUS_SIZE_INVALID                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0033UL)
-#define CL_STATUS_VALUE_MISMATCH                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0034UL)
-#define CL_STATUS_OPERATION_REQUIRES_HIGHER_CPL            (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0035UL)
+#define STATUS_UNSUPPORTED                              (FAIL_MASK | GENERAL_MASK | 0x0001UL)
+#define STATUS_INTERNAL_ERROR                           (FAIL_MASK | GENERAL_MASK | 0x0002UL)
+#define STATUS_UNSUCCESSFUL                             (FAIL_MASK | GENERAL_MASK | 0x0003UL)
+#define STATUS_ELEMENT_NOT_FOUND                        (FAIL_MASK | GENERAL_MASK | 0x0004UL)
+#define STATUS_ELEMENT_FOUND                            (FAIL_MASK | GENERAL_MASK | 0x0005UL)
+#define STATUS_LIST_EMPTY                               (FAIL_MASK | GENERAL_MASK | 0x0006UL)
+#define STATUS_ALREADY_INITIALIZED                      (FAIL_MASK | GENERAL_MASK | 0x0007UL)
+#define STATUS_ALREADY_INITIALIZED_HINT                 (WARNING_MASK | GENERAL_MASK | 0x0008UL )
+#define STATUS_INCOMPATIBLE_INTERFACE                   (FAIL_MASK | GENERAL_MASK | 0x0009UL )
+#define STATUS_INVALID_PARAMETER1                       (FAIL_MASK | GENERAL_MASK | 0x0011UL)
+#define STATUS_INVALID_PARAMETER2                       (FAIL_MASK | GENERAL_MASK | 0x0012UL)
+#define STATUS_INVALID_PARAMETER3                       (FAIL_MASK | GENERAL_MASK | 0x0013UL)
+#define STATUS_INVALID_PARAMETER4                       (FAIL_MASK | GENERAL_MASK | 0x0014UL)
+#define STATUS_INVALID_PARAMETER5                       (FAIL_MASK | GENERAL_MASK | 0x0015UL)
+#define STATUS_INVALID_PARAMETER6                       (FAIL_MASK | GENERAL_MASK | 0x0016UL)
+#define STATUS_INVALID_PARAMETER7                       (FAIL_MASK | GENERAL_MASK | 0x0017UL)
+#define STATUS_INVALID_PARAMETER8                       (FAIL_MASK | GENERAL_MASK | 0x0018UL)
+#define STATUS_INVALID_FILE_NAME                        (FAIL_MASK | GENERAL_MASK | 0x0019UL)
+#define STATUS_FILE_NOT_FOUND                           (FAIL_MASK | GENERAL_MASK | 0x001AUL)
+#define STATUS_FILE_TYPE_INVALID                        (FAIL_MASK | GENERAL_MASK | 0x001BUL)
+#define STATUS_TIME_INVALID                             (FAIL_MASK | GENERAL_MASK | 0x001CUL)
+#define STATUS_PATH_NOT_VALID                           (FAIL_MASK | GENERAL_MASK | 0x001DUL)
+#define STATUS_FILE_ALREADY_EXISTS                      (FAIL_MASK | GENERAL_MASK | 0x001EUL)
+#define STATUS_FILE_NOT_DIRECTORY                       (FAIL_MASK | GENERAL_MASK | 0x001FUL)
+#define STATUS_NO_MORE_OBJECTS                          (FAIL_MASK | GENERAL_MASK | 0x0020UL)
+#define STATUS_PARSE_FAILED                             (FAIL_MASK | GENERAL_MASK | 0x0021UL)
+#define STATUS_JOB_INTERRUPTED                          (FAIL_MASK | GENERAL_MASK | 0x0022UL)
+#define STATUS_INVALID_MZ_IMAGE                         (FAIL_MASK | GENERAL_MASK | 0x0023UL)
+#define STATUS_INVALID_IMAGE_SIZE                       (FAIL_MASK | GENERAL_MASK | 0x0024UL)
+#define STATUS_INVALID_PE_IMAGE                         (FAIL_MASK | GENERAL_MASK | 0x0025UL)
+#define STATUS_IMAGE_NOT_64_BIT                         (FAIL_MASK | GENERAL_MASK | 0x0026UL)
+#define STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE               (FAIL_MASK | GENERAL_MASK | 0x0027UL)
+#define STATUS_IMAGE_NOT_FULLY_LOADED                   (FAIL_MASK | GENERAL_MASK | 0x0028UL)
+#define STATUS_IMAGE_HAS_RELOCATIONS                    (FAIL_MASK | GENERAL_MASK | 0x0029UL)
+#define STATUS_NOT_IMPLEMENTED                          (FAIL_MASK | GENERAL_MASK | 0x002AUL)
+#define STATUS_INVALID_FUNCTION                         (FAIL_MASK | GENERAL_MASK | 0x002BUL)
+#define STATUS_INVALID_BUFFER                           (FAIL_MASK | GENERAL_MASK | 0x002CUL)
+#define STATUS_NOT_INITIALIZED                          (FAIL_MASK | GENERAL_MASK | 0x002DUL)
+#define STATUS_NO_HANDLING_REQUIRED                     (INFO_MASK | GENERAL_MASK | 0x002EUL)
+#define STATUS_CONFLICTING_OPTIONS                      (FAIL_MASK | GENERAL_MASK | 0x002FUL)
+#define STATUS_ASSERTION_FAILURE                        (FAIL_MASK | GENERAL_MASK | 0x0030UL)
+#define STATUS_NO_DATA_AVAILABLE                        (FAIL_MASK | GENERAL_MASK | 0x0031UL)
+#define STATUS_LIMIT_REACHED                            (FAIL_MASK | GENERAL_MASK | 0x0032UL)
 
 // introspection errors
-#define CL_STATUS_INTRO_INVALID_SYSCALL_HANDLER            (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0001UL )
-#define CL_STATUS_INTRO_KERNEL_BASE_NOT_FOUND              (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0002UL )
-#define CL_STATUS_INTRO_KERNEL_INVALID_IMAGE               (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0003UL )
-#define CL_STATUS_INTRO_EXPORT_NOT_FOUND                   (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0004UL )
-#define CL_STATUS_INTRO_MODULE_LIST_NOT_FOUND              (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0005UL )
-#define CL_STATUS_INTRO_PCR_NOT_AVAILABLE                  (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0006UL )
-#define CL_STATUS_INTRO_KERNEL_ADDRESS_INVALID             (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0007UL )
-#define CL_STATUS_INTRO_VARIABLES_NOT_DEFINED              (INFO_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0008UL )
-#define CL_STATUS_INTRO_INTROSPECTION_NOT_SUPPORTED        (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0009UL )
-#define CL_STATUS_INTRO_PROCESS_NOT_VALID                  (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000AUL )
-#define CL_STATUS_INTRO_PATTERN_NOT_FOUND                  (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000BUL )
-#define CL_STATUS_INTRO_INTROSPECTION_NOT_INITIALIZED      (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000CUL )
-#define CL_STATUS_INTRO_DEBUGGER_DATA_NOT_FOUND            (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000DUL )
+#define STATUS_INTRO_INVALID_SYSCALL_HANDLER            (FAIL_MASK | INTRO_MASK | 0x0001UL )
+#define STATUS_INTRO_KERNEL_BASE_NOT_FOUND              (FAIL_MASK | INTRO_MASK | 0x0002UL )
+#define STATUS_INTRO_KERNEL_INVALID_IMAGE               (FAIL_MASK | INTRO_MASK | 0x0003UL )
+#define STATUS_INTRO_EXPORT_NOT_FOUND                   (FAIL_MASK | INTRO_MASK | 0x0004UL )
+#define STATUS_INTRO_MODULE_LIST_NOT_FOUND              (FAIL_MASK | INTRO_MASK | 0x0005UL )
+#define STATUS_INTRO_PCR_NOT_AVAILABLE                  (FAIL_MASK | INTRO_MASK | 0x0006UL )
+#define STATUS_INTRO_KERNEL_ADDRESS_INVALID             (FAIL_MASK | INTRO_MASK | 0x0007UL )
+#define STATUS_INTRO_VARIABLES_NOT_DEFINED              (WARNING_MASK | INTRO_MASK | 0x0008UL )
+#define STATUS_INTRO_INTROSPECTION_NOT_SUPPORTED        (FAIL_MASK | INTRO_MASK | 0x0009UL )
+#define STATUS_INTRO_PROCESS_NOT_VALID                  (FAIL_MASK | INTRO_MASK | 0x000AUL )
+#define STATUS_INTRO_PATTERN_NOT_FOUND                  (FAIL_MASK | INTRO_MASK | 0x000BUL )
+#define STATUS_INTRO_INTROSPECTION_NOT_INITIALIZED      (FAIL_MASK | INTRO_MASK | 0x000CUL )
+#define STATUS_INTRO_DEBUGGER_DATA_NOT_FOUND            (FAIL_MASK | INTRO_MASK | 0x000DUL )
 
 // vmx related issues
-#define CL_STATUS_VMX_WRITE_FAILED                         (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0001UL )
-#define CL_STATUS_VMX_READ_FAILED                          (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0002UL )
-#define CL_STATUS_VMX_INVEPT_FAILED                        (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0003UL )
-#define CL_STATUS_VMX_EPT_MAPPING_FAILED                   (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0004UL )
-#define CL_STATUS_VMX_EXIT_NOT_IMPLEMENTED                 (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0005UL )
-#define CL_STATUS_VMX_FEATURE_NOT_SUPPORTED                (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0006UL )
-#define CL_STATUS_VMX_UNEXPECTED_VMCALL                    (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0007UL )
-#define CL_STATUS_VMX_GUEST_MEMORY_CANNOT_BE_MAPPED        (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0008UL )
-#define CL_STATUS_VMX_NO_CALLBACKS                         (WARNING_MASK | CUSTOMER_BIT | VMX_MASK | 0x0009UL )
-#define CL_STATUS_VMX_INCOMPATIBLE_CONFIGURATION           (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x000AUL )
+#define STATUS_VMX_WRITE_FAILED                         (FAIL_MASK | VMX_MASK | 0x0001UL )
+#define STATUS_VMX_READ_FAILED                          (FAIL_MASK | VMX_MASK | 0x0002UL )
+#define STATUS_VMX_INVEPT_FAILED                        (FAIL_MASK | VMX_MASK | 0x0003UL )
+#define STATUS_VMX_EPT_MAPPING_FAILED                   (FAIL_MASK | VMX_MASK | 0x0004UL )
+#define STATUS_VMX_EXIT_NOT_IMPLEMENTED                 (FAIL_MASK | VMX_MASK | 0x0005UL )
+#define STATUS_VMX_FEATURE_NOT_SUPPORTED                (FAIL_MASK | VMX_MASK | 0x0006UL )
+#define STATUS_VMX_UNEXPECTED_VMCALL                    (FAIL_MASK | VMX_MASK | 0x0007UL )
+#define STATUS_VMX_GUEST_MEMORY_CANNOT_BE_MAPPED        (FAIL_MASK | VMX_MASK | 0x0008UL )
 
 // cpu related errors
-#define CL_STATUS_CPU_UNSUPPORTED_FEATURE                  (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0001UL)
-#define CL_STATUS_CPU_MONITOR_NOT_SUPPORTED                (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0002UL)
-#define CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL        (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0003UL)
-#define CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE        (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0004UL)
-#define CL_STATUS_CPU_NO_MATCHES                           (INFO_MASK | CUSTOMER_BIT | CPU_MASK | 0x0005UL)
-#define CL_STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE        (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0006UL)
+#define STATUS_CPU_UNSUPPORTED_FEATURE                  (FAIL_MASK | CPU_MASK | 0x0001UL)
+#define STATUS_CPU_MONITOR_NOT_SUPPORTED                (FAIL_MASK | CPU_MASK | 0x0002UL)
+#define STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL        (FAIL_MASK | CPU_MASK | 0x0003UL)
+#define STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE        (FAIL_MASK | CPU_MASK | 0x0004UL)
+#define STATUS_CPU_NO_MATCHES                           (WARNING_MASK | CPU_MASK | 0x0005UL)
 
 // communication related errors
-#define CL_STATUS_COMM_SERIAL_ALREADY_INITIALIZED          (INFO_MASK | CUSTOMER_BIT | COMM_MASK | 0x0001UL)
-#define CL_STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE           (INFO_MASK | CUSTOMER_BIT | COMM_MASK | 0x0002UL)
-#define CL_STATUS_COMM_SERIAL_NOT_INITIALIZED              (ERROR_MASK | CUSTOMER_BIT | COMM_MASK | 0x0003UL)
-#define CL_STATUS_COMM_VMCALL_UNSUPPORTED_COMMAND          (ERROR_MASK | CUSTOMER_BIT | COMM_MASK | 0x0004UL)
+#define STATUS_COMM_SERIAL_ALREADY_INITIALIZED          (WARNING_MASK | COMM_MASK | 0x0001UL)
+#define STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE           (WARNING_MASK | COMM_MASK | 0x0002UL)
+#define STATUS_COMM_SERIAL_NOT_INITIALIZED              (FAIL_MASK | COMM_MASK | 0x0003UL)
+#define STATUS_COMM_VMCALL_UNSUPPORTED_COMMAND          (FAIL_MASK | COMM_MASK | 0x0004UL)
 
 // timer related errors
-#define CL_STATUS_TIMER_INVALID_FREQUENCY                  (ERROR_MASK | CUSTOMER_BIT | TIMER_MASK | 0x0001UL)
+#define STATUS_TIMER_INVALID_FREQUENCY                  (FAIL_MASK | TIMER_MASK | 0x0001UL)
 
 // heap related errors
-#define CL_STATUS_HEAP_TOO_SMALL                           (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0001UL)
-#define CL_STATUS_HEAP_ALREADY_INITIALIZED                 (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0002UL)
-#define CL_STATUS_HEAP_NO_MORE_MEMORY                      (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0003UL)
-#define CL_STATUS_HEAP_INSUFFICIENT_RESOURCES              (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0004UL)
+#define STATUS_HEAP_TOO_SMALL                           (FAIL_MASK | HEAP_MASK | 0x0001UL)
+#define STATUS_HEAP_ALREADY_INITIALIZED                 (FAIL_MASK | HEAP_MASK | 0x0002UL)
+#define STATUS_HEAP_NO_MORE_MEMORY                      (FAIL_MASK | HEAP_MASK | 0x0003UL)
+#define STATUS_HEAP_INSUFFICIENT_RESOURCES              (FAIL_MASK | HEAP_MASK | 0x0004UL)
 
 // memory related errors
-#define CL_STATUS_INVALID_POINTER                          (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0001UL)
-#define CL_STATUS_BUFFER_TOO_SMALL                         (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0002UL)
-#define CL_STATUS_INSUFFICIENT_MEMORY                      (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0003UL)
-#define CL_STATUS_MEMORY_CANNOT_BE_MAPPED                  (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0004UL)
-#define CL_STATUS_PHYSICAL_MEMORY_TOO_SMALL                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0005UL)
-#define CL_STATUS_MEMORY_IS_NOT_RESERVED                   (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0006UL)
-#define CL_STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE            (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0007UL)
-#define CL_STATUS_PAT_LAYOUT_NOT_COMPATIBLE                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0008UL)
-#define CL_STATUS_MEMORY_CANNOT_BE_RESERVED                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0009UL)
-#define CL_STATUS_MEMORY_ACCESS_DENIED                     (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000AUL)
-#define CL_STATUS_MEMORY_CANNOT_BE_COMMITED                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000BUL)
-#define CL_STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS         (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000CUL)
-#define CL_STATUS_MEMORY_CONFLICTING_CACHEABILITY          (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000DUL)
-#define CL_STATUS_BUFFER_TOO_LARGE                         (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000EUL)
-#define CL_STATUS_MEMORY_ALREADY_RESERVED                  (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000FUL)
-#define CL_STATUS_MEMORY_IS_NOT_COMMITED                   (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0010UL)
-#define CL_STATUS_MEMORY_PREVENTS_USERMODE_ACCESS          (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0011UL)
-#define CL_STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS        (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0012UL)
-#define CL_STATUS_PHYSICAL_MEMORY_QUOTA_EXCEEDED           (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0013UL)
+#define STATUS_INVALID_POINTER                          (FAIL_MASK | MEMORY_MASK | 0x0001UL)
+#define STATUS_BUFFER_TOO_SMALL                         (FAIL_MASK | MEMORY_MASK | 0x0002UL)
+#define STATUS_INSUFFICIENT_MEMORY                      (FAIL_MASK | MEMORY_MASK | 0x0003UL)
+#define STATUS_MEMORY_CANNOT_BE_MAPPED                  (FAIL_MASK | MEMORY_MASK | 0x0004UL)
+#define STATUS_PHYSICAL_MEMORY_TOO_SMALL                (FAIL_MASK | MEMORY_MASK | 0x0005UL)
+#define STATUS_MEMORY_IS_NOT_RESERVED                   (FAIL_MASK | MEMORY_MASK | 0x0006UL)
+#define STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE            (FAIL_MASK | MEMORY_MASK | 0x0007UL)
+#define STATUS_PAT_LAYOUT_NOT_COMPATIBLE                (FAIL_MASK | MEMORY_MASK | 0x0008UL)
+#define STATUS_MEMORY_CANNOT_BE_RESERVED                (FAIL_MASK | MEMORY_MASK | 0x0009UL)
+#define STATUS_MEMORY_ACCESS_DENIED                     (FAIL_MASK | MEMORY_MASK | 0x000AUL)
+#define STATUS_MEMORY_CANNOT_BE_COMMITED                (FAIL_MASK | MEMORY_MASK | 0x000BUL)
+#define STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS         (FAIL_MASK | MEMORY_MASK | 0x000CUL)
+#define STATUS_MEMORY_CONFLICTING_CACHEABILITY          (FAIL_MASK | MEMORY_MASK | 0x000DUL)
+#define STATUS_BUFFER_TOO_LARGE                         (FAIL_MASK | MEMORY_MASK | 0x000EUL)
+#define STATUS_MEMORY_ALREADY_RESERVED                  (FAIL_MASK | MEMORY_MASK | 0x000FUL)
+#define STATUS_MEMORY_IS_NOT_COMMITED                   (FAIL_MASK | MEMORY_MASK | 0x0010UL)
+#define STATUS_MEMORY_PREVENTS_USERMODE_ACCESS          (FAIL_MASK | MEMORY_MASK | 0x0011UL)
+#define STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS        (FAIL_MASK | MEMORY_MASK | 0x0012UL)
 
 // disk related errors
-#define CL_STATUS_DISK_MBR_NOT_PRESENT                     (ERROR_MASK | CUSTOMER_BIT | DISK_MASK | 0x0001UL)
-#define CL_STATUS_DISK_FULL                                (ERROR_MASK | CUSTOMER_BIT | DISK_MASK | 0x0002UL)
+#define STATUS_DISK_MBR_NOT_PRESENT                     (FAIL_MASK | DISK_MASK | 0x0001UL)
+#define STATUS_DISK_FULL                                (FAIL_MASK | DISK_MASK | 0x0002UL)
 
 // APIC errors
-#define CL_STATUS_APIC_NOT_MAPPED                          (ERROR_MASK | CUSTOMER_BIT | APIC_MASK | 0x0001UL)
-#define CL_STATUS_APIC_NOT_INITIALIZED                     (ERROR_MASK | CUSTOMER_BIT | APIC_MASK | 0x0002UL)
-#define CL_STATUS_APIC_NOT_ENABLED                         (ERROR_MASK | CUSTOMER_BIT | APIC_MASK | 0x0003UL)
+#define STATUS_APIC_NOT_MAPPED                          (FAIL_MASK | APIC_MASK | 0x0001UL)
+#define STATUS_APIC_NOT_INITIALIZED                     (FAIL_MASK | APIC_MASK | 0x0002UL)
+#define STATUS_APIC_NOT_ENABLED                         (FAIL_MASK | APIC_MASK | 0x0003UL)
 
 // device error
-#define CL_STATUS_DEVICE_DOES_NOT_EXIST                    (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0001UL)
-#define CL_STATUS_DEVICE_NO_MORE_DEVICES                   (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0002UL)
-#define CL_STATUS_DEVICE_NOT_SUPPORTED                     (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0003UL)
-#define CL_STATUS_DEVICE_NOT_INITIALIZED                   (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0004UL)
-#define CL_STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED            (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0005UL)
-#define CL_STATUS_DEVICE_SECTOR_COUNT_EXCEEDED             (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0006UL)
-#define CL_STATUS_DEVICE_COULD_NOT_BE_CREATED              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0007UL)
-#define CL_STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED       (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0008UL)
-#define CL_STATUS_DEVICE_INVALID_OPERATION                 (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0009UL)
-#define CL_STATUS_DEVICE_DATA_ALIGNMENT_ERROR              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000AUL)
-#define CL_STATUS_DEVICE_NO_FILESYSTEM_MOUNTED             (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000BUL)
-#define CL_STATUS_DEVICE_FILESYSTEM_UNSUPPORTED            (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000CUL)
-#define CL_STATUS_DEVICE_CLUSTER_INVALID                   (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000DUL)
-#define CL_STATUS_DEVICE_ALIGNMENT_NO_SATISFIED            (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000EUL)
-#define CL_STATUS_DEVICE_DMA_NOT_SUPPORTED                 (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000FUL)
-#define CL_STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH     (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0010UL)
-#define CL_STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE       (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0011UL)
-#define CL_STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE           (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0012UL)
-#define CL_STATUS_DEVICE_DMA_SPAN_CROSSES_BOUNDARY         (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0013UL)
-#define CL_STATUS_DEVICE_DOES_NOT_EXIST_HINT               (INFO_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0014UL)
-#define CL_STATUS_DEVICE_NOT_READY                         (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0015UL)
-#define CL_STATUS_DEVICE_DISABLED                          (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0016UL)
-#define CL_STATUS_DEVICE_NOT_CONNECTED                     (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0017UL)
-#define CL_STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED          (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0018UL)
-#define CL_STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED        (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0019UL)
-#define CL_STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST         (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001AUL)
-#define CL_STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED      (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001BUL)
-#define CL_STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE  (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001CUL)
-#define CL_STATUS_DEVICE_SPACE_RANGE_EXCEEDED              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001DUL)
-#define CL_STATUS_DEVICE_TYPE_INVALID                      (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001EUL)
-#define CL_STATUS_DEVICE_BUSY                              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001FUL)
+#define STATUS_DEVICE_DOES_NOT_EXIST                    (FAIL_MASK | DEVICE_MASK | 0x0001UL)
+#define STATUS_DEVICE_NO_MORE_DEVICES                   (FAIL_MASK | DEVICE_MASK | 0x0002UL)
+#define STATUS_DEVICE_NOT_SUPPORTED                     (FAIL_MASK | DEVICE_MASK | 0x0003UL)
+#define STATUS_DEVICE_NOT_INITIALIZED                   (FAIL_MASK | DEVICE_MASK | 0x0004UL)
+#define STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED            (FAIL_MASK | DEVICE_MASK | 0x0005UL)
+#define STATUS_DEVICE_SECTOR_COUNT_EXCEEDED             (FAIL_MASK | DEVICE_MASK | 0x0006UL)
+#define STATUS_DEVICE_COULD_NOT_BE_CREATED              (FAIL_MASK | DEVICE_MASK | 0x0007UL)
+#define STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED       (FAIL_MASK | DEVICE_MASK | 0x0008UL)
+#define STATUS_DEVICE_INVALID_OPERATION                 (FAIL_MASK | DEVICE_MASK | 0x0009UL)
+#define STATUS_DEVICE_DATA_ALIGNMENT_ERROR              (FAIL_MASK | DEVICE_MASK | 0x000AUL)
+#define STATUS_DEVICE_NO_FILESYSTEM_MOUNTED             (FAIL_MASK | DEVICE_MASK | 0x000BUL)
+#define STATUS_DEVICE_FILESYSTEM_UNSUPPORTED            (FAIL_MASK | DEVICE_MASK | 0x000CUL)
+#define STATUS_DEVICE_CLUSTER_INVALID                   (FAIL_MASK | DEVICE_MASK | 0x000DUL)
+#define STATUS_DEVICE_ALIGNMENT_NO_SATISFIED            (FAIL_MASK | DEVICE_MASK | 0x000EUL)
+#define STATUS_DEVICE_DMA_NOT_SUPPORTED                 (FAIL_MASK | DEVICE_MASK | 0x000FUL)
+#define STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH     (FAIL_MASK | DEVICE_MASK | 0x0010UL)
+#define STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE       (FAIL_MASK | DEVICE_MASK | 0x0011UL)
+#define STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE           (FAIL_MASK | DEVICE_MASK | 0x0012UL)
+#define STATUS_DEVICE_DMA_SPAN_CROSSES_BOUNDARY         (FAIL_MASK | DEVICE_MASK | 0x0013UL)
+#define STATUS_DEVICE_DOES_NOT_EXIST_HINT               (WARNING_MASK | DEVICE_MASK | 0x0014UL)
+#define STATUS_DEVICE_NOT_READY                         (FAIL_MASK | DEVICE_MASK | 0x0015UL)
+#define STATUS_DEVICE_DISABLED                          (FAIL_MASK | DEVICE_MASK | 0x0016UL)
+#define STATUS_DEVICE_NOT_CONNECTED                     (FAIL_MASK | DEVICE_MASK | 0x0017UL)
+#define STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED          (FAIL_MASK | DEVICE_MASK | 0x0018UL)
+#define STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED        (FAIL_MASK | DEVICE_MASK | 0x0019UL)
+#define STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST         (FAIL_MASK | DEVICE_MASK | 0x001AUL)
+#define STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED      (FAIL_MASK | DEVICE_MASK | 0x001BUL)
+#define STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE  (FAIL_MASK | DEVICE_MASK | 0x001CUL)
+#define STATUS_DEVICE_SPACE_RANGE_EXCEEDED              (FAIL_MASK | DEVICE_MASK | 0x001DUL)
+#define STATUS_DEVICE_TYPE_INVALID                      (FAIL_MASK | DEVICE_MASK | 0x001EUL)
+#define STATUS_DEVICE_BUSY                              (FAIL_MASK | DEVICE_MASK | 0x001FUL)
 
 // success status
-#define CL_STATUS_SUCCESS                                  0UL
+#define STATUS_SUCCESS                                  0UL
 
 // check if a status was successful
-#define SUCCEEDED(x)                                    (0 == ( (x) & FAIL_MASK ) )
-
-typedef _Return_type_success_(SUCCEEDED(return)) DWORD  STATUS;
-
-#ifndef CL_NON_NATIVE
-
-// general errors
-#define STATUS_UNSUPPORTED                              CL_STATUS_UNSUPPORTED
-#define STATUS_INTERNAL_ERROR                           CL_STATUS_INTERNAL_ERROR
-#define STATUS_UNSUCCESSFUL                             CL_STATUS_UNSUCCESSFUL
-#define STATUS_ELEMENT_NOT_FOUND                        CL_STATUS_ELEMENT_NOT_FOUND
-#define STATUS_ELEMENT_FOUND                            CL_STATUS_ELEMENT_FOUND
-#define STATUS_LIST_EMPTY                               CL_STATUS_LIST_EMPTY
-#define STATUS_ALREADY_INITIALIZED                      CL_STATUS_ALREADY_INITIALIZED
-#define STATUS_ALREADY_INITIALIZED_HINT                 CL_STATUS_ALREADY_INITIALIZED_HINT
-#define STATUS_INCOMPATIBLE_INTERFACE                   CL_STATUS_INCOMPATIBLE_INTERFACE
-#define STATUS_INVALID_PARAMETER1                       CL_STATUS_INVALID_PARAMETER1
-#define STATUS_INVALID_PARAMETER2                       CL_STATUS_INVALID_PARAMETER2
-#define STATUS_INVALID_PARAMETER3                       CL_STATUS_INVALID_PARAMETER3
-#define STATUS_INVALID_PARAMETER4                       CL_STATUS_INVALID_PARAMETER4
-#define STATUS_INVALID_PARAMETER5                       CL_STATUS_INVALID_PARAMETER5
-#define STATUS_INVALID_PARAMETER6                       CL_STATUS_INVALID_PARAMETER6
-#define STATUS_INVALID_PARAMETER7                       CL_STATUS_INVALID_PARAMETER7
-#define STATUS_INVALID_PARAMETER8                       CL_STATUS_INVALID_PARAMETER8
-#define STATUS_INVALID_FILE_NAME                        CL_STATUS_INVALID_FILE_NAME
-#define STATUS_FILE_NOT_FOUND                           CL_STATUS_FILE_NOT_FOUND
-#define STATUS_FILE_TYPE_INVALID                        CL_STATUS_FILE_TYPE_INVALID
-#define STATUS_TIME_INVALID                             CL_STATUS_TIME_INVALID
-#define STATUS_PATH_NOT_VALID                           CL_STATUS_PATH_NOT_VALID
-#define STATUS_FILE_ALREADY_EXISTS                      CL_STATUS_FILE_ALREADY_EXISTS
-#define STATUS_FILE_NOT_DIRECTORY                       CL_STATUS_FILE_NOT_DIRECTORY
-#define STATUS_NO_MORE_OBJECTS                          CL_STATUS_NO_MORE_OBJECTS
-#define STATUS_PARSE_FAILED                             CL_STATUS_PARSE_FAILED
-#define STATUS_JOB_INTERRUPTED                          CL_STATUS_JOB_INTERRUPTED
-#define STATUS_INVALID_MZ_IMAGE                         CL_STATUS_INVALID_MZ_IMAGE
-#define STATUS_INVALID_IMAGE_SIZE                       CL_STATUS_INVALID_IMAGE_SIZE
-#define STATUS_INVALID_PE_IMAGE                         CL_STATUS_INVALID_PE_IMAGE
-#define STATUS_IMAGE_NOT_64_BIT                         CL_STATUS_IMAGE_NOT_64_BIT
-#define STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE               CL_STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE
-#define STATUS_IMAGE_NOT_FULLY_LOADED                   CL_STATUS_IMAGE_NOT_FULLY_LOADED
-#define STATUS_IMAGE_HAS_RELOCATIONS                    CL_STATUS_IMAGE_HAS_RELOCATIONS
-#define STATUS_NOT_IMPLEMENTED                          CL_STATUS_NOT_IMPLEMENTED
-#define STATUS_INVALID_FUNCTION                         CL_STATUS_INVALID_FUNCTION
-#define STATUS_INVALID_BUFFER                           CL_STATUS_INVALID_BUFFER
-#define STATUS_NOT_INITIALIZED                          CL_STATUS_NOT_INITIALIZED
-#define STATUS_NO_HANDLING_REQUIRED                     CL_STATUS_NO_HANDLING_REQUIRED
-#define STATUS_CONFLICTING_OPTIONS                      CL_STATUS_CONFLICTING_OPTIONS
-#define STATUS_ASSERTION_FAILURE                        CL_STATUS_ASSERTION_FAILURE
-#define STATUS_NO_DATA_AVAILABLE                        CL_STATUS_NO_DATA_AVAILABLE
-#define STATUS_LIMIT_REACHED                            CL_STATUS_LIMIT_REACHED
-#define STATUS_SIZE_INVALID                             CL_STATUS_SIZE_INVALID
-#define STATUS_VALUE_MISMATCH                           CL_STATUS_VALUE_MISMATCH
-#define STATUS_OPERATION_REQUIRES_HIGHER_CPL            CL_STATUS_OPERATION_REQUIRES_HIGHER_CPL
-
-// introspection errors
-#define STATUS_INTRO_INVALID_SYSCALL_HANDLER            CL_STATUS_INTRO_INVALID_SYSCALL_HANDLER
-#define STATUS_INTRO_KERNEL_BASE_NOT_FOUND              CL_STATUS_INTRO_KERNEL_BASE_NOT_FOUND
-#define STATUS_INTRO_KERNEL_INVALID_IMAGE               CL_STATUS_INTRO_KERNEL_INVALID_IMAGE
-#define STATUS_INTRO_EXPORT_NOT_FOUND                   CL_STATUS_INTRO_EXPORT_NOT_FOUND
-#define STATUS_INTRO_MODULE_LIST_NOT_FOUND              CL_STATUS_INTRO_MODULE_LIST_NOT_FOUND
-#define STATUS_INTRO_PCR_NOT_AVAILABLE                  CL_STATUS_INTRO_PCR_NOT_AVAILABLE
-#define STATUS_INTRO_KERNEL_ADDRESS_INVALID             CL_STATUS_INTRO_KERNEL_ADDRESS_INVALID
-#define STATUS_INTRO_VARIABLES_NOT_DEFINED              CL_STATUS_INTRO_VARIABLES_NOT_DEFINED
-#define STATUS_INTRO_INTROSPECTION_NOT_SUPPORTED        CL_STATUS_INTRO_INTROSPECTION_NOT_SUPPORTED
-#define STATUS_INTRO_PROCESS_NOT_VALID                  CL_STATUS_INTRO_PROCESS_NOT_VALID
-#define STATUS_INTRO_PATTERN_NOT_FOUND                  CL_STATUS_INTRO_PATTERN_NOT_FOUND
-#define STATUS_INTRO_INTROSPECTION_NOT_INITIALIZED      CL_STATUS_INTRO_INTROSPECTION_NOT_INITIALIZED
-#define STATUS_INTRO_DEBUGGER_DATA_NOT_FOUND            CL_STATUS_INTRO_DEBUGGER_DATA_NOT_FOUND
-
-// vmx related issues
-#define STATUS_VMX_WRITE_FAILED                         CL_STATUS_VMX_WRITE_FAILED
-#define STATUS_VMX_READ_FAILED                          CL_STATUS_VMX_READ_FAILED
-#define STATUS_VMX_INVEPT_FAILED                        CL_STATUS_VMX_INVEPT_FAILED
-#define STATUS_VMX_EPT_MAPPING_FAILED                   CL_STATUS_VMX_EPT_MAPPING_FAILED
-#define STATUS_VMX_EXIT_NOT_IMPLEMENTED                 CL_STATUS_VMX_EXIT_NOT_IMPLEMENTED
-#define STATUS_VMX_FEATURE_NOT_SUPPORTED                CL_STATUS_VMX_FEATURE_NOT_SUPPORTED
-#define STATUS_VMX_UNEXPECTED_VMCALL                    CL_STATUS_VMX_UNEXPECTED_VMCALL
-#define STATUS_VMX_GUEST_MEMORY_CANNOT_BE_MAPPED        CL_STATUS_VMX_GUEST_MEMORY_CANNOT_BE_MAPPED
-#define STATUS_VMX_NO_CALLBACKS                         CL_STATUS_VMX_NO_CALLBACKS
-#define STATUS_VMX_INCOMPATIBLE_CONFIGURATION           CL_STATUS_VMX_INCOMPATIBLE_CONFIGURATION
-
-// cpu related errors
-#define STATUS_CPU_UNSUPPORTED_FEATURE                  CL_STATUS_CPU_UNSUPPORTED_FEATURE
-#define STATUS_CPU_MONITOR_NOT_SUPPORTED                CL_STATUS_CPU_MONITOR_NOT_SUPPORTED
-#define STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL        CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL
-#define STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE        CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE
-#define STATUS_CPU_NO_MATCHES                           CL_STATUS_CPU_NO_MATCHES
-#define STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE        CL_STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE
-
-// communication related errors
-#define STATUS_COMM_SERIAL_ALREADY_INITIALIZED          CL_STATUS_COMM_SERIAL_ALREADY_INITIALIZED
-#define STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE           CL_STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE
-#define STATUS_COMM_SERIAL_NOT_INITIALIZED              CL_STATUS_COMM_SERIAL_NOT_INITIALIZED
-#define STATUS_COMM_VMCALL_UNSUPPORTED_COMMAND          CL_STATUS_COMM_VMCALL_UNSUPPORTED_COMMAND
-
-// timer related errors
-#define STATUS_TIMER_INVALID_FREQUENCY                  CL_STATUS_TIMER_INVALID_FREQUENCY
-
-// heap related errors
-#define STATUS_HEAP_TOO_SMALL                           CL_STATUS_HEAP_TOO_SMALL
-#define STATUS_HEAP_ALREADY_INITIALIZED                 CL_STATUS_HEAP_ALREADY_INITIALIZED
-#define STATUS_HEAP_NO_MORE_MEMORY                      CL_STATUS_HEAP_NO_MORE_MEMORY
-#define STATUS_HEAP_INSUFFICIENT_RESOURCES              CL_STATUS_HEAP_INSUFFICIENT_RESOURCES
-
-// memory related errors
-#define STATUS_INVALID_POINTER                          CL_STATUS_INVALID_POINTER
-#define STATUS_BUFFER_TOO_SMALL                         CL_STATUS_BUFFER_TOO_SMALL
-#define STATUS_INSUFFICIENT_MEMORY                      CL_STATUS_INSUFFICIENT_MEMORY
-#define STATUS_MEMORY_CANNOT_BE_MAPPED                  CL_STATUS_MEMORY_CANNOT_BE_MAPPED
-#define STATUS_PHYSICAL_MEMORY_TOO_SMALL                CL_STATUS_PHYSICAL_MEMORY_TOO_SMALL
-#define STATUS_MEMORY_IS_NOT_RESERVED                   CL_STATUS_MEMORY_IS_NOT_RESERVED
-#define STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE            CL_STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE
-#define STATUS_PAT_LAYOUT_NOT_COMPATIBLE                CL_STATUS_PAT_LAYOUT_NOT_COMPATIBLE
-#define STATUS_MEMORY_CANNOT_BE_RESERVED                CL_STATUS_MEMORY_CANNOT_BE_RESERVED
-#define STATUS_MEMORY_ACCESS_DENIED                     CL_STATUS_MEMORY_ACCESS_DENIED
-#define STATUS_MEMORY_CANNOT_BE_COMMITED                CL_STATUS_MEMORY_CANNOT_BE_COMMITED
-#define STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS         CL_STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS
-#define STATUS_MEMORY_CONFLICTING_CACHEABILITY          CL_STATUS_MEMORY_CONFLICTING_CACHEABILITY
-#define STATUS_BUFFER_TOO_LARGE                         CL_STATUS_BUFFER_TOO_LARGE
-#define STATUS_MEMORY_ALREADY_RESERVED                  CL_STATUS_MEMORY_ALREADY_RESERVED
-#define STATUS_MEMORY_IS_NOT_COMMITED                   CL_STATUS_MEMORY_IS_NOT_COMMITED
-#define STATUS_MEMORY_PREVENTS_USERMODE_ACCESS          CL_STATUS_MEMORY_PREVENTS_USERMODE_ACCESS
-#define STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS        CL_STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS
-#define STATUS_PHYSICAL_MEMORY_QUOTA_EXCEEDED           CL_STATUS_PHYSICAL_MEMORY_QUOTA_EXCEEDED
-
-// disk related errors
-#define STATUS_DISK_MBR_NOT_PRESENT                     CL_STATUS_DISK_MBR_NOT_PRESENT
-#define STATUS_DISK_FULL                                CL_STATUS_DISK_FULL
-
-// APIC errors
-#define STATUS_APIC_NOT_MAPPED                          CL_STATUS_APIC_NOT_MAPPED
-#define STATUS_APIC_NOT_INITIALIZED                     CL_STATUS_APIC_NOT_INITIALIZED
-#define STATUS_APIC_NOT_ENABLED                         CL_STATUS_APIC_NOT_ENABLED
-
-// device error
-#define STATUS_DEVICE_DOES_NOT_EXIST                    CL_STATUS_DEVICE_DOES_NOT_EXIST
-#define STATUS_DEVICE_NO_MORE_DEVICES                   CL_STATUS_DEVICE_NO_MORE_DEVICES
-#define STATUS_DEVICE_NOT_SUPPORTED                     CL_STATUS_DEVICE_NOT_SUPPORTED
-#define STATUS_DEVICE_NOT_INITIALIZED                   CL_STATUS_DEVICE_NOT_INITIALIZED
-#define STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED            CL_STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED
-#define STATUS_DEVICE_SECTOR_COUNT_EXCEEDED             CL_STATUS_DEVICE_SECTOR_COUNT_EXCEEDED
-#define STATUS_DEVICE_COULD_NOT_BE_CREATED              CL_STATUS_DEVICE_COULD_NOT_BE_CREATED
-#define STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED       CL_STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED
-#define STATUS_DEVICE_INVALID_OPERATION                 CL_STATUS_DEVICE_INVALID_OPERATION
-#define STATUS_DEVICE_DATA_ALIGNMENT_ERROR              CL_STATUS_DEVICE_DATA_ALIGNMENT_ERROR
-#define STATUS_DEVICE_NO_FILESYSTEM_MOUNTED             CL_STATUS_DEVICE_NO_FILESYSTEM_MOUNTED
-#define STATUS_DEVICE_FILESYSTEM_UNSUPPORTED            CL_STATUS_DEVICE_FILESYSTEM_UNSUPPORTED
-#define STATUS_DEVICE_CLUSTER_INVALID                   CL_STATUS_DEVICE_CLUSTER_INVALID
-#define STATUS_DEVICE_ALIGNMENT_NO_SATISFIED            CL_STATUS_DEVICE_ALIGNMENT_NO_SATISFIED
-#define STATUS_DEVICE_DMA_NOT_SUPPORTED                 CL_STATUS_DEVICE_DMA_NOT_SUPPORTED
-#define STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH     CL_STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH
-#define STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE       CL_STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE
-#define STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE           CL_STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE
-#define STATUS_DEVICE_DMA_SPAN_CROSSES_BOUNDARY         CL_STATUS_DEVICE_DMA_SPAN_CROSSES_BOUNDARY
-#define STATUS_DEVICE_DOES_NOT_EXIST_HINT               CL_STATUS_DEVICE_DOES_NOT_EXIST_HINT
-#define STATUS_DEVICE_NOT_READY                         CL_STATUS_DEVICE_NOT_READY
-#define STATUS_DEVICE_DISABLED                          CL_STATUS_DEVICE_DISABLED
-#define STATUS_DEVICE_NOT_CONNECTED                     CL_STATUS_DEVICE_NOT_CONNECTED
-#define STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED          CL_STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED
-#define STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED        CL_STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED
-#define STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST         CL_STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST
-#define STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED      CL_STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED
-#define STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE  CL_STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE
-#define STATUS_DEVICE_SPACE_RANGE_EXCEEDED              CL_STATUS_DEVICE_SPACE_RANGE_EXCEEDED
-#define STATUS_DEVICE_TYPE_INVALID                      CL_STATUS_DEVICE_TYPE_INVALID
-#define STATUS_DEVICE_BUSY                              CL_STATUS_DEVICE_BUSY
-
-// success status
-#define STATUS_SUCCESS                                  CL_STATUS_SUCCESS
-#endif // CL_NON_NATIVE
+#define SUCCEEDED(x)                                    ( 0 == ( (x) & FAIL_MASK ) )
 
-C_HEADER_END
+typedef _Return_type_success_(SUCCEEDED(return)) DWORD  STATUS;
\ No newline at end of file
diff --git a/src/CommonLib/inc/string.h b/src/CommonLib/inc/string.h
new file mode 100644
index 0000000..e5e2893
--- /dev/null
+++ b/src/CommonLib/inc/string.h
@@ -0,0 +1,152 @@
+#pragma once
+
+#define INVALID_STRING_SIZE             MAX_DWORD
+
+//******************************************************************************
+// Function:     strcmp
+// Description:  Compares two strings.
+// Returns:      int  0 => strings equal
+//                   +1 => str1 > str2
+//                   -1 => str2 > str1
+// Parameter:    IN_Z char * str1
+// Parameter:    IN_Z char * str2
+//******************************************************************************
+int
+strcmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    );
+
+//******************************************************************************
+// Function:     stricmp
+// Description:  Same as strcmp except its case insensitive.
+// Returns:      int
+// Parameter:    IN_Z char * str1
+// Parameter:    IN_Z char * str2
+//******************************************************************************
+int
+stricmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    );
+
+int
+strncmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    );
+
+int
+strnicmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    );
+
+//******************************************************************************
+// Function:     strchr
+// Description:  Searches a string for the first occurrence of a character.
+// Returns:      const char* - pointer to the first occurence of the character.
+//               If the character is not found the result will point to str.
+// Parameter:    IN_Z char * str
+// Parameter:    IN char c
+//******************************************************************************
+const
+char*
+strchr(
+    IN_Z  char* str,
+    IN  char c
+    );
+
+//******************************************************************************
+// Function:     strrchr
+// Description:  Searches a string for the last occurrence of a character.
+// Returns:      const char* - pointer to the last occurence of the character.
+//               If the character is not found the result will point to str.
+// Parameter:    IN_Z char * str
+// Parameter:    IN char c
+//******************************************************************************
+const
+char*
+strrchr(
+    IN_Z  char* str,
+    IN  char c
+    );
+
+void
+strcpy(
+    OUT_Z char* dst,
+    IN_Z  char* src
+    );
+
+//******************************************************************************
+// Function:     strncpy
+// Description:  Copies the first length characters from src to dst. If the src
+//               string terminates faster the copying will stop. No matter what
+//               the termination reason dst[i+1] will be set to '\0', where i
+//               represents the number of characters copied.
+// Returns:      void
+// Parameter:    char* dst - the size of the dst buffer must be with at laast
+//               1 BYTE greater than length
+// Parameter:    char* src
+// Parameter:    IN DWORD length
+//******************************************************************************
+void
+strncpy(
+    OUT_WRITES(length + 1)  char* dst,
+    IN_READS_Z(length)      char* src,
+    IN                      DWORD length
+    );
+
+SIZE_SUCCESS
+DWORD
+strlen(
+    IN_Z  char* str
+    );
+
+SIZE_SUCCESS
+DWORD
+strlen_s(
+    IN_READS_Z(maxLen)
+                char*   str,
+    IN          DWORD   maxLen
+    );
+
+// buffSize also includes the NULL terminator
+// => only buffSize - 1 will actually be
+// characters
+STATUS
+snprintf(
+    OUT_WRITES(buffSize)    char* outputBuffer,
+    IN                      DWORD buffSize,
+    IN_Z                    char* inputBuffer,
+    ...
+    );
+
+#define sprintf(outBuff,inBuff,...)     snprintf(outBuff,MAX_PATH,inBuff,__VA_ARGS__)
+
+STATUS
+vsnprintf(
+    OUT_WRITES(buffSize)    char*       outputBuffer,
+    IN                      DWORD       buffSize,
+    IN_Z                    char*       inputBuffer,
+    INOUT                   va_list     argptr
+    );
+
+const
+char*
+strtok_s(
+    _When_(*context==NULL,IN_Z)
+    _When_(*context!=NULL,IN_OPT)
+                                char*       strToken,
+    IN_Z                        char*       delimiters,
+    INOUT                       char**      context
+    );
+
+SIZE_SUCCESS
+DWORD
+strcelem(
+    IN_Z                    char*       string,
+    IN                      char        delimiter
+    );
diff --git a/src/CommonLib/inc/strutils.h b/src/CommonLib/inc/strutils.h
index 910b985..5f7ce63 100644
--- a/src/CommonLib/inc/strutils.h
+++ b/src/CommonLib/inc/strutils.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 // most often used numbering bases
 #define BASE_TWO            2
 #define BASE_TEN            10
@@ -11,7 +10,6 @@ C_HEADER_START
 #define islower(c)          ( ( 'a' <= (c)) && ((c) <= 'z'))
 #define tolower(c)          ( (c) | LOWER_UPPER_DIFF)
 #define toupper(c)          ( (c) & (~LOWER_UPPER_DIFF))
-#define isspace(c)          ((' ' == (c)) || ('\t' == (c)) || ('\n' == (c)) || ('\r' == (c)))
 
 #define LOWER_UPPER_DIFF    ('a' - 'A')
 
@@ -26,13 +24,13 @@ C_HEADER_START
 // Parameter:     IN BOOLEAN signedValue - If set the value is signed, else unsigned
 // Parameter:     OUT char * buffer - Buffer in which to write the number
 // Parameter:     IN DWORD base - Numeric base of the input value
-// Parameter:     IN DWORD minimumDigits - The minimum number of digits to place
+// Parameter:     IN DWORD minimumDigits - The minimum number of digits to place 
 //                in the buffer
-// Parameter:     IN BOOLEAN is64BitValue - If set the value is treated as a 64bit
+// Parameter:     IN BOOLEAN is64BitValue - If set the value is treated as a 64bit 
 //                value
 //******************************************************************************
-void
-itoa(
+void 
+itoa( 
     IN      PVOID       valueAddress,
     IN      BOOLEAN     signedValue,
     OUT_Z   char*       buffer,
@@ -51,5 +49,4 @@ atoi(
     );
 
 #define atoi32(addr,buf,base)       atoi((addr),(buf),(base),FALSE)
-#define atoi64(addr,buf,base)       atoi((addr),(buf),(base),TRUE)
-C_HEADER_END
+#define atoi64(addr,buf,base)       atoi((addr),(buf),(base),TRUE)
\ No newline at end of file
diff --git a/src/CommonLib/inc/time.h b/src/CommonLib/inc/time.h
index c27cacb..701a034 100644
--- a/src/CommonLib/inc/time.h
+++ b/src/CommonLib/inc/time.h
@@ -1,6 +1,5 @@
 #pragma once
 
-C_HEADER_START
 #pragma pack(push,8)
 typedef struct _DATE
 {
@@ -29,5 +28,4 @@ TimeGetStringFormattedBuffer(
     IN                          DATETIME        DateTime,
     OUT_WRITES_Z(BufferSize)    char*           Buffer,
     IN                          DWORD           BufferSize
-    );
-C_HEADER_END
+    );
\ No newline at end of file
diff --git a/src/CommonLib/inc/va_list.h b/src/CommonLib/inc/va_list.h
index 6943681..4c4f443 100644
--- a/src/CommonLib/inc/va_list.h
+++ b/src/CommonLib/inc/va_list.h
@@ -1,10 +1,6 @@
 #pragma once
 
-C_HEADER_START
-#ifndef _VA_LIST_DEFINED
-#define _VA_LIST_DEFINED
 typedef PBYTE               va_list;
-#endif
 
 #define STACKITEM_SIZE      sizeof(PVOID)
 
@@ -15,5 +11,4 @@ typedef PBYTE               va_list;
 // Retrieves the value of the next argument
 // And increases the List pointer
 #define va_arg(List, Type)	\
-	((List) += STACKITEM_SIZE, *((Type *)((List) - STACKITEM_SIZE)))
-C_HEADER_END
+	((List) += STACKITEM_SIZE, *((Type *)((List) - STACKITEM_SIZE)))
\ No newline at end of file
diff --git a/src/CommonLib/src/_gs_checks.yasm b/src/CommonLib/src/_gs_checks.yasm
index 870c8fc..fe191c5 100644
--- a/src/CommonLib/src/_gs_checks.yasm
+++ b/src/CommonLib/src/_gs_checks.yasm
@@ -1,6 +1,3 @@
-%ifdef CL_NO_RUNTIME_CHECKS
-
-%else
 global __security_check_cookie
 
 extern __report_cookie_corruption
@@ -25,4 +22,3 @@ __security_check_cookie:
 .end:
     mov             rax, r11
     ret
-%endif ; CL_NO_RUNTIME_CHECKS
diff --git a/src/CommonLib/src/assert.c b/src/CommonLib/src/assert.c
index 2693bd9..ccd39e7 100644
--- a/src/CommonLib/src/assert.c
+++ b/src/CommonLib/src/assert.c
@@ -52,7 +52,7 @@ AssertInfo(
     {
         m_pAssertFunction(m_assertBuffer);
     }
-
+    
 #ifndef _COMMONLIB_NO_LOCKS_
     LockRelease(&m_assertLock, oldState );
 #endif // _COMMONLIB_NO_LOCKS_
@@ -88,8 +88,6 @@ AssertFreeLock(
     void
     )
 {
-    _Analysis_assume_lock_acquired_(m_assertLock);
-
     LockRelease(&m_assertLock, INTR_OFF );
 }
 #endif // _COMMONLIB_NO_LOCKS_
diff --git a/src/CommonLib/src/bitmap.c b/src/CommonLib/src/bitmap.c
index 7688b63..d5cd501 100644
--- a/src/CommonLib/src/bitmap.c
+++ b/src/CommonLib/src/bitmap.c
@@ -67,7 +67,7 @@ BitmapInitEx(
     ASSERT(NULL != Bitmap);
     ASSERT(NULL != BitmapBuffer);
 
-    memset(BitmapBuffer,
+    memset(BitmapBuffer, 
            Set ? MAX_BYTE : 0,
            Bitmap->BufferSize);
 
@@ -103,7 +103,7 @@ BitmapSetBitValue(
 {
     ASSERT(NULL != Bitmap);
     ASSERT(Index < Bitmap->BitCount);
-
+    
     _BitmapChangeBit(Bitmap->BitmapBuffer, Index, Set);
 }
 
diff --git a/src/CommonLib/src/checkin_queue.c b/src/CommonLib/src/checkin_queue.c
deleted file mode 100644
index 6d39e96..0000000
--- a/src/CommonLib/src/checkin_queue.c
+++ /dev/null
@@ -1,108 +0,0 @@
-#include "common_lib.h"
-#include "lock_common.h"
-#include "checkin_queue.h"
-
-#ifndef _COMMONLIB_NO_LOCKS_
-
-DWORD
-CheckinQueuePreInit(
-    OUT       PCHECKIN_QUEUE      Queue,
-    IN        DWORD               NumberOfThreads
-)
-{
-    ASSERT(NULL != Queue);
-    ASSERT(0 < NumberOfThreads);
-
-    memzero(Queue, sizeof(CHECKIN_QUEUE));
-
-    Queue->NumberOfThreads = NumberOfThreads;
-
-    Queue->BufferSize = NumberOfThreads * sizeof(BOOLEAN);
-
-    return Queue->BufferSize;
-}
-
-void
-CheckinQueueInit(
-    INOUT     PCHECKIN_QUEUE      Queue,
-    IN        PBYTE               QueueBuffer
-)
-{
-    ASSERT(NULL != Queue);
-    ASSERT(NULL != QueueBuffer);
-    ASSERT(0 < Queue->NumberOfThreads); // a validation in-case PreInit wasn't called
-
-    Queue->Array = QueueBuffer;
-
-    memset((void*)Queue->Array, FALSE, Queue->NumberOfThreads);
-}
-
-void
-CheckinQueueUninit(
-    INOUT     PCHECKIN_QUEUE      Queue
-)
-{
-    ASSERT(NULL != Queue);
-
-    memzero(Queue, sizeof(CHECKIN_QUEUE));
-}
-
-void
-CheckinQueueMarkPresence(
-    INOUT       PCHECKIN_QUEUE       Queue
-)
-{
-    ASSERT(NULL != Queue);
-    ASSERT(0 < Queue->NumberOfThreads);
-
-    // mark here that thread or cpu arrived where it should be after creation
-    // little busy wait here, it should be basically nothing or minimum waiting time (atomic operation)
-    for (DWORD i = 0; i < Queue->NumberOfThreads; i++)
-    {
-        if (!_InterlockedCompareExchange8(&Queue->Array[i], TRUE, FALSE))
-        {
-            // marked my slot, the index of the slot is not an issue
-            break;
-        }
-    }
-}
-
-
-void
-CheckinQueueWaitOn(
-    IN          PCHECKIN_QUEUE      Queue,
-    IN          BOOLEAN             WaitAll,
-    IN_OPT      DWORD               NumberOfCheckinsToWait
-)
-{
-    ASSERT(NULL != Queue);
-    ASSERT(0 < Queue->NumberOfThreads);
-
-    INTR_STATE oldState;
-    BOOLEAN busyWait = TRUE;
-    DWORD numberOfThreads = (WaitAll) ? Queue->NumberOfThreads : NumberOfCheckinsToWait;
-
-    // disable interrupts, as we shouldn't been interrupted.
-    oldState = CpuIntrDisable();
-
-    // don't let the main thread or cpu advance until every thread signaled
-    // that it arrived before the blocking sequence.
-    while (busyWait)
-    {
-        BOOLEAN semaphoreGreen = TRUE;
-        for (DWORD i = 0; i < numberOfThreads; i++)
-        {
-            if (!_InterlockedCompareExchange8(&Queue->Array[i], TRUE, TRUE))
-            {
-                semaphoreGreen = FALSE;
-            }
-            _mm_pause();
-        }
-        if (semaphoreGreen) busyWait = FALSE;
-    }
-
-    // set back the interrupt state
-    CpuIntrSetState(oldState);
-}
-
-#endif // _COMMONLIB_NO_LOCKS_
\ No newline at end of file
diff --git a/src/CommonLib/src/gs_checks.c b/src/CommonLib/src/gs_checks.c
index e208118..ec9d149 100644
--- a/src/CommonLib/src/gs_checks.c
+++ b/src/CommonLib/src/gs_checks.c
@@ -1,8 +1,3 @@
-#ifdef CL_NO_RUNTIME_CHECKS
-
-// warning C4206: nonstandard extension used: translation unit is empty
-#pragma warning(disable:4206)
-#else
 #include "common_lib.h"
 
 #define DEFAULT_SECURITY_COOKIE_VALUE       (QWORD)0xBEEF'0301'2497'EC03ULL
@@ -58,4 +53,3 @@ __report_cookie_corruption(
                 "Security cookie is 0x%X but should have been 0x%X. RA is 0x%X\n",
                 StackCookie, __security_cookie, GET_RETURN_ADDRESS);
 }
-#endif // CL_NO_RUNTIME_CHECKS
diff --git a/src/CommonLib/src/gs_utils.c b/src/CommonLib/src/gs_utils.c
index 46ccb2e..fb2bd57 100644
--- a/src/CommonLib/src/gs_utils.c
+++ b/src/CommonLib/src/gs_utils.c
@@ -1,8 +1,3 @@
-#ifdef CL_NO_RUNTIME_CHECKS
-// warning C4206: nonstandard extension used: translation unit is empty
-#pragma warning(disable:4206)
-#else
-
 #include "common_lib.h"
 
 extern UINT64 __security_cookie;
@@ -44,5 +39,4 @@ GSNotifyStackChange(
             *pNewStackCookie = (*pNewStackCookie ^ xorResult);
         }
     }
-}
-#endif // CL_NO_RUNTIME_CHECKS
+}
\ No newline at end of file
diff --git a/src/CommonLib/src/list.c b/src/CommonLib/src/list.c
index 7561f2d..66de8f6 100644
--- a/src/CommonLib/src/list.c
+++ b/src/CommonLib/src/list.c
@@ -153,8 +153,7 @@ void
 InsertOrderedList(
     INOUT   PLIST_ENTRY             ListHead,
     INOUT   PLIST_ENTRY             Entry,
-    IN      PFUNC_CompareFunction   CompareFunction,
-    IN_OPT  PVOID                   Context
+    IN      PFUNC_CompareFunction   CompareFunction
     )
 {
     PLIST_ENTRY pCurrentEntry;
@@ -168,7 +167,7 @@ InsertOrderedList(
          pCurrentEntry = pCurrentEntry->Flink
          )
     {
-        if (CompareFunction(Entry, pCurrentEntry, Context) < 0)
+        if (CompareFunction(Entry, pCurrentEntry) < 0)
         {
             // entry to insert is smaller than current entry
             break;
@@ -297,9 +296,7 @@ PLIST_ENTRY
 ListSearchForElement(
     IN      PLIST_ENTRY             ListHead,
     IN      PLIST_ENTRY             ElementToSearchFor,
-    IN      BOOLEAN                 IsListOrdered,
-    IN      PFUNC_CompareFunction   CompareFunction,
-    IN_OPT  PVOID                   Context
+    IN      PFUNC_CompareFunction   CompareFunction
     )
 {
     PLIST_ENTRY pCurEntry;
@@ -326,48 +323,13 @@ ListSearchForElement(
     pCurEntry = ListHead->Flink;
     while (pCurEntry != ListHead)
     {
-        INT64 cmpResult = CompareFunction(pCurEntry, ElementToSearchFor, Context);
-
-        if (cmpResult == 0) return pCurEntry;
-        if (IsListOrdered && (cmpResult > 0)) return NULL;
+        if (0 == CompareFunction(pCurEntry, ElementToSearchFor))
+        {
+            return pCurEntry;
+        }
 
         pCurEntry = pCurEntry->Flink;
     }
 
     return NULL;
-}
-
-void
-ListIteratorInit(
-    IN      PLIST_ENTRY         List,
-    OUT     PLIST_ITERATOR      ListIterator
-    )
-{
-    ASSERT(List != NULL);
-    ASSERT(ListIterator != NULL);
-
-    ListIterator->ListHead = List;
-    ListIterator->CurrentEntry = List->Flink;
-}
-
-PLIST_ENTRY
-ListIteratorNext(
-    INOUT   PLIST_ITERATOR      ListIterator
-    )
-{
-    PLIST_ENTRY pResult;
-
-    ASSERT(ListIterator != NULL);
-
-    pResult = NULL;
-
-    if (ListIterator->CurrentEntry != ListIterator->ListHead)
-    {
-        pResult = ListIterator->CurrentEntry;
-
-        // advance current entry
-        ListIterator->CurrentEntry = ListIterator->CurrentEntry->Flink;
-    }
-
-    return pResult;
-}
+}
\ No newline at end of file
diff --git a/src/CommonLib/src/lock_common.c b/src/CommonLib/src/lock_common.c
index ac31e6b..559c931 100644
--- a/src/CommonLib/src/lock_common.c
+++ b/src/CommonLib/src/lock_common.c
@@ -13,16 +13,14 @@ PFUNC_LockRelease        LockRelease = NULL;
 
 PFUNC_LockIsOwner        LockIsOwner = NULL;
 
-#pragma warning(push)
-// warning C4028: formal parameter 1 different from declaration
-#pragma warning(disable:4028)
-
 void
 LockSystemInit(
     IN      BOOLEAN             MonitorSupport
     )
 {
 
+// warning C4028: formal parameter 1 different from declaration
+#pragma warning(disable:4028)
     if (MonitorSupport)
     {
         // we have monitor support
@@ -41,7 +39,7 @@ LockSystemInit(
         LockIsOwner = SpinlockIsOwner;
         LockRelease = SpinlockRelease;
     }
+#pragma warning(default:4028)
 }
-#pragma warning(pop)
 
 #endif // _COMMONLIB_NO_LOCKS_
diff --git a/src/CommonLib/src/memory.c b/src/CommonLib/src/memory.c
new file mode 100644
index 0000000..36404d7
--- /dev/null
+++ b/src/CommonLib/src/memory.c
@@ -0,0 +1,174 @@
+#include "common_lib.h"
+#include "memory.h"
+
+extern void CpuClearDirectionFlag();
+
+_At_buffer_( address, i, size, _Post_satisfies_( ((PBYTE)address)[i] == value ))
+void
+memset(
+    OUT_WRITES_BYTES_ALL(size)  PVOID address,
+    IN                          BYTE value,
+    IN                          DWORD size
+    )
+{
+    DWORD i;
+
+    // validate parameters
+    // size validation is done implicitly in the for loop
+    if (NULL == address)
+    {
+        return;
+    }
+
+    for (i = 0; i < size; ++i)
+    {
+        ((BYTE*)address)[i] = value;
+    }
+}
+
+_At_buffer_(Destination, i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+memcpy(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             PVOID   Source,
+    IN                          QWORD   Count
+    )
+{
+    PBYTE dst;
+    PBYTE src;
+    QWORD alignedCount;
+    QWORD unalignedCount;
+
+    if( (NULL == Destination) || (NULL == Source))
+    {
+        return;
+    }
+
+    unalignedCount = Count & 0x7;
+    alignedCount = Count - unalignedCount;
+
+    dst = (PBYTE)Destination;
+    src = (PBYTE)Source;
+
+    if (unalignedCount & 0x4)
+    {
+        *((PDWORD)dst) = *((PDWORD)src);
+        dst = dst + sizeof(DWORD);
+        src = src + sizeof(DWORD);
+    }
+
+    if (unalignedCount & 0x2)
+    {
+        *((PWORD)dst) = *((PWORD)src);
+        dst = dst + sizeof(WORD);
+        src = src + sizeof(WORD);
+    }
+    
+    if (unalignedCount & 0x1)
+    {
+        *((PBYTE)dst) = *((PBYTE)src);
+        dst = dst + sizeof(BYTE);
+        src = src + sizeof(BYTE);
+    }
+
+    if (0 != alignedCount)
+    {
+        ASSERT(IsAddressAligned(alignedCount, sizeof(QWORD)));
+
+        dst = (PBYTE)Destination + unalignedCount;
+        src = (PBYTE)Source + unalignedCount;
+
+        CpuClearDirectionFlag();
+
+        __movsq(dst, src, alignedCount / sizeof(QWORD));
+    }
+}
+
+_At_buffer_(Destination, i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+memmove(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             PVOID   Source,
+    IN                          QWORD   Count
+    )
+{
+    PBYTE dst;
+    PBYTE src;
+    QWORD i;
+
+    if ((NULL == Destination) || (NULL == Source))
+    {
+        return;
+    }
+
+    dst = Destination;
+    src = Source;
+
+    for (i = 0; i < Count; ++i)
+    {
+        dst[i] = src[i];
+    }
+}
+
+int
+memcmp(
+    IN_READS_BYTES(size)    PVOID ptr1,
+    IN_READS_BYTES(size)    PVOID ptr2,
+    IN                      DWORD size
+    )
+{
+    INT64 i = size;
+    PBYTE p1;
+    PBYTE p2;
+
+    if ((NULL == ptr1) || (NULL == ptr2))
+    {
+        // TODO: what is the best result to return?
+        return size;
+    }
+
+
+    p1 = (PBYTE)ptr1;
+    p2 = (PBYTE)ptr2;
+
+    for (i = 0; i < size; ++i)
+    {
+        if (p1[i] != p2[i])
+        {
+            return p1[i] - p2[i];
+        }
+    }
+
+    return 0;
+}
+
+int
+memscan(
+    IN_READS_BYTES(size)    PVOID buffer,
+    IN                      DWORD size,
+    IN                      BYTE  value
+    )
+{
+    DWORD i;
+    PBYTE pData;
+
+    if (NULL == buffer)
+    {
+        return 0;
+    }
+
+    pData = (PBYTE)buffer;
+
+    for (i = 0; i < size; ++i)
+    {
+        if (pData[i] != value)
+        {
+            // game over
+            return i;
+        }
+    }
+
+    return i;
+}
\ No newline at end of file
diff --git a/src/CommonLib/src/monlock.c b/src/CommonLib/src/monlock.c
index 13fdcf1..7435fa0 100644
--- a/src/CommonLib/src/monlock.c
+++ b/src/CommonLib/src/monlock.c
@@ -68,30 +68,13 @@ MonitorLockTryAcquire(
 {
     BOOLEAN acquired;
 
-    PVOID pCurrentCpu;
-
-    ASSERT(NULL != Lock);
-    ASSERT(NULL != IntrState);
-
     *IntrState = CpuIntrDisable();
 
-    pCurrentCpu = CpuGetCurrent();
-
     acquired = (LOCK_FREE == _InterlockedCompareExchange8(&Lock->Lock.State, LOCK_TAKEN, LOCK_FREE));
     if (!acquired)
     {
         CpuIntrSetState(*IntrState);
     }
-    else
-    {
-        ASSERT(NULL == Lock->Lock.FunctionWhichTookLock);
-        ASSERT(NULL == Lock->Lock.Holder);
-
-        Lock->Lock.Holder = pCurrentCpu;
-        Lock->Lock.FunctionWhichTookLock = *((PVOID*)_AddressOfReturnAddress());
-
-        ASSERT(LOCK_TAKEN == Lock->Lock.State);
-    }
 
     return acquired;
 }
diff --git a/src/CommonLib/src/rec_rw_spinlock.c b/src/CommonLib/src/rec_rw_spinlock.c
index e7d09ae..6c342e0 100644
--- a/src/CommonLib/src/rec_rw_spinlock.c
+++ b/src/CommonLib/src/rec_rw_spinlock.c
@@ -25,17 +25,12 @@ RecRwSpinlockInit(
     Spinlock->MaxRecursivityDepth = recursivityDepth;
 }
 
-// warning C26165 : Possibly failing to release lock '* Spinlock' in function 'RecRwSpinlockAcquire'.
-// well we're not actually attempting to release a lock in this function...
-#pragma warning(push)
-#pragma warning(disable:26165)
-
 REQUIRES_NOT_HELD_LOCK(*Spinlock)
 _When_(Exclusive, ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Spinlock))
 _When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RecRwSpinlockAcquire(
-    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    INOUT   PREC_RW_SPINLOCK    Spinlock,
     OUT     INTR_STATE*         IntrState,
     IN      BOOLEAN             Exclusive
     )
@@ -58,8 +53,6 @@ RecRwSpinlockAcquire(
                         Spinlock->CurrentRecursivityDepth,
                         Spinlock->MaxRecursivityDepth
                         );
-
-            _Analysis_assume_lock_acquired_(*Spinlock);
             Spinlock->CurrentRecursivityDepth++;
             return;
         }
@@ -77,21 +70,12 @@ RecRwSpinlockAcquire(
         Spinlock->Holder = CpuGetCurrent();
     }
 }
-#pragma warning(pop)
-
-// warning C26167: Possibly releasing unheld lock '* Spinlock' in function 'RecRwSpinlockRelease'.
-// FALSE, even if we tell SAL we used reentrant locks it's still stupid, and wants a release on
-// each call, so we need to tell him we release the lock in the first branch, and as a result
-// there's a situation in which he thinks we release the lock twice, one on the first branch
-// and second on the RwSpinlockRelease
-#pragma warning(push)
-#pragma warning(disable:26167)
 
 _When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_REENTRANT_LOCK(*Spinlock))
 _When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RecRwSpinlockRelease(
-    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    INOUT   PREC_RW_SPINLOCK    Spinlock,
     IN      INTR_STATE          IntrState,
     IN      BOOLEAN             Exclusive
     )
@@ -106,12 +90,7 @@ RecRwSpinlockRelease(
     if (Exclusive)
     {
         ASSERT(pCurrentCpu == Spinlock->Holder);
-
-        // if we're past the previous assert => lock is held by this CPU, SAL doesn't realize it, so assume it
-        _Analysis_assume_lock_held_(*Spinlock);
         Spinlock->CurrentRecursivityDepth--;
-        
-        _Analysis_assume_lock_released_(*Spinlock);
     }
 
     if (0 == Spinlock->CurrentRecursivityDepth || !Exclusive)
@@ -123,6 +102,4 @@ RecRwSpinlockRelease(
     }
 }
 
-#pragma warning(pop)
-
 #endif // _COMMONLIB_NO_LOCKS_
diff --git a/src/CommonLib/src/ref_cnt.c b/src/CommonLib/src/ref_cnt.c
index 2afbbcb..1fe3d5e 100644
--- a/src/CommonLib/src/ref_cnt.c
+++ b/src/CommonLib/src/ref_cnt.c
@@ -1,6 +1,6 @@
 #include "common_lib.h"
 #include "ref_cnt.h"
-#include "cl_memory.h"
+#include "memory.h"
 
 void
 RfcPreInit(
@@ -47,7 +47,7 @@ RfcReference(
 
     newRefCount = (DWORD)_InterlockedIncrement(&Object->ReferenceCount);
     ASSERT_INFO(MAX_DWORD > newRefCount, "Reached max reference count");
-    ASSERT_INFO( 1 <= newRefCount,
+    ASSERT_INFO( 1 <= newRefCount, 
                 "Inexistent object with %u references referenced",
                 newRefCount - 1
                 );
diff --git a/src/CommonLib/src/rtc_checks.c b/src/CommonLib/src/rtc_checks.c
index 36eed58..ab5c762 100644
--- a/src/CommonLib/src/rtc_checks.c
+++ b/src/CommonLib/src/rtc_checks.c
@@ -1,8 +1,3 @@
-#ifdef CL_NO_RUNTIME_CHECKS
-// warning C4206: nonstandard extension used: translation unit is empty
-#pragma warning(disable:4206)
-#else
-
 #include "common_lib.h"
 
 #define UNUSED_PATTERN     (DWORD)0xCC'CC'CC'CCUL
@@ -81,4 +76,3 @@ _RTC_CheckStackVars(
         );
     }
 }
-#endif // CL_NO_RUNTIME_CHECKS
diff --git a/src/CommonLib/src/rw_spinlock.c b/src/CommonLib/src/rw_spinlock.c
index be9ac8e..a38b06c 100644
--- a/src/CommonLib/src/rw_spinlock.c
+++ b/src/CommonLib/src/rw_spinlock.c
@@ -18,7 +18,7 @@ _When_(Exclusive, ACQUIRES_EXCL_AND_NON_REENTRANT_LOCK(*Spinlock))
 _When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RwSpinlockAcquire(
-    INOUT   RW_SPINLOCK     *Spinlock,
+    INOUT   PRW_SPINLOCK    Spinlock,
     OUT     INTR_STATE*     IntrState,
     IN      BOOLEAN         Exclusive
     )
@@ -73,13 +73,13 @@ _When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_NON_REENTRANT_
 _When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
 void
 RwSpinlockRelease(
-    INOUT   RW_SPINLOCK     *Spinlock,
+    INOUT   PRW_SPINLOCK    Spinlock,
     IN      INTR_STATE      IntrState,
     IN      BOOLEAN         Exclusive
     )
 {
     ASSERT( NULL != Spinlock );
-
+    
     if (Exclusive)
     {
         ASSERT( 1 == Spinlock->ActiveWriter );
diff --git a/src/CommonLib/src/seh.c b/src/CommonLib/src/seh.c
index a7bfc60..e2bddf8 100644
--- a/src/CommonLib/src/seh.c
+++ b/src/CommonLib/src/seh.c
@@ -1,8 +1,3 @@
-#ifdef CL_NO_RUNTIME_CHECKS
-// warning C4206: nonstandard extension used: translation unit is empty
-#pragma warning(disable:4206)
-#else
-
 #include "common_lib.h"
 #include "seh.h"
 
@@ -23,4 +18,3 @@ __C_specific_handler(
 
     return ExceptionContinueExecution;
 }
-#endif // CL_NO_RUNTIME_CHECKS
diff --git a/src/CommonLib/src/spinlock.c b/src/CommonLib/src/spinlock.c
index a966ca8..ef6a3b4 100644
--- a/src/CommonLib/src/spinlock.c
+++ b/src/CommonLib/src/spinlock.c
@@ -29,7 +29,7 @@ SpinlockAcquire(
     *IntrState = CpuIntrDisable();
 
     pCurrentCpu = CpuGetCurrent();
-
+    
     ASSERT_INFO(pCurrentCpu != Lock->Holder,
                 "Lock initial taken by function 0x%X, now called by 0x%X\n",
                 Lock->FunctionWhichTookLock,
@@ -57,32 +57,15 @@ SpinlockTryAcquire(
     OUT         INTR_STATE*     IntrState
     )
 {
-    PVOID pCurrentCpu;
-
     BOOLEAN acquired;
 
-    ASSERT(NULL != Lock);
-    ASSERT(NULL != IntrState);
-
     *IntrState = CpuIntrDisable();
 
-    pCurrentCpu = CpuGetCurrent();
-
     acquired = (LOCK_FREE == _InterlockedCompareExchange8(&Lock->State, LOCK_TAKEN, LOCK_FREE));
     if (!acquired)
     {
         CpuIntrSetState(*IntrState);
     }
-    else
-    {
-        ASSERT(NULL == Lock->FunctionWhichTookLock);
-        ASSERT(NULL == Lock->Holder);
-
-        Lock->Holder = pCurrentCpu;
-        Lock->FunctionWhichTookLock = *((PVOID*)_AddressOfReturnAddress());
-
-        ASSERT(LOCK_TAKEN == Lock->State);
-    }
 
     return acquired;
 }
@@ -104,8 +87,8 @@ SpinlockRelease(
     PVOID pCurrentCpu = CpuGetCurrent();
 
     ASSERT(NULL != Lock);
-    ASSERT_INFO(pCurrentCpu == Lock->Holder,
-                "LockTaken by CPU: 0x%X in function: 0x%X\nNow release by CPU: 0x%X in function: 0x%X\n",
+    ASSERT_INFO(pCurrentCpu == Lock->Holder, 
+                "LockTaken by CPU: 0x%X in function: 0x%X\nNow release by CPU: 0x%X in function: 0x%X\n", 
                 Lock->Holder, Lock->FunctionWhichTookLock,
                 pCurrentCpu, *( (PVOID*) _AddressOfReturnAddress() ) );
     ASSERT(INTR_OFF == CpuIntrGetState());
diff --git a/src/CommonLib/src/string.c b/src/CommonLib/src/string.c
new file mode 100644
index 0000000..c1d36b8
--- /dev/null
+++ b/src/CommonLib/src/string.c
@@ -0,0 +1,665 @@
+#include "common_lib.h"
+#include "string.h"
+#include "strutils.h"
+
+// 64 characters needed in case of %B specifier
+// with NULL terminator => 65 characters are required
+#define VSNPRINTF_BUFFER_SIZE               65
+
+int
+strcmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    i = 0;
+
+    while (('\0' != str1[i]) && ('\0' != str2[i]))
+    {
+        if (str1[i] > str2[i])
+        {
+            return 1;
+        }
+
+        if (str1[i] < str2[i])
+        {
+            return -1;
+        }
+
+        ++i;
+    }
+
+    // it means the second string is over but the first still has
+    // some characters
+    if ('\0' != str1[i])
+    {
+        return 1;
+    }
+
+    if ('\0' != str2[i])
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+int
+stricmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    i = 0;
+
+    while (('\0' != str1[i]) && ('\0' != str2[i]))
+    {
+        char c1 = tolower(str1[i]);
+        char c2 = tolower(str2[i]);
+
+        if (c1 > c2)
+        {
+            return 1;
+        }
+
+        if (c1 < c2)
+        {
+            return -1;
+        }
+
+        ++i;
+    }
+
+    // it means the second string is over but the first still has
+    // some characters
+    if ('\0' != str1[i])
+    {
+        return 1;
+    }
+
+    if ('\0' != str2[i])
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+int
+strncmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == length)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    i = 0;
+
+    for (i = 0; i < length && '\0' != str1[i] && '\0' != str2[i]; ++i)
+    {
+        if (str1[i] > str2[i])
+        {
+            return 1;
+        }
+
+        if (str1[i] < str2[i])
+        {
+            return -1;
+        }
+    }
+
+    if (i == length)
+    {
+        // they are truly equal
+        return 0;
+    }
+
+    if ('\0' != str1[i])
+    {
+        // string 1 is bigger
+        return 1;
+    }
+
+    // string 2 is bigger
+    return -1;
+}
+
+int
+strnicmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == length)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    i = 0;
+
+    for (i = 0; i < length && '\0' != str1[i] && '\0' != str2[i]; ++i)
+    {
+        char c1 = tolower(str1[i]);
+        char c2 = tolower(str2[i]);
+
+        if (c1 > c2)
+        {
+            return 1;
+        }
+
+        if (c1 < c2)
+        {
+            return -1;
+        }
+    }
+
+    if (i == length)
+    {
+        // they are truly equal
+        return 0;
+    }
+
+    if ('\0' != str1[i])
+    {
+        // string 1 is bigger
+        return 1;
+    }
+
+    // string 2 is bigger
+    return -1;
+}
+
+const
+char*
+strchr(
+    IN_Z  char* str,
+    IN  char c
+    )
+{
+    DWORD i;
+
+    if (NULL == str)
+    {
+        return NULL;
+    }
+
+    i = 0;
+
+    while ('\0' != str[i])
+    {
+        if (str[i] == c)
+        {
+            return (str + i);
+        }
+        ++i;
+    }
+
+    return str;
+}
+
+const
+char*
+strrchr(
+    IN_Z  char* str,
+    IN  char c
+    )
+{
+    DWORD i;
+    const char* charIndex;
+
+    if (NULL == str)
+    {
+        return NULL;
+    }
+
+    i = 0;
+    charIndex = str;
+
+    while ('\0' != str[i])
+    {
+        if (str[i] == c)
+        {
+            charIndex = (str + i);
+        }
+        ++i;
+    }
+
+    return charIndex;
+}
+
+void
+strcpy(
+    OUT_Z char* dst,
+    IN_Z  char* src
+    )
+{
+    DWORD i;
+
+    ASSERT( NULL != dst );
+    ASSERT( NULL != src );
+
+    i = 0;
+
+    while ('\0' != src[i])
+    {
+        dst[i] = src[i];
+        ++i;
+    }
+
+    dst[i] = '\0';
+}
+
+void
+strncpy(
+    OUT_WRITES(length + 1)  char* dst,
+    IN_READS_Z(length)      char* src,
+    IN                      DWORD length
+    )
+{
+    DWORD i;
+
+    ASSERT( NULL != dst );
+    ASSERT( NULL != src );
+    ASSERT( 0 != length );
+
+    i = 0;
+
+    for (i = 0; i < length && src[i] != '\0'; ++i)
+    {
+        dst[i] = src[i];
+    }
+
+    dst[i] = '\0';
+}
+
+SIZE_SUCCESS
+DWORD
+strlen(
+    IN_Z  char* str
+    )
+{
+    DWORD i;
+
+    if (NULL == str)
+    {
+        return INVALID_STRING_SIZE;
+    }
+
+    i = 0;
+
+    while ('\0' != str[i])
+    {
+        ++i;
+    }
+
+    return i;
+}
+
+SIZE_SUCCESS
+DWORD
+strlen_s(
+    IN_READS_Z(maxLen)
+                char*   str,
+    IN          DWORD   maxLen
+    )
+{
+    DWORD i;
+
+    if (NULL == str)
+    {
+        return INVALID_STRING_SIZE;
+    }
+
+    i = 0;
+
+    while (i < maxLen && '\0' != str[i])
+    {
+        ++i;
+    }
+
+    return i;
+}
+
+STATUS
+snprintf(
+    OUT_WRITES(buffSize)    char* outputBuffer,
+    IN                      DWORD buffSize,
+    IN_Z                    char* inputBuffer,
+    ...
+    )
+{
+    va_list va;
+
+    va_start(va, inputBuffer);
+
+    return vsnprintf(outputBuffer, buffSize, inputBuffer, va);
+}
+
+STATUS
+vsnprintf(
+    OUT_WRITES(buffSize)    char*       outputBuffer,
+    IN                      DWORD       buffSize,
+    IN_Z                    char*       inputBuffer,
+    INOUT                   va_list     argptr
+    )
+{
+    char temp[VSNPRINTF_BUFFER_SIZE];        // temporary buffer
+    DWORD index;                // index in Buffer
+    DWORD param_index;            // index which we want to find
+    QWORD temp_value;
+    DWORD outBufferOffset;
+    DWORD temp_len;
+    char* temp_str;
+
+    if (NULL == outputBuffer)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (0 == buffSize)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (NULL == inputBuffer)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    index = 0;
+    param_index = 1;
+    temp_value = 0;
+    outBufferOffset = 0;
+    temp_len = 0;
+    temp_str = temp;
+
+    while ('\0' != inputBuffer[index])
+    {
+        if ('%' == inputBuffer[index])
+        {
+            DWORD digits = 0;
+            DWORD fillSpaces = 0;
+            char next = inputBuffer[index + 1];
+            BOOLEAN firstSpecificator = TRUE;
+            char fillChar = ' ';
+            DWORD charsToCopy;
+
+            while (('0' <= next) && (next <= '9'))
+            {
+                if (firstSpecificator)
+                {
+                    firstSpecificator = FALSE;
+
+                    if ('0' == next)
+                    {
+                        fillChar = '0';
+                    }
+                }
+
+                digits = digits * 10 + next - '0';
+                index++;
+                next = inputBuffer[index + 1];
+            }
+
+
+            switch (next)
+            {
+            case 'b':
+                // we have an unsigned 32 bit value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TWO, FALSE);
+                break;
+            case 'B':
+                // we have an unsigned 64 bit value to print
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TWO, TRUE);
+                break;
+            case 'u':
+                // we have an unsigned 32 bit value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TEN, FALSE);
+                break;
+            case 'U':
+                // we have an unsigned 64 bit value to print
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TEN, TRUE);
+                break;
+            case 'd':
+                // we have a signed 32 bit value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, TRUE, temp_str, BASE_TEN, FALSE);
+                break;
+            case 'D':
+                // we have a signed 64 bit value
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, TRUE, temp_str, BASE_TEN, TRUE);
+                break;
+            case 'x':
+                // we have a 32 bit hexadecimal value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_HEXA, FALSE);
+                break;
+            case 'X':
+                // we have a 64 bit hexadecimal value to print
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_HEXA, TRUE);
+                break;
+            case 'c':
+                // we have a character value to print
+                temp_value = va_arg(argptr, char);
+                strncpy(temp_str, (char*)&temp_value, sizeof(char));
+                break;
+            case 's':
+            case 'S':
+                // we have a string to print
+                temp_str = va_arg(argptr, char*);
+                break;
+            default:
+                // A parsing error - an incorrect string was supplied =>
+                // return a status error
+                return STATUS_PARSE_FAILED;
+            }
+
+            temp_len = strlen(temp_str);
+            ASSERT(temp_len != INVALID_STRING_SIZE);
+
+            charsToCopy = (next == 'S') ? min(digits, temp_len) : temp_len;
+
+            if (outBufferOffset + temp_len >= buffSize)
+            {
+                // we don't have any more space
+                return STATUS_BUFFER_TOO_SMALL;
+            }
+            // see if we need to pad the string with spaces or with digits
+            fillSpaces = digits > temp_len ? digits - temp_len : 0;
+            if (outBufferOffset + temp_len + fillSpaces >= buffSize)
+            {
+                // we don't have any more space
+                return STATUS_BUFFER_TOO_SMALL;
+            }
+            if (0 != fillSpaces)
+            {
+                // put spaces
+                memset(outputBuffer + outBufferOffset, fillChar, fillSpaces);
+                outBufferOffset = outBufferOffset + fillSpaces;
+            }
+
+            if (charsToCopy != 0)
+            {
+                strncpy(outputBuffer + outBufferOffset, temp_str, charsToCopy);
+            }
+            outBufferOffset = outBufferOffset + charsToCopy;
+
+            param_index++;          // number of parameters parsed
+            index += 2;             // we advance in the format string
+            temp_str = temp;        // we need to reset temp_str to point to temp
+                                    // else, after a string operation it will point to the
+                                    // printed string
+        }
+        else
+        {
+            if (outBufferOffset + 1 >= buffSize)
+            {
+                // we don't have any more space
+                outputBuffer[outBufferOffset] = '\0';
+                return STATUS_BUFFER_TOO_SMALL;
+            }
+
+            outputBuffer[outBufferOffset] = inputBuffer[index];
+
+            outBufferOffset++;
+            index++;
+        }
+
+    }
+
+    outputBuffer[outBufferOffset] = '\0';
+
+    return param_index - 1;
+}
+
+const
+char*
+strtok_s(
+    _When_(*context == NULL, IN_Z)
+    _When_(*context != NULL, IN_OPT)
+                                char*       strToken,
+    IN_Z                        char*       delimiters,
+    INOUT                       char**      context
+    )
+{
+    DWORD i;
+    DWORD j;
+    char* pStr;
+
+    if (NULL == delimiters)
+    {
+        return NULL;
+    }
+
+    if (NULL == context)
+    {
+        return NULL;
+    }
+
+    if ((NULL == *context) && (NULL == strToken) )
+    {
+        return NULL;
+    }
+
+    pStr = (NULL == *context) ? strToken : *context;
+
+    if ('\0' == pStr[0])
+    {
+        // we reached the end of the string
+        return NULL;
+    }
+
+    for (i = 0; pStr[i] != '\0'; ++i)
+    {
+        for (j = 0; delimiters[j] != '\0'; ++j)
+        {
+            if (pStr[i] == delimiters[j])
+            {
+                pStr[i] = '\0';
+                *context = &pStr[i + 1];
+                return pStr;
+            }
+        }
+    }
+
+    // we return the whole string
+    // if we reached the end of the string the context must point to NULL as well
+    // else we go over our string boundary
+    *context = pStr[i] == '\0' ? &pStr[i] : &pStr[i + 1];
+
+    return pStr;
+}
+
+SIZE_SUCCESS
+DWORD
+strcelem(
+    IN_Z                    char*       string,
+    IN                      char        delimiter
+    )
+{
+    DWORD noOfElements;
+    const char* pPrevValue;
+
+    if (string == NULL)
+    {
+        return INVALID_STRING_SIZE;
+    }
+
+    // If we have n elements we will have n-1 spaces
+    // => start with 1 element
+    noOfElements = 1;
+    pPrevValue = string;
+
+    for (const char* curPosition = strchr(string, delimiter);
+         curPosition != pPrevValue;
+         curPosition = strchr(curPosition, delimiter))
+    {
+        noOfElements++;
+
+        // need to increment by 1 else we'll get stuck in a loop because strchr returns a pointer
+        // to the first occurrence of the character
+        curPosition++;
+        pPrevValue = curPosition;
+    }
+
+    return noOfElements;
+}
diff --git a/src/CommonLib/src/strutils.c b/src/CommonLib/src/strutils.c
index ad861c3..d10bef1 100644
--- a/src/CommonLib/src/strutils.c
+++ b/src/CommonLib/src/strutils.c
@@ -80,7 +80,7 @@ itoa(
         index++;
     }
 
-    // we convert the number and get a
+    // we convert the number and get a 
     // reversed ordered string
     while (0 != value)
     {
@@ -151,7 +151,7 @@ atoi(
         BYTE currentCharValue;
 
         ASSERT(isascii(buffer[i]));
-
+        
         // it's ok to use tolower even if we have a digit
         // because they are 0x30 -> 0x39 and an OR with 0x20 leaves
         // them unmodified
@@ -186,7 +186,7 @@ atoi(
     {
         // we can either have any negative number
         // or positive numbers smaller or equal to MAX_DWORD
-        ASSERT( negative || (value <= MAX_DWORD) );
+        ASSERT( negative || ( !negative && value <= MAX_DWORD ) );
 
         *((PDWORD)valueAddress) = (DWORD) value;
     }
diff --git a/src/CommonLibUnitTests/CommonLibUnitTests.vcxproj b/src/CommonLibUnitTests/CommonLibUnitTests.vcxproj
index a8186f4..65eccfc 100644
--- a/src/CommonLibUnitTests/CommonLibUnitTests.vcxproj
+++ b/src/CommonLibUnitTests/CommonLibUnitTests.vcxproj
@@ -14,20 +14,20 @@
     <ProjectGuid>{098EB03E-8151-46DB-9052-5136D9BC14EA}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>CommonLibUnitTests</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
diff --git a/src/Disk/Disk.vcxproj b/src/Disk/Disk.vcxproj
index ce5f0b1..04f3709 100644
--- a/src/Disk/Disk.vcxproj
+++ b/src/Disk/Disk.vcxproj
@@ -34,9 +34,10 @@
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -47,7 +48,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -58,13 +59,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
@@ -78,7 +72,7 @@
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <OmitFramePointers>true</OmitFramePointers>
       <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -98,36 +92,16 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
+      <WarningLevel>Level3</WarningLevel>
       <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
       <FunctionLevelLinking>true</FunctionLevelLinking>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
       <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <SDLCheck>true</SDLCheck>
     </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
   </ItemDefinitionGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
diff --git a/src/Disk/inc/mbr.h b/src/Disk/inc/mbr.h
index fa0ebba..3fa3ee6 100644
--- a/src/Disk/inc/mbr.h
+++ b/src/Disk/inc/mbr.h
@@ -18,8 +18,6 @@
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
@@ -35,7 +33,7 @@ STATIC_ASSERT(sizeof(CHS_ADDRESS) == CHS_ADDRESS_SIZE);
 typedef struct _MBR_PARTITION_ENTRY
 {
     // 0x80 - active (old MBRs only accept this value as valid)
-    // 0x00 - inactive
+    // 0x00 - inactive 
     // 0x1 - 7xF invalid
     BYTE                    Status;
     CHS_ADDRESS             FirstSectorCHS;
@@ -54,5 +52,5 @@ typedef struct _MBR
 } MBR, *PMBR;
 STATIC_ASSERT(sizeof(MBR) == MBR_SIZE);
 
-#pragma warning(pop)
-#pragma pack(pop)
+#pragma warning(default:4214)
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src/Disk/src/disk.c b/src/Disk/src/disk.c
index 57e6b3b..1d77aaa 100644
--- a/src/Disk/src/disk.c
+++ b/src/Disk/src/disk.c
@@ -11,12 +11,14 @@ _DiskInitialize(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _DiskRetrievePartitionsFromDisk(
     INOUT   PDEVICE_OBJECT          DiskDevice
     );
 
 static
+SAL_SUCCESS
 STATUS
 _DiskRetrievePartitionsFromDiskStartingAtOffset(
     INOUT   PDEVICE_OBJECT              DiskDevice,
@@ -27,6 +29,7 @@ _DiskRetrievePartitionsFromDiskStartingAtOffset(
     OUT_OPT PDISK_LAYOUT_INFORMATION    DiskLayoutInformation
     );
 
+SAL_SUCCESS
 STATUS
 (__cdecl DiskDriverEntry)(
     INOUT       PDRIVER_OBJECT      DriverObject
@@ -57,12 +60,9 @@ STATUS
         LOG_FUNC_ERROR("IoGetDeviceByType", status);
         return status;
     }
-    ASSERT(numberOfDevices == 0 || pHardDiskControllerDevices != NULL);
 
     for (i = 0; i < numberOfDevices; ++i)
     {
-        ASSERT(pHardDiskControllerDevices[i] != NULL);
-
         status = _DiskInitialize(DriverObject,
                                  pHardDiskControllerDevices[i]
                                  );
@@ -190,6 +190,7 @@ _DiskInitialize(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _DiskRead(
     IN                                          PDEVICE_OBJECT  DiskDevice,
@@ -266,6 +267,7 @@ _DiskRead(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _DiskRetrievePartitionsFromDisk(
     INOUT   PDEVICE_OBJECT          DiskDevice
@@ -329,6 +331,7 @@ _DiskRetrievePartitionsFromDisk(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _DiskRetrievePartitionsFromDiskStartingAtOffset(
     INOUT   PDEVICE_OBJECT              DiskDevice,
diff --git a/src/Disk/src/disk_dispatch.c b/src/Disk/src/disk_dispatch.c
index 7a307b0..232d35a 100644
--- a/src/Disk/src/disk_dispatch.c
+++ b/src/Disk/src/disk_dispatch.c
@@ -1,6 +1,7 @@
 #include "disk_base.h"
 #include "disk_dispatch.h"
 
+SAL_SUCCESS
 STATUS
 (__cdecl DiskDispatchReadWrite)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -41,6 +42,7 @@ STATUS
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl DiskDispatchDeviceControl)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
diff --git a/src/Eth_82574L/Eth_82574L.vcxproj b/src/Eth_82574L/Eth_82574L.vcxproj
index 82ad07b..cd57990 100644
--- a/src/Eth_82574L/Eth_82574L.vcxproj
+++ b/src/Eth_82574L/Eth_82574L.vcxproj
@@ -23,9 +23,10 @@
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -36,7 +37,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -47,13 +48,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
@@ -67,7 +61,7 @@
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <OmitFramePointers>true</OmitFramePointers>
       <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -85,36 +79,16 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
+      <WarningLevel>Level3</WarningLevel>
       <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc;..\NetworkPort\inc</AdditionalIncludeDirectories>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
       <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
     </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="src\eth_82574L.c" />
diff --git a/src/Eth_82574L/headers/eth_82574L_operations.h b/src/Eth_82574L/headers/eth_82574L_operations.h
index d0d019a..d9dd813 100644
--- a/src/Eth_82574L/headers/eth_82574L_operations.h
+++ b/src/Eth_82574L/headers/eth_82574L_operations.h
@@ -1,5 +1,6 @@
 #pragma once
 
+SAL_SUCCESS
 STATUS
 EthInitializeDevice(
     IN_READS(ETH_NO_OF_BARS_USED)   PPCI_BAR        Bars,
diff --git a/src/Eth_82574L/headers/eth_82574L_regs.h b/src/Eth_82574L/headers/eth_82574L_regs.h
index 1b7d2c5..bf0cf65 100644
--- a/src/Eth_82574L/headers/eth_82574L_regs.h
+++ b/src/Eth_82574L/headers/eth_82574L_regs.h
@@ -4,8 +4,6 @@
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
@@ -19,14 +17,14 @@
 // 0x04 - RW
 typedef union _DEVICE_CONTROL_REGISTER
 {
-    struct
+    struct  
     {
         DWORD               FullDuplex                      : 1;
 
         DWORD               __Reserved0                     : 1;
 
         DWORD               GIOMasterDisable                : 1;
-
+        
         DWORD               __Reserved1                     : 2;
 
         DWORD               AutoSpeedDetectionEnable        : 1;
@@ -103,7 +101,7 @@ STATIC_ASSERT(sizeof(DEVICE_STATUS_REGISTER) == ETH_INTERNAL_REG_SIZE);
 // 0xC0 - RC/WC
 typedef union _INT_CAUSE_READ_REGISTER
 {
-    struct
+    struct  
     {
         // Set when hardware processes a descriptor with RS set. If using
         // delayed interrupts(IDE set), the interrupt is delayed until after one of
@@ -152,7 +150,7 @@ STATIC_ASSERT(sizeof(INT_CAUSE_READ_REGISTER) == ETH_INTERNAL_REG_SIZE);
 // 0xD0 - RW
 typedef union _INT_MASK_SET_REGISTER
 {
-    struct
+    struct  
     {
         // Sets the mask for transmit descriptor written back.
         DWORD               TdWrittenBack                   : 1;
@@ -221,7 +219,7 @@ STATIC_ASSERT(sizeof(INT_MASK_SET_REGISTER) == ETH_INTERNAL_REG_SIZE);
 // 0xD8 - W
 typedef union _INT_MASK_CLEAR_REGISTER
 {
-    struct
+    struct  
     {
         // Clears the mask for transmit descriptor written back.
         DWORD               TdWrittenBack                   : 1;
@@ -297,7 +295,7 @@ typedef union _INT_MASK_CLEAR_REGISTER
 // 0x100 - RW
 typedef union _RECEIVE_CONTROL_REGISTER
 {
-    struct
+    struct  
     {
         DWORD               __Reserved0                     : 1;
 
@@ -311,7 +309,7 @@ typedef union _RECEIVE_CONTROL_REGISTER
         DWORD               UnicastPromiscuousEnable        : 1;
 
         DWORD               MulticastPromiscuousEnable      : 1;
-
+        
         DWORD               LongPacketEnable                : 1;
 
         // Should always be set to 00b
@@ -355,7 +353,7 @@ typedef union _RECEIVE_CONTROL_REGISTER
         DWORD               VlanFilterEnable                : 1;
 
         DWORD               CanonicalFormIndicatorEnable    : 1;
-
+        
         DWORD               CanonicalFormIndiicatorValue    : 1;
 
         DWORD               __Reserved2                     : 1;
@@ -387,7 +385,7 @@ STATIC_ASSERT(sizeof(RECEIVE_CONTROL_REGISTER) == ETH_INTERNAL_REG_SIZE);
 // 0x2800 - RW
 typedef union _RD_BASE_ADDRESS_LOW
 {
-    struct
+    struct  
     {
         DWORD                   __Ignored0                      :  4;
 
@@ -423,13 +421,13 @@ STATIC_ASSERT(sizeof(RD_LENGTH) == ETH_INTERNAL_REG_SIZE);
 // 0x2810 - RW
 typedef union _RD_HEAD
 {
-    struct
+    struct  
     {
         // This register contains the head pointer for the receive descriptor buffer.The register
         // points to a 16 - byte datum.Hardware controls the pointer.The only time that software
         // should write to this register is after a reset(hardware reset or CTRL.RST) and before
         // enabling the receive function(RCTL.EN).
-        /// ATTENTION: If software were to write to this register while the receive function was
+        /// ATTENTION: If software were to write to this register while the receive function was 
         /// enabled, the on - chip descriptor buffers might be invalidated and the hardware
         /// could be become unstable.
         WORD                    Head;
@@ -523,7 +521,7 @@ STATIC_ASSERT(sizeof(TRANSMIT_INTERRUPT_ABSOLUTE_DELAY_TIMER) == ETH_INTERNAL_RE
 // 0x5008 - RW
 typedef union _RECEIVE_FILTER_CONTROL_REGISTER
 {
-    struct
+    struct 
     {
         // Disable the iSCSI filtering.
         DWORD                   IScsiDisable                    :  1;
@@ -656,7 +654,7 @@ STATIC_ASSERT(sizeof(TRANSMIT_CONTROL_REGISTER) == ETH_INTERNAL_REG_SIZE);
 // 0x3800 - RW
 typedef union _TD_BASE_ADDRESS_LOW
 {
-    struct
+    struct  
     {
         DWORD                   __Ignored0                      :  4;
 
@@ -677,13 +675,13 @@ STATIC_ASSERT(sizeof(TD_BASE_ADDRESS_HIGH) == ETH_INTERNAL_REG_SIZE);
 // 0x3808 - RW
 typedef union _TD_LENGTH
 {
-    struct
+    struct  
     {
         // Number of bytes allocated for descriptors in the circular descriptor
         // buffer.It must be 128 - byte aligned.
         DWORD                   Length                          : 20;
 
-        DWORD                   __Reserved0                     : 12;
+        DWORD                   __Reserved0                     : 12;      
     };
     DWORD                       Raw;
 } TD_LENGTH, *PTD_LENGTH;
@@ -692,7 +690,7 @@ STATIC_ASSERT(sizeof(TD_LENGTH) == ETH_INTERNAL_REG_SIZE);
 // 0x3810 - RW
 typedef union _TD_HEAD
 {
-    struct
+    struct  
     {
         // This register contains the head pointer for the transmit descriptor ring.It points to a
         // 16 - byte datum.Hardware controls this pointer.The only time that software should
@@ -723,5 +721,6 @@ typedef union _TD_TAIL
 } TD_TAIL, *PTD_TAIL;
 STATIC_ASSERT(sizeof(TD_TAIL) == ETH_INTERNAL_REG_SIZE);
 
-#pragma warning(pop)
-#pragma pack(pop)
+#pragma warning(default:4214)
+#pragma warning(default:4201)
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src/Eth_82574L/headers/eth_82574L_structures.h b/src/Eth_82574L/headers/eth_82574L_structures.h
index 25909f3..e670f62 100644
--- a/src/Eth_82574L/headers/eth_82574L_structures.h
+++ b/src/Eth_82574L/headers/eth_82574L_structures.h
@@ -37,8 +37,6 @@
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
@@ -323,7 +321,8 @@ typedef struct _TX_DATA
     LOCK                                    TxInterruptLock;
 } TX_DATA, *PTX_DATA;
 
-#pragma warning(pop)
+#pragma warning(default:4214)
+#pragma warning(default:4201)
 
 typedef struct _ETH_DEVICE
 {
diff --git a/src/Eth_82574L/src/eth_82574L.c b/src/Eth_82574L/src/eth_82574L.c
index e30862c..e31e301 100644
--- a/src/Eth_82574L/src/eth_82574L.c
+++ b/src/Eth_82574L/src/eth_82574L.c
@@ -50,6 +50,7 @@ _EthInitializeBuffers(
     Buffers->BufferSize = BufferInit->BufferSize;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl Eth82574LDriverEntry)(
     INOUT       PDRIVER_OBJECT      DriverObject
diff --git a/src/Eth_82574L/src/eth_82574L_operations.c b/src/Eth_82574L/src/eth_82574L_operations.c
index 71dc96d..583005f 100644
--- a/src/Eth_82574L/src/eth_82574L_operations.c
+++ b/src/Eth_82574L/src/eth_82574L_operations.c
@@ -53,6 +53,7 @@ _EthRetrieveMacAddress(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _EthRxInit(
     IN      PETH_DEVICE         Device
@@ -65,6 +66,7 @@ _EthTxInit(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _EthInterruptInit(
     IN      PETH_DEVICE         Device
@@ -82,6 +84,7 @@ _EthSignalTxQueueFullIfNecessary(
     IN      PETH_DEVICE         Device
     );
 
+SAL_SUCCESS
 STATUS
 EthInitializeDevice(
     IN_READS(ETH_NO_OF_BARS_USED)   PPCI_BAR        Bars,
@@ -459,6 +462,7 @@ _EthRetrieveMacAddress(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _EthRxInit(
     IN      PETH_DEVICE         Device
@@ -591,6 +595,7 @@ _EthTxInit(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _EthInterruptInit(
     IN      PETH_DEVICE         Device
diff --git a/src/FAT32/FAT32.vcxproj b/src/FAT32/FAT32.vcxproj
index 86ea2c4..f978df0 100644
--- a/src/FAT32/FAT32.vcxproj
+++ b/src/FAT32/FAT32.vcxproj
@@ -5,10 +5,6 @@
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}</ProjectGuid>
@@ -23,12 +19,6 @@
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
@@ -37,9 +27,6 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <LinkIncremental>true</LinkIncremental>
@@ -49,14 +36,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <LinkIncremental>true</LinkIncremental>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <PrecompiledHeader>
@@ -71,7 +50,7 @@
       <CompileAsManaged>false</CompileAsManaged>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
       <OmitFramePointers>true</OmitFramePointers>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -92,45 +71,6 @@
       <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>MaxSpeed</Optimization>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <EnablePREfast>true</EnablePREfast>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-  </ItemDefinitionGroup>
   <ItemGroup>
     <ClInclude Include="headers\fat32_base.h" />
     <ClInclude Include="headers\fat_structures.h" />
diff --git a/src/FAT32/headers/fat_operations.h b/src/FAT32/headers/fat_operations.h
index 00631b5..0adbe1d 100644
--- a/src/FAT32/headers/fat_operations.h
+++ b/src/FAT32/headers/fat_operations.h
@@ -21,26 +21,13 @@ typedef struct _FAT_DATA
     DWORD               AllocationSize;
 } FAT_DATA, *PFAT_DATA;
 
- typedef
-STATUS
-(__cdecl FUNC_FatReadWriteFile)(
-    IN      PFAT_DATA   FatData,
-    IN      QWORD       BaseFileSector,
-    IN      QWORD       SectorOffset,
-    IN      QWORD       DirEntrySector,
-    IN      PVOID       Buffer,
-    IN      QWORD       SectorsToReadOrWrite,
-    OUT     QWORD*      SectorsReadOrWritten,
-    IN      BOOLEAN     Asynchronous
-    );
-
-typedef FUNC_FatReadWriteFile *PFUNC_FatReadWriteFile;
-
+SAL_SUCCESS
 STATUS
 FatInitVolume(
     INOUT          PFAT_DATA           FatData
     );
 
+SAL_SUCCESS
 STATUS
 FatSearch(
     IN      PFAT_DATA               FatData,
@@ -51,6 +38,7 @@ FatSearch(
     OUT     QWORD*                  ParentSector
     );
 
+SAL_SUCCESS
 STATUS
 FatSearchDirectoryEntry(
     IN      PFAT_DATA               FatData,
@@ -62,30 +50,19 @@ FatSearchDirectoryEntry(
     OUT     QWORD*                  ParentSector
     );
 
+SAL_SUCCESS
 STATUS
 FatReadFile(
     IN      PFAT_DATA   FatData,
     IN      QWORD       BaseFileSector,
     IN      QWORD       SectorOffset,
-    IN      QWORD       DirEntrySector,
     IN      PVOID       Buffer,
     IN      QWORD       SectorsToRead,
     OUT     QWORD*      SectorsRead,
     IN      BOOLEAN     Asynchronous
     );
 
-STATUS
-FatWriteFile(
-    IN      PFAT_DATA   FatData,
-    IN      QWORD       BaseFileSector,
-    IN      QWORD       SectorOffset,
-    IN      QWORD       DirEntrySector,
-    IN      PVOID       Buffer,
-    IN      QWORD       SectorsToWrite,
-    OUT     QWORD*      SectorsWritten,
-    IN      BOOLEAN     Asynchronous
-);
-
+SAL_SUCCESS
 STATUS
 FatCreateDirectoryEntry(
     IN      PFAT_DATA       FatData,
@@ -93,11 +70,12 @@ FatCreateDirectoryEntry(
     IN      BYTE            FileAttributes
     );
 
+SAL_SUCCESS
 STATUS
 FatQueryDirectory(
     IN                                              PFAT_DATA                       FatData,
     IN                                              QWORD                           DirectorySector,
     IN                                              DWORD                           DirectoryInformationSize,
-    OUT_WRITES_BYTES(DirectoryInformationSize)      FILE_DIRECTORY_INFORMATION      *DirectoryInformation,
+    OUT_WRITES_BYTES(DirectoryInformationSize)      PFILE_DIRECTORY_INFORMATION     DirectoryInformation,
     OUT                                             DWORD*                          RequiredDirectionInformationSize
     );
\ No newline at end of file
diff --git a/src/FAT32/headers/fat_structures.h b/src/FAT32/headers/fat_structures.h
index b8f871a..a60120e 100644
--- a/src/FAT32/headers/fat_structures.h
+++ b/src/FAT32/headers/fat_structures.h
@@ -17,8 +17,8 @@
 #define        ATTR_LONG_NAME_MASK          (ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID|ATTR_DIRECTORY|ATTR_ARCHIVE)
 
 // Short Directory entry name length
-#define        SHORT_NAME_NAME              8
-#define        SHORT_NAME_EXT               3
+#define     SHORT_NAME_NAME                 8
+#define     SHORT_NAME_EXT                  3
 #define        SHORT_NAME_CHARS             11
 
 // Long Directory Entries char lengths
@@ -27,8 +27,6 @@
 #define        LONG_NAME3_CHARS             2
 #define        LONG_NAME_TOTAL_CHARS        (LONG_NAME1_CHARS+LONG_NAME2_CHARS+LONG_NAME3_CHARS)
 
-#define        LONG_NAME_MAX_CHARS          255
-
 #define        MAX_SECTORS_FOR_LONG_ENTRY    3
 
 // Values in DIR_Name[0] to check to see if entry
@@ -37,8 +35,6 @@
 #define        FREE_ALL                     0x00
 #define        FREE_JAP_ENTRY               0x05
 
-#define        LONG_NAME_ORD_END_MASK       0x40
-
 // FAT Date format values
 #define        FAT_DAY_BITS                 5
 #define        FAT_MONTH_BITS               4
@@ -90,17 +86,11 @@
 // Bad cluster value
 #define        FAT32_BAD_CLUSTER            0x0FFFFFF7
 
-// Checks if cluster number marks the end of the cluster chain
-#define        FAT32_EOC(cluster)           ((cluster) > FAT32_BAD_CLUSTER)
-
-#define        FAT32_UNKNOWN                0xFFFFFFFF
 
 // Maximum number of clusters per FAT type
 #define        FAT12_MAX_CLUSTERS           4085
 #define        FAT16_MAX_CLUSTERS           65525
 
-//typedef     WORD    FAT16_ENTRY;
-typedef     DWORD   FAT32_ENTRY;
 
 /////////////////////////////////////////////////////////////////////////////////////////////////
 /////////                                    STRUCTURES                                 /////////
@@ -110,8 +100,6 @@ typedef     DWORD   FAT32_ENTRY;
 // Directory entry structure
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 //warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 typedef struct _FATDATE
@@ -134,7 +122,7 @@ typedef struct _FATTIME
     WORD        Hour    : 5;
 } FATTIME, *PFATTIME;
 STATIC_ASSERT(sizeof(FATTIME) == sizeof(WORD));
-#pragma warning(pop)
+#pragma warning(default:4214)
 
 typedef struct _DIR_ENTRY
 {
@@ -188,7 +176,6 @@ typedef struct _LONG_DIR_ENTRY
     BYTE            LDIR_Name3[4];
 } LONG_DIR_ENTRY, *PLONG_DIR_ENTRY;
 
-// Found in sector 1 of the partition
 typedef struct _FSINFO
 {
     DWORD           FSI_LeadSig;
@@ -200,7 +187,6 @@ typedef struct _FSINFO
     DWORD           FSI_TrailSig;
 } FSINFO, *PFSINFO;
 
-// Found in sector 0 of the partition
 typedef struct _FAT_BPB
 {
     BYTE            BS_jmpBoot[3];      // jump instruction
diff --git a/src/FAT32/headers/fat_utils.h b/src/FAT32/headers/fat_utils.h
index 0c9edda..4718080 100644
--- a/src/FAT32/headers/fat_utils.h
+++ b/src/FAT32/headers/fat_utils.h
@@ -1,76 +1,57 @@
 #pragma once
 
+SAL_SUCCESS
 STATUS
 NextSectorInClusterChain(
     IN      PFAT_DATA       FatData,
     IN      QWORD           CurrentSector,
-    OUT     QWORD*          NextSector,
-    IN      BOOLEAN         ExtendChain
-);
+    OUT     QWORD*          NextSector
+    );
 
+SAL_SUCCESS
 STATUS
 NextClusterInChain(
     IN      PFAT_DATA       FatData,
     IN      QWORD           CurrentCluster,
     OUT     QWORD*          Result
-);
+    );
 
+SAL_SUCCESS
 STATUS
 FirstSectorOfCluster(
     IN      PFAT_DATA   FatData,
     IN      QWORD       Cluster,
     OUT     QWORD*      Result
-);
+    );
 
+SAL_SUCCESS
 STATUS
 ClusterOfSector(
     IN      PFAT_DATA   FatData,
     IN      QWORD       Sector,
     OUT     QWORD*      Result
-);
-
-STATUS
-GetDirEntryFromSector(
-    IN      PFAT_DATA   FatData,
-    IN      QWORD       EntrySector,
-    IN      QWORD       DirFirstSector, // search criterion
-    OUT     QWORD*      EntryIndex,
-    OUT     DIR_ENTRY*  DirEntry
-);
-
-STATUS
-WriteDirEntryToSector(
-    IN      PFAT_DATA   FatData,
-    IN      QWORD       EntrySector,
-    IN      QWORD       EntryIndex,
-    IN      DIR_ENTRY*  DirEntry
-);
+    );
 
+SAL_SUCCESS
 STATUS
 ConvertFatDateTimeToDateTime(
     IN      FATDATE*    FatDate,
     IN      FATTIME*    FatTime,
     OUT     DATETIME*   DateTime
-);
+    );
 
 void
 ConvertDateTimeToFatDateTime(
     IN      PDATETIME   DateTime,
     OUT     FATDATE*    FatDate,
     OUT     FATTIME*    FatTime
-);
+    );
 
+SAL_SUCCESS
 STATUS
 ConvertFatNameToName(
     IN_READS(SHORT_NAME_CHARS)      char*       FatName,
     IN                              DWORD       BufferSize,
     OUT_WRITES(BufferSize)          char*       Buffer,
     OUT                             DWORD*      ActualNameLength
-);
-
-STATUS
-WritePartialLongFatNameToName(
-    IN                          LONG_DIR_ENTRY* LongDirEntry,
-    IN                          DWORD           BufferSize,
-    INOUT_UPDATES(BufferSize)   char*           Buffer
-);
+    );
\ No newline at end of file
diff --git a/src/FAT32/src/fat32.c b/src/FAT32/src/fat32.c
index 656fae1..92119c4 100644
--- a/src/FAT32/src/fat32.c
+++ b/src/FAT32/src/fat32.c
@@ -4,7 +4,7 @@
 
 FUNC_DriverDispatch     _FatDispatchCreate;
 FUNC_DriverDispatch     _FatDispatchClose;
-FUNC_DriverDispatch     _FatDispatchReadWrite;
+FUNC_DriverDispatch     _FatDispatchRead;
 FUNC_DriverDispatch     _FatDispatchQueryInformation;
 FUNC_DriverDispatch     _FatDispatchDirectoryControl;
 
@@ -18,6 +18,7 @@ typedef struct _FCB
     FILE_INFORMATION    FileInformation;
 } FCB, *PFCB;
 
+SAL_SUCCESS
 STATUS
 (__cdecl FatDriverEntry)(
     INOUT       PDRIVER_OBJECT      DriverObject
@@ -47,8 +48,7 @@ STATUS
 
     DriverObject->DispatchFunctions[IRP_MJ_CREATE] = _FatDispatchCreate;
     DriverObject->DispatchFunctions[IRP_MJ_CLOSE] = _FatDispatchClose;
-    DriverObject->DispatchFunctions[IRP_MJ_READ] = _FatDispatchReadWrite;
-    DriverObject->DispatchFunctions[IRP_MJ_WRITE] = _FatDispatchReadWrite;
+    DriverObject->DispatchFunctions[IRP_MJ_READ] = _FatDispatchRead;
     DriverObject->DispatchFunctions[IRP_MJ_QUERY_INFORMATION] = _FatDispatchQueryInformation;
     DriverObject->DispatchFunctions[IRP_MJ_DIRECTORY_CONTROL] = _FatDispatchDirectoryControl;
 
@@ -81,11 +81,11 @@ STATUS
 
             // send an IOCTL to see device description
             pIrp = IoBuildDeviceIoControlRequest(IOCTL_VOLUME_PARTITION_INFO,
-                pCurVolume,
-                NULL,
-                0,
-                &partitionInformation,
-                sizeof(PARTITION_INFORMATION)
+                                                 pCurVolume,
+                                                 NULL,
+                                                 0,
+                                                 &partitionInformation,
+                                                 sizeof(PARTITION_INFORMATION)
             );
             if (NULL == pIrp)
             {
@@ -171,6 +171,7 @@ STATUS
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl _FatDispatchCreate)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -211,7 +212,7 @@ STATUS
     ASSERT(NULL == pStackLocation->FileObject->RelatedFileObject);
 
     fileType = (TRUE == pStackLocation->FileObject->Flags.DirectoryFile) ? ATTR_DIRECTORY : ATTR_NORMAL;
-    createOperation = (BOOLEAN)pStackLocation->FileObject->Flags.Create;
+    createOperation = (BOOLEAN) pStackLocation->FileObject->Flags.Create;
 
     __try
     {
@@ -221,7 +222,7 @@ STATUS
             status = FatCreateDirectoryEntry(pFatData, pStackLocation->FileObject->FileName, fileType);
             if (!SUCCEEDED(status))
             {
-                LOG_TRACE_FILESYSTEM("[ERROR]FatCreateDirectoryEntry with status 0x%x\n", status);
+                LOG_FUNC_ERROR("FatCreateDirectoryEntry", status);
                 __leave;
             }
 
@@ -229,15 +230,15 @@ STATUS
         }
 
         status = FatSearch(pFatData,
-            pStackLocation->FileObject->FileName,
-            &fileSector,
-            fileType,
-            &fileInformation,
-            &parentSector
+                           pStackLocation->FileObject->FileName,
+                           &fileSector,
+                           fileType,
+                           &fileInformation,
+                           &parentSector
         );
         if (!SUCCEEDED(status))
         {
-            LOG_TRACE_FILESYSTEM("[ERROR]FatSearch failed with status 0x%x\n", status);
+            LOG_FUNC_ERROR("FatSearch", status);
             __leave;
         }
 
@@ -250,7 +251,7 @@ STATUS
         }
 
         pFcb->FileOffsetInVolume = fileSector;
-        pFcb->ParentOffsetInVolume = parentSector;
+        pFcb->ParentOffsetInVolume = fileSector;
         memcpy(&pFcb->FileInformation, &fileInformation, sizeof(FILE_INFORMATION));
 
         pStackLocation->FileObject->FileSize = fileInformation.FileSize;
@@ -269,6 +270,7 @@ STATUS
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl _FatDispatchClose)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -310,8 +312,9 @@ STATUS
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
-(__cdecl _FatDispatchReadWrite)(
+(__cdecl _FatDispatchRead)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
     INOUT       PIRP                Irp
     )
@@ -319,10 +322,10 @@ STATUS
     STATUS status;
     PIO_STACK_LOCATION pStackLocation;
     PFAT_DATA pFatData;
+    BYTE fileType;
+    BOOLEAN createOperation;
     PFCB pFcb;
-    QWORD sectorsReadOrWritten;
-
-    PFUNC_FatReadWriteFile FatReadWriteFunc;
+    QWORD sectorsRead;
 
     LOG_FUNC_START;
 
@@ -332,16 +335,18 @@ STATUS
     status = STATUS_SUCCESS;
     pStackLocation = NULL;
     pFatData = NULL;
+    fileType = 0;
+    createOperation = FALSE;
     pFcb = NULL;
-    sectorsReadOrWritten = 0;
+    sectorsRead = 0;
 
     pStackLocation = IoGetCurrentIrpStackLocation(Irp);
-    ASSERT(IRP_MJ_READ == pStackLocation->MajorFunction || IRP_MJ_WRITE == pStackLocation->MajorFunction);
+    ASSERT(IRP_MJ_READ == pStackLocation->MajorFunction);
 
     pFatData = IoGetDeviceExtension(DeviceObject);
     ASSERT(NULL != pFatData);
 
-    pFcb = (PFCB)pStackLocation->FileObject->FsContext2;
+    pFcb = (PFCB) pStackLocation->FileObject->FsContext2;
     ASSERT(NULL != pFcb);
 
     ASSERT(MAX_DWORD >= pFcb->FileOffsetInVolume);
@@ -352,36 +357,24 @@ STATUS
 
     __try
     {
-        if (IRP_MJ_READ == pStackLocation->MajorFunction)
-        {
-            FatReadWriteFunc = FatReadFile;
-        }
-        else
-        {
-            ASSERT(pStackLocation->MajorFunction == IRP_MJ_WRITE);
-            FatReadWriteFunc = FatWriteFile;
-        }
-
-        status = FatReadWriteFunc(
-            pFatData,
-            (DWORD)pFcb->FileOffsetInVolume,
-            (DWORD)(pStackLocation->Parameters.ReadWrite.Offset / pFatData->BytesPerSector),
-            pFcb->ParentOffsetInVolume,
-            Irp->Buffer,
-            (DWORD)(pStackLocation->Parameters.ReadWrite.Length / pFatData->BytesPerSector),
-            &sectorsReadOrWritten,
-            (BOOLEAN)Irp->Flags.Asynchronous
-        );
+        status = FatReadFile(pFatData,
+                             (DWORD) pFcb->FileOffsetInVolume,
+                             (DWORD) ( pStackLocation->Parameters.ReadWrite.Offset / pFatData->BytesPerSector ),
+                             Irp->Buffer,
+                             (DWORD) ( pStackLocation->Parameters.ReadWrite.Length / pFatData->BytesPerSector ),
+                             &sectorsRead,
+                             (BOOLEAN) Irp->Flags.Asynchronous
+                             );
         if (!SUCCEEDED(status))
         {
-            LOG_FUNC_ERROR("FatReadWriteFunc", status);
+            LOG_FUNC_ERROR("FatReadFile", status);
             __leave;
         }
     }
     __finally
     {
         Irp->IoStatus.Status = status;
-        Irp->IoStatus.Information = sectorsReadOrWritten * pFatData->BytesPerSector;
+        Irp->IoStatus.Information = sectorsRead * pFatData->BytesPerSector;
 
         IoCompleteIrp(Irp);
 
@@ -391,6 +384,7 @@ STATUS
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl _FatDispatchQueryInformation)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -444,6 +438,7 @@ STATUS
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl _FatDispatchDirectoryControl)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -490,10 +485,10 @@ STATUS
 
         // status = FatQueryDirectory
         status = FatQueryDirectory(pFatData,
-            pFcb->FileOffsetInVolume,
-            pStackLocation->Parameters.QueryDirectory.Length,
-            Irp->Buffer,
-            &information
+                                   pFcb->FileOffsetInVolume,
+                                   pStackLocation->Parameters.QueryDirectory.Length,
+                                   Irp->Buffer,
+                                   &information
         );
         if (!SUCCEEDED(status))
         {
diff --git a/src/FAT32/src/fat_operations.c b/src/FAT32/src/fat_operations.c
index 1d44c87..d3a9c46 100644
--- a/src/FAT32/src/fat_operations.c
+++ b/src/FAT32/src/fat_operations.c
@@ -2,19 +2,19 @@
 #include "fat_operations.h"
 #include "fat_utils.h"
 
-
 static
 void
 _FatPopulateFileInformationFromFatEntry(
     IN      PFAT_DATA               FatData,
     IN      PDIR_ENTRY              DirEntry,
     OUT     PFILE_INFORMATION       FileInformation
-);
+    );
 
+SAL_SUCCESS
 STATUS
 FatInitVolume(
     INOUT          PFAT_DATA           FatData
-)
+    )
 {
     STATUS status;
     FAT_BPB bpb;
@@ -136,11 +136,12 @@ FatInitVolume(
     LOG_TRACE_FILESYSTEM("ALlocation size: %d\n", FatData->AllocationSize);
 
     ASSERT_INFO(FatData->AllocationSize >= pVolumeDevice->DeviceAlignment,
-        "The FAT driver does not handle issues caused by greater device alignment needed by volume devices");
+                "The FAT driver does not handle issues caused by greater device alignment needed by volume devices" );
 
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 FatSearch(
     IN      PFAT_DATA               FatData,
@@ -149,10 +150,10 @@ FatSearch(
     IN      BYTE                    SearchType,
     OUT_OPT PFILE_INFORMATION       FileInformation,
     OUT     QWORD*                  ParentSector
-)
+    )
 {
     // name of current entry to search ( name between backslashes )
-    char partialName[LONG_NAME_MAX_CHARS];
+    char partialName[13];
 
     // current index of partial name in the full path name
     DWORD startIndexInName;
@@ -202,7 +203,7 @@ FatSearch(
         LOG_TRACE_FILESYSTEM("Search for root directory\n");
 
         // we have the root directory
-        if (ATTR_DIRECTORY != (SearchType & ATTR_DIRECTORY))
+        if (ATTR_DIRECTORY != ( SearchType & ATTR_DIRECTORY) )
         {
             return STATUS_FILE_TYPE_INVALID;
         }
@@ -220,7 +221,7 @@ FatSearch(
         return STATUS_SUCCESS;
     }
 
-    startIndexInName++;
+    startIndexInName++;   
 
     do
     {
@@ -243,7 +244,7 @@ FatSearch(
 
         if (partialNameLength >= sizeof(partialName) || partialNameLength == 0)
         {
-            LOG_TRACE_FILESYSTEM("[ERROR]Partial name length is %u\n", partialNameLength);
+            LOG_ERROR("Partial name length is %u\n", partialNameLength);
             return STATUS_PATH_NOT_VALID;
         }
 
@@ -257,7 +258,7 @@ FatSearch(
         if (!SUCCEEDED(status))
         {
             // something bad happened
-            LOG_TRACE_FILESYSTEM("[ERROR]SearchDirectoryEntry failed with status 0x%x\n", status);
+            LOG_FUNC_ERROR("SearchDirectoryEntry", status);
             return status;
         }
 
@@ -273,17 +274,17 @@ FatSearch(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 FatReadFile(
-    IN      PFAT_DATA   FatData,
+    IN      PFAT_DATA   FatData, 
     IN      QWORD       BaseFileSector,
     IN      QWORD       SectorOffset,
-    IN      QWORD       DirEntrySector,
     IN      PVOID       Buffer,
     IN      QWORD       SectorsToRead,
     OUT     QWORD*      SectorsRead,
     IN      BOOLEAN     Asynchronous
-)
+    )
 {
     STATUS status;
     QWORD currentSector;                // the sector in which the file is
@@ -293,12 +294,7 @@ FatReadFile(
     QWORD bytesToRead;
     PBYTE pData;
     QWORD sectorsTraversed;
-
-    DIR_ENTRY  dirEntry = { 0 };
-    QWORD dirEntryIndex = 0;
-    DATETIME currentDateTime = { 0 };
-    FATDATE fatDate = { 0 };
-    FATTIME fatTime = { 0 };
+    BOOLEAN firstIteration;
 
     LOG_FUNC_START;
 
@@ -306,7 +302,7 @@ FatReadFile(
     ASSERT(NULL != Buffer);
 
     ASSERT(IsAddressAligned(BaseFileSector, FatData->SectorsPerCluster));
-
+    
     status = STATUS_SUCCESS;
     currentSector = BaseFileSector;
     nextSector = 0;
@@ -314,22 +310,17 @@ FatReadFile(
     sectorsTraversed = 0;
     sectorsToRead = 0;
     bytesToRead = 0;
-    pData = (PBYTE)Buffer;
+    pData = (PBYTE) Buffer;
+    firstIteration = TRUE;
 
     LOG_TRACE_FILESYSTEM("Base file sector: [0x%x]\n", BaseFileSector);
     LOG_TRACE_FILESYSTEM("Sector offset: [0x%x]\n", SectorOffset);
 
-    if (0 == sectorsRemaining)
-    {
-        *SectorsRead = 0;
-        return STATUS_SUCCESS;
-    }
-
     while (sectorsTraversed + FatData->SectorsPerCluster <= SectorOffset)
     {
         ASSERT(SectorOffset >= FatData->SectorsPerCluster);
 
-        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, FALSE);
+        status = NextSectorInClusterChain(FatData, currentSector, &nextSector);
         if (!SUCCEEDED(status))
         {
             LOG_FUNC_ERROR("NextSectorInClusterChain", status);
@@ -343,235 +334,60 @@ FatReadFile(
 
     // we modify current sector to sectorToReach because
     // we do not need to read the whole cluster
-    currentSector = currentSector + (SectorOffset % FatData->SectorsPerCluster);
-
-    // it is possible that the first sector to read is in the middle of a cluster
-    sectorsToRead = min(sectorsRemaining, FatData->SectorsPerCluster - (SectorOffset % FatData->SectorsPerCluster));
-    bytesToRead = sectorsToRead * FatData->BytesPerSector;
+    currentSector = currentSector + ( SectorOffset % FatData->SectorsPerCluster );
 
-    for (;;)
+    while (0 != sectorsRemaining)
     {
-        LOG_TRACE_FILESYSTEM("Will read [0x%x] sectors starting from sector [0x%x]\n", sectorsToRead, currentSector);
-
-        status = IoReadDeviceEx(
-            FatData->VolumeDevice,
-            pData,
-            &bytesToRead,
-            currentSector * FatData->BytesPerSector,
-            Asynchronous
-        );
-        if (!SUCCEEDED(status))
+        if (!firstIteration)
         {
-            LOG_FUNC_ERROR("IoReadDeviceEx", status);
-            return status;
-        }
-        ASSERT(bytesToRead == sectorsToRead * FatData->BytesPerSector);
-
-        pData = pData + bytesToRead;
-
-        sectorsRemaining = sectorsRemaining - sectorsToRead;
-
-        if (0 == sectorsRemaining)
-        {
-            break;
-        }
+            // find next sector
+            status = NextSectorInClusterChain(FatData, currentSector, &nextSector);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+                return status;
+            }
 
-        // find next sector
-        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, FALSE);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("NextSectorInClusterChain", status);
-            return status;
-        }
+            currentSector = nextSector;
 
-        if (0 == nextSector)
-        {
-            // reached EOC marker
-            break;
+            if (0 == nextSector)
+            {
+                // reached EOC marker
+                *SectorsRead = (SectorsToRead - sectorsRemaining);
+                return STATUS_SUCCESS;
+            }
         }
 
-        currentSector = nextSector;
-
         sectorsToRead = min(FatData->SectorsPerCluster, sectorsRemaining);
         bytesToRead = sectorsToRead * FatData->BytesPerSector;
-    }
-
-    status = GetDirEntryFromSector(FatData, DirEntrySector, BaseFileSector, &dirEntryIndex, &dirEntry);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("GetDirEntryFromSector", status);
-        return status;
-    }
-
-    currentDateTime = IoGetCurrentDateTime();
-
-    ConvertDateTimeToFatDateTime(&currentDateTime, &fatDate, &fatTime);
-
-    dirEntry.DIR_LstAccDate = fatDate;
-
-    status = WriteDirEntryToSector(FatData, DirEntrySector, dirEntryIndex, &dirEntry);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("WriteDirEntryToSector", status);
-        return status;
-    }
-
-    *SectorsRead = SectorsToRead - sectorsRemaining;
-
-    return status;
-}
-
-STATUS
-FatWriteFile(
-    IN      PFAT_DATA   FatData,
-    IN      QWORD       BaseFileSector,
-    IN      QWORD       SectorOffset,
-    IN      QWORD       DirEntrySector,
-    IN      PVOID       Buffer,
-    IN      QWORD       SectorsToWrite,
-    OUT     QWORD*      SectorsWritten,
-    IN      BOOLEAN     Asynchronous
-)
-{
-    STATUS status;
-    QWORD currentSector;                // the sector in which the file is
-    QWORD nextSector;
-    QWORD sectorsRemaining;             // how much of the file we have parsed so far
-    QWORD sectorsToWrite;
-    QWORD bytesToWrite;
-    PBYTE pData;
-    QWORD sectorsTraversed;
-    DIR_ENTRY  dirEntry = { 0 };
-    QWORD dirEntryIndex = 0;
-    DATETIME currentDateTime = { 0 };
-    FATDATE fatDate = { 0 };
-    FATTIME fatTime = { 0 };
-    DWORD nextByteToWrite = 0;
-
-    LOG_FUNC_START;
-
-    ASSERT(NULL != FatData);
-    ASSERT(NULL != Buffer);
-
-    ASSERT(IsAddressAligned(BaseFileSector, FatData->SectorsPerCluster));
-
-    status = STATUS_SUCCESS;
-    currentSector = BaseFileSector;
-    nextSector = 0;
-    sectorsRemaining = SectorsToWrite;
-    sectorsTraversed = 0;
-    sectorsToWrite = 0;
-    bytesToWrite = 0;
-    pData = (PBYTE)Buffer;
-
-    LOG_TRACE_FILESYSTEM("Base file sector: [0x%x]\n", BaseFileSector);
-    LOG_TRACE_FILESYSTEM("Sector offset: [0x%x]\n", SectorOffset);
-
-    if (0 == sectorsRemaining)
-    {
-        *SectorsWritten = 0;
-        return STATUS_SUCCESS;
-    }
-
-    while (sectorsTraversed + FatData->SectorsPerCluster <= SectorOffset)
-    {
-        ASSERT(SectorOffset >= FatData->SectorsPerCluster);
-
-        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, TRUE);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("NextSectorInClusterChain", status);
-            return status;
-        }
-
-        currentSector = nextSector;
-        sectorsTraversed = sectorsTraversed + FatData->SectorsPerCluster;
-    }
-    ASSERT(0 != currentSector);
-
-    // we modify current sector to sectorToReach because
-    // we do not need to write to the whole cluster
-    currentSector = currentSector + (SectorOffset % FatData->SectorsPerCluster);
-
-    // it is possible that the first sector to write to is in the middle of a cluster
-    sectorsToWrite = min(sectorsRemaining, FatData->SectorsPerCluster - (SectorOffset % FatData->SectorsPerCluster));
-    bytesToWrite = sectorsToWrite * FatData->BytesPerSector;
 
-    for (;;)
-    {
-        LOG_TRACE_FILESYSTEM("Will write [0x%x] sectors starting from sector [0x%x]\n", sectorsToWrite, currentSector);
-
-        status = IoWriteDeviceEx(
-            FatData->VolumeDevice,
-            pData,
-            &bytesToWrite,
-            currentSector * FatData->BytesPerSector,
-            Asynchronous
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoWriteDeviceEx", status);
-            return status;
-        }
-        ASSERT(bytesToWrite == sectorsToWrite * FatData->BytesPerSector);
-
-        pData = pData + bytesToWrite;
-
-        sectorsRemaining = sectorsRemaining - sectorsToWrite;
-
-        if (0 == sectorsRemaining)
-        {
-            break;
-        }
+        LOG_TRACE_FILESYSTEM("Will read [0x%x] sectors starting from sector [0x%x]\n", sectorsToRead, currentSector);
 
-        // find next sector, extend chain if necessary
-        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, TRUE);
+        status = IoReadDeviceEx(FatData->VolumeDevice,
+                                pData,
+                                &bytesToRead,
+                                currentSector * FatData->BytesPerSector,
+                                Asynchronous
+                                );
         if (!SUCCEEDED(status))
         {
-            LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+            LOG_FUNC_ERROR("IoReadDeviceEx", status);
             return status;
         }
+        ASSERT(bytesToRead == sectorsToRead * FatData->BytesPerSector);
 
-        currentSector = nextSector;
-
-        sectorsToWrite = min(FatData->SectorsPerCluster, sectorsRemaining);
-        bytesToWrite = sectorsToWrite * FatData->BytesPerSector;
-    }
-
-    status = GetDirEntryFromSector(FatData, DirEntrySector, BaseFileSector, &dirEntryIndex, &dirEntry);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("GetDirEntryFromSector", status);
-        return status;
-    }
-
-    nextByteToWrite = (DWORD)(SectorOffset + SectorsToWrite) * FatData->BytesPerSector;
-
-    if (nextByteToWrite > dirEntry.DIR_FileSize)
-    {
-        dirEntry.DIR_FileSize = nextByteToWrite;
-    }
-
-    currentDateTime = IoGetCurrentDateTime();
-
-    ConvertDateTimeToFatDateTime(&currentDateTime, &fatDate, &fatTime);
-
-    dirEntry.DIR_LstAccDate = fatDate;
-    dirEntry.DIR_WrtDate = fatDate;
-    dirEntry.DIR_WrtTime = fatTime;
+        pData = pData + bytesToRead;
 
-    status = WriteDirEntryToSector(FatData, DirEntrySector, dirEntryIndex, &dirEntry);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("WriteDirEntryToSector", status);
-        return status;
+        sectorsRemaining = sectorsRemaining - sectorsToRead;
+        firstIteration = FALSE;
     }
 
-    *SectorsWritten = SectorsToWrite;
+    *SectorsRead = SectorsToRead;
 
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 FatSearchDirectoryEntry(
     IN      PFAT_DATA               FatData,
@@ -581,7 +397,7 @@ FatSearchDirectoryEntry(
     OUT     QWORD*                  SearchResult,
     OUT_OPT PFILE_INFORMATION       FileInformation,
     OUT     QWORD*                  ParentSector
-)
+    )
 {
     STATUS status;
     LONG_DIR_ENTRY* pLongEntry;
@@ -589,8 +405,7 @@ FatSearchDirectoryEntry(
     QWORD sectorToParse;
     int index;
     QWORD bytesToRead;
-    char normalizedShortName[SHORT_NAME_MAX_LENGTH] = { 0 };
-    char normalizedLongName[LONG_NAME_MAX_CHARS + 1] = { 0 };
+    char normalizedName[16];
     DWORD requiredLength;
 
     LOG_FUNC_START;
@@ -629,7 +444,7 @@ FatSearchDirectoryEntry(
                     pEntry = NULL;
 
                     // we go to the next sector we need to parse
-                    status = NextSectorInClusterChain(FatData, sectorToParse, &sectorToParse, FALSE);
+                    status = NextSectorInClusterChain(FatData, sectorToParse, &sectorToParse);
                     if (!SUCCEEDED(status))
                     {
                         // something bad happened :(
@@ -656,10 +471,10 @@ FatSearchDirectoryEntry(
                 }
 
                 status = IoReadDeviceEx(FatData->VolumeDevice,
-                    pEntry,
-                    &bytesToRead,
-                    sectorToParse * FatData->BytesPerSector,
-                    TRUE
+                                        pEntry,
+                                        &bytesToRead,
+                                        sectorToParse * FatData->BytesPerSector,
+                                        TRUE
                 );
                 if (!SUCCEEDED(status))
                 {
@@ -682,26 +497,20 @@ FatSearchDirectoryEntry(
 
             if ((pLongEntry->LDIR_Attr & ATTR_LONG_NAME_MASK) == ATTR_LONG_NAME)
             {
-                status = WritePartialLongFatNameToName(pLongEntry, LONG_NAME_MAX_CHARS + 1, normalizedLongName);
-                ASSERT(SUCCEEDED(status));
-
+                // we don't care for long directory entries ATM
+                // should be implemented in future versions
                 index++;
                 continue;
             }
 
-            // short directory entry
-
             LOG_TRACE_FILESYSTEM("[%d]: [%s][%x]\n", index, pEntry[index].DIR_Name, pEntry[index].DIR_Attr);
 
-            status = ConvertFatNameToName((char*)pEntry[index].DIR_Name, SHORT_NAME_MAX_LENGTH, normalizedShortName, &requiredLength);
+            status = ConvertFatNameToName((char*)pEntry[index].DIR_Name, 16, normalizedName, &requiredLength);
             ASSERT(SUCCEEDED(status));
 
+            LOG_TRACE_FILESYSTEM("Normalized: [%s]\n", normalizedName);
 
-            LOG_TRACE_FILESYSTEM("Normalized long  name: [%s]\n", normalizedLongName);
-            LOG_TRACE_FILESYSTEM("Normalized short name: [%s]\n", normalizedShortName);
-
-            if (0 == stricmp(normalizedLongName, Name) ||
-                0 == stricmp(normalizedShortName, Name))
+            if (0 == stricmp(normalizedName, Name))
             {
                 // we found what we were looking for
                 QWORD cluster;
@@ -738,16 +547,10 @@ FatSearchDirectoryEntry(
                 __leave;
             }
 
-            // reset long name
-            // in case the next short directory entry does not have associated long name entries
-            // it must not use the long name from a previous entry
-            normalizedLongName[0] = '\0';
-
-            // we increment the index to search the next directory entry
-
+            // we increment the index to search the next directory
+            // entry
             index++;
 
-
         } while (FREE_ALL != pEntry[index].DIR_Name[0]);
 
 
@@ -773,7 +576,7 @@ _FatPopulateFileInformationFromFatEntry(
     IN      PFAT_DATA               FatData,
     IN      PDIR_ENTRY              DirEntry,
     OUT     PFILE_INFORMATION       FileInformation
-)
+    )
 {
     STATUS status;
 
@@ -798,7 +601,7 @@ _FatPopulateFileInformationFromFatEntry(
     LOG_TRACE_FILESYSTEM("Attributes: [0x%x]\n", DirEntry->DIR_Attr);
 
     // the root entry has no creation or write datetime
-    if (FILE_ATTRIBUTE_VOLUME != FileInformation->FileAttributes)
+    if ( FILE_ATTRIBUTE_VOLUME != FileInformation->FileAttributes )
     {
         status = ConvertFatDateTimeToDateTime(&DirEntry->DIR_CrtDate, &DirEntry->DIR_CrtTime, &FileInformation->CreationTime);
         ASSERT(SUCCEEDED(status));
@@ -808,15 +611,16 @@ _FatPopulateFileInformationFromFatEntry(
     }
 }
 
+SAL_SUCCESS
 STATUS
 FatCreateDirectoryEntry(
-    IN      PFAT_DATA       FatData,
-    IN_Z    char*           Name,
+    IN      PFAT_DATA       FatData, 
+    IN_Z    char*           Name, 
     IN      BYTE            FileAttributes
-)
+    )
 {
-    char fullPath[MAX_PATH] = { 0 };
-    char newEntryName[SHORT_NAME_CHARS + 1];
+    char fullPath[MAX_PATH];
+    char newEntryName[SHORT_NAME_CHARS+1];
     char* pPathToBackSlash;
     DWORD lastBackslashIndex = 0;
     QWORD parentSector;
@@ -841,48 +645,37 @@ FatCreateDirectoryEntry(
     QWORD bytesToRead;
 
     LOG_FUNC_START;
-    // Step 0. Check pointers
+                                    // Step 0. Check pointers
     ASSERT(NULL != FatData);
     ASSERT(NULL != Name);
 
-    LOG_TRACE_FILESYSTEM("[ERROR]Will create file [%s]\n", Name);
+    LOG("Will create file [%s]\n", Name);
 
     memset(newEntryName, ' ', SHORT_NAME_CHARS);
 
     // fullPath contains the path until the new directory entry
-    pPathToBackSlash = (char*)strrchr(Name, FAT_DELIMITER);
+    pPathToBackSlash = (char*) strrchr(Name, FAT_DELIMITER);
     bytesToRead = 0;
 
-    if (Name == pPathToBackSlash && FAT_DELIMITER != Name[0])
+    if (Name == pPathToBackSlash)
     {
         // path is not specified correctly
-        LOG_TRACE_FILESYSTEM("'%c' not found in [%s]\n", FAT_DELIMITER, Name);
         return STATUS_PATH_NOT_VALID;
     }
 
-    lastBackslashIndex = (DWORD)(pPathToBackSlash - Name);
+    lastBackslashIndex = (DWORD) ( pPathToBackSlash - Name );
 
     // in fullPath we copy the parent directory path
-    if (0 == lastBackslashIndex)
-    {
-        strcpy(fullPath, "\\"); // parent directory is root
-    }
-    else
-    {
-        strncpy(fullPath, Name, lastBackslashIndex);
-    }
+    strncpy(fullPath, Name, lastBackslashIndex);
 
     // newEntryName contains only the name of the to be created entry
     strcpy(newEntryName, (Name + lastBackslashIndex + 1));
 
-    LOG_TRACE_FILESYSTEM("Directory: [%s]\n", fullPath);
-    LOG_TRACE_FILESYSTEM("Filename: [%s]\n", newEntryName);
-
     // we don't want a NULL terminated string
     newEntryName[strlen(newEntryName)] = ' ';
 
     // Step 1. Check if to be parent directory exists
-    status = FatSearch(FatData, fullPath, &parentSector, ATTR_DIRECTORY, NULL, &parentDirEntrySector);
+    status = FatSearch(FatData, fullPath, &parentSector, ATTR_DIRECTORY, NULL,&parentDirEntrySector);
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("FatSearch", status);
@@ -890,14 +683,14 @@ FatCreateDirectoryEntry(
     }
 
     // Step 2. Check if there is already a file with the same name
-    status = FatSearch(FatData, Name, &dummySector, ATTR_NORMAL, NULL, &parentDirEntrySector);
+    status = FatSearch(FatData, Name, &dummySector, ATTR_NORMAL, NULL,&parentDirEntrySector);
     if (SUCCEEDED(status) || (STATUS_FILE_TYPE_INVALID == status))
     {
         return STATUS_FILE_ALREADY_EXISTS;
     }
 
     // Step 3. Go to the EOC cluster of the parent directory entry
-    /// TODO check if there is enough space before the end cluster
+
     // we find the cluster of the parent
     status = ClusterOfSector(FatData, parentSector, &currentClusterInChain);
     if (!SUCCEEDED(status))
@@ -910,7 +703,7 @@ FatCreateDirectoryEntry(
 
     // this loop will place in currentClusterInChain the last cluster belonging
     // to the parent directory
-    while (!FAT32_EOC(tempCluster))
+    while (FAT32_BAD_CLUSTER > (tempCluster & FAT32_CLUSTER_MASK))
     {
         currentClusterInChain = tempCluster;
 
@@ -933,7 +726,7 @@ FatCreateDirectoryEntry(
     // we allocate space for the last cluster
     bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
 
-    pEntry = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+    pEntry = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD) bytesToRead, HEAP_TEMP_TAG, 0);
     if (NULL == pEntry)
     {
         status = STATUS_HEAP_NO_MORE_MEMORY;
@@ -944,10 +737,10 @@ FatCreateDirectoryEntry(
     __try
     {
         status = IoReadDeviceEx(FatData->VolumeDevice,
-            pEntry,
-            &bytesToRead,
-            finalSector * FatData->BytesPerSector,
-            TRUE
+                                pEntry,
+                                &bytesToRead,
+                                finalSector * FatData->BytesPerSector,
+                                TRUE
         );
         if (!SUCCEEDED(status))
         {
@@ -964,13 +757,10 @@ FatCreateDirectoryEntry(
         }
 
         // Step 4. Is there space in the current cluster?
-        /// TODO check for enough space for long dir entries
         found = FALSE;
         while (index < (FatData->EntriesPerSector * FatData->SectorsPerCluster))
         {
-            if ((FREE_ENTRY == pEntry[index].DIR_Name[0]) ||
-                (FREE_ALL == pEntry[index].DIR_Name[0]) ||
-                (FREE_JAP_ENTRY == pEntry[index].DIR_Name[0]))
+            if ((FREE_ENTRY == pEntry[index].DIR_Name[0]) || (FREE_ALL == pEntry[index].DIR_Name[0]) || (FREE_JAP_ENTRY == pEntry[index].DIR_Name[0]))
             {
                 // we found a place where we can place our new entry
                 found = TRUE;
@@ -1025,9 +815,9 @@ FatCreateDirectoryEntry(
             }
 
             status = IoReadDevice(FatData->VolumeDevice,
-                pFSinfo,
-                &bytesToRead,
-                1 * FatData->BytesPerSector
+                                  pFSinfo,
+                                  &bytesToRead,
+                                  1 * FatData->BytesPerSector
             );
             if (!SUCCEEDED(status))
             {
@@ -1057,7 +847,15 @@ FatCreateDirectoryEntry(
 
         // set the new file attributes
         pEntry[index].DIR_Attr = FileAttributes;
-        pEntry[index].DIR_FileSize = 0; // redundant because of MemSet to 0
+
+        if (ATTR_DIRECTORY == (FileAttributes & (ATTR_DIRECTORY | ATTR_VOLUME_ID)))
+        {
+            pEntry[index].DIR_FileSize = 0; // redundant because of MemSet to 0
+        }
+        else
+        {
+            pEntry[index].DIR_FileSize = 0;
+        }
 
         // get current date time
         crtDateTime = IoGetCurrentDateTime();
@@ -1087,9 +885,9 @@ FatCreateDirectoryEntry(
         // we write the changes made to pFSinfo and to the parent cluster of the new entry
         bytesToRead = FatData->BytesPerSector;
         status = IoWriteDevice(FatData->VolumeDevice,
-            pFSinfo,
-            &bytesToRead,
-            1 * FatData->BytesPerSector
+                               pFSinfo,
+                               &bytesToRead,
+                               1 * FatData->BytesPerSector
         );
         if (!SUCCEEDED(status))
         {
@@ -1100,9 +898,9 @@ FatCreateDirectoryEntry(
 
         bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
         status = IoWriteDevice(FatData->VolumeDevice,
-            pEntry,
-            &bytesToRead,
-            finalSector * FatData->BytesPerSector
+                               pEntry,
+                               &bytesToRead,
+                               finalSector * FatData->BytesPerSector
         );
         if (!SUCCEEDED(status))
         {
@@ -1183,9 +981,9 @@ FatCreateDirectoryEntry(
         }
 
         status = IoWriteDevice(FatData->VolumeDevice,
-            pEntry,
-            &bytesToRead,
-            sectorAllocated * FatData->BytesPerSector
+                               pEntry,
+                               &bytesToRead,
+                               sectorAllocated * FatData->BytesPerSector
         );
         if (!SUCCEEDED(status))
         {
@@ -1212,9 +1010,9 @@ FatCreateDirectoryEntry(
 
 
         status = IoReadDevice(FatData->VolumeDevice,
-            pFAT,
-            &bytesToRead,
-            fatEntrySector * FatData->BytesPerSector
+                              pFAT,
+                              &bytesToRead,
+                              fatEntrySector * FatData->BytesPerSector
         );
         if (!SUCCEEDED(status))
         {
@@ -1229,9 +1027,9 @@ FatCreateDirectoryEntry(
 
 
         status = IoWriteDevice(FatData->VolumeDevice,
-            pFAT,
-            &bytesToRead,
-            fatEntrySector * FatData->BytesPerSector
+                               pFAT,
+                               &bytesToRead,
+                               fatEntrySector * FatData->BytesPerSector
         );
         if (!SUCCEEDED(status))
         {
@@ -1266,16 +1064,15 @@ FatCreateDirectoryEntry(
     return status;
 }
 
-// warning C6101: Returning uninitialized memory '*DirectoryInformation'.  A successful path through the function does not set the named _Out_ parameter. 
-
+SAL_SUCCESS
 STATUS
 FatQueryDirectory(
     IN                                              PFAT_DATA                       FatData,
     IN                                              QWORD                           DirectorySector,
     IN                                              DWORD                           DirectoryInformationSize,
-    OUT_WRITES_BYTES(DirectoryInformationSize)      FILE_DIRECTORY_INFORMATION      *DirectoryInformation,
+    OUT_WRITES_BYTES(DirectoryInformationSize)      PFILE_DIRECTORY_INFORMATION     DirectoryInformation,
     OUT                                             DWORD*                          RequiredDirectionInformationSize
-)
+    )
 {
     STATUS status;
     LONG_DIR_ENTRY* pLongEntry;
@@ -1287,12 +1084,6 @@ FatQueryDirectory(
     PFILE_DIRECTORY_INFORMATION pCurEntry;
     PFILE_DIRECTORY_INFORMATION pPrevEntry;
 
-    char longName[LONG_NAME_MAX_CHARS + 1] = { 0 };
-    DWORD longNameLength;
-    char shortName[SHORT_NAME_MAX_LENGTH] = { 0 };
-    DWORD shortNameLength;
-    DWORD curStructureSize;
-
     ASSERT(NULL != FatData);
     ASSERT(NULL != DirectoryInformation || 0 == DirectoryInformationSize);
     ASSERT(NULL != RequiredDirectionInformationSize);
@@ -1307,9 +1098,6 @@ FatQueryDirectory(
     pCurEntry = DirectoryInformation;
     pPrevEntry = NULL;
 
-    longNameLength = 0;
-    shortNameLength = 0;
-
     __try
     {
         do
@@ -1324,7 +1112,7 @@ FatQueryDirectory(
                     pEntry = NULL;
 
                     // we go to the next sector by following the cluster chain
-                    status = NextSectorInClusterChain(FatData, sectorToParse, &sectorToParse, FALSE);
+                    status = NextSectorInClusterChain(FatData, sectorToParse, &sectorToParse);
                     if (!SUCCEEDED(status))
                     {
                         LOG_FUNC_ERROR("NextSectorInClusterChain", status);
@@ -1351,10 +1139,10 @@ FatQueryDirectory(
 
                 // we read the next cluster
                 status = IoReadDeviceEx(FatData->VolumeDevice,
-                    pEntry,
-                    &bytesToRead,
-                    sectorToParse * FatData->BytesPerSector,
-                    TRUE
+                                        pEntry,
+                                        &bytesToRead,
+                                        sectorToParse * FatData->BytesPerSector,
+                                        TRUE
                 );
                 if (!SUCCEEDED(status))
                 {
@@ -1378,69 +1166,58 @@ FatQueryDirectory(
 
             pLongEntry = (LONG_DIR_ENTRY*)&(pEntry[index]);
 
+
             if ((pLongEntry->LDIR_Attr & ATTR_LONG_NAME_MASK) == ATTR_LONG_NAME)
             {
-                status = WritePartialLongFatNameToName(pLongEntry, LONG_NAME_MAX_CHARS + 1, longName);
-                ASSERT(SUCCEEDED(status));
+                // ATM do nothing with long entries
 
+                // handling needs to be implemented
                 index++;
                 continue;
             }
-
-            // short directory entry
-
-            status = ConvertFatNameToName((char*)pEntry[index].DIR_Name, SHORT_NAME_MAX_LENGTH, shortName, &shortNameLength);
-            ASSERT(SUCCEEDED(status));
-
-            longNameLength = strlen_s(longName, LONG_NAME_MAX_CHARS);
-            if (0 == longNameLength)
+            else
             {
-                longNameLength = shortNameLength;
-                strncpy(longName, shortName, shortNameLength);
-            }
+                // found a short directory entry
+                char name[16];
+                DWORD nameLength;
+                DWORD curStructureSize;
 
-            curStructureSize = sizeof(FILE_DIRECTORY_INFORMATION) + longNameLength;
+                status = ConvertFatNameToName((char*)pEntry[index].DIR_Name, 16, name, &nameLength);
+                ASSERT(SUCCEEDED(status));
 
-            requiredSize = requiredSize + curStructureSize;
+                curStructureSize = sizeof(FILE_DIRECTORY_INFORMATION) + nameLength;
 
-            if (requiredSize <= DirectoryInformationSize)
-            {
-                if (NULL != pPrevEntry)
-                {
-                    // update previous entry offset
-                    pPrevEntry->NextEntryOffset = (DWORD)((PBYTE)pCurEntry - (PBYTE)pPrevEntry);
-                }
+                requiredSize = requiredSize + curStructureSize;
 
-                LOG_TRACE_FILESYSTEM("[%d]: [%s][%x]\n", index, pEntry[index].DIR_Name, pEntry[index].DIR_Attr);
-                LOG_TRACE_FILESYSTEM("File short name: [%s]\n", shortName);
-                LOG_TRACE_FILESYSTEM("File long  name: [%s]\n", longName);
+                if (requiredSize <= DirectoryInformationSize)
+                {
+                    if (NULL != pPrevEntry)
+                    {
+                        // update previous entry offset
+                        pPrevEntry->NextEntryOffset = (DWORD)((PBYTE)pCurEntry - (PBYTE)pPrevEntry);
+                    }
 
-                // populate current entry
+                    LOG_TRACE_FILESYSTEM("[%d]: [%s][%x]\n", index, pEntry[index].DIR_Name, pEntry[index].DIR_Attr);
+                    LOG_TRACE_FILESYSTEM("File name: [%s]\n", name);
 
-                // we set offset to 0 because we don't know if there are any entries
-                // after us
-                pCurEntry->NextEntryOffset = 0;
+                    // populate current entry
 
-                _FatPopulateFileInformationFromFatEntry(FatData, &pEntry[index], &pCurEntry->BasicFileInformation);
-                memcpy(pCurEntry->ShortFilename, shortName, shortNameLength);
+                    // we set offset to 0 because we don't know if there are any entries
+                    // after us
+                    pCurEntry->NextEntryOffset = 0;
 
-                pCurEntry->FilenameLength = longNameLength;
-                memcpy(pCurEntry->Filename, longName, longNameLength);
+                    _FatPopulateFileInformationFromFatEntry(FatData, &pEntry[index], &pCurEntry->BasicFileInformation);
+                    pCurEntry->FilenameLength = nameLength;
+                    memcpy(pCurEntry->Filename, name, nameLength);
 
-                // update previous and current entry
-                pPrevEntry = pCurEntry;
-                pCurEntry = (PFILE_DIRECTORY_INFORMATION)((PBYTE)pCurEntry + curStructureSize);
+                    // update previous and current entry
+                    pPrevEntry = pCurEntry;
+                    pCurEntry = (PFILE_DIRECTORY_INFORMATION)((PBYTE)pCurEntry + curStructureSize);
+                }
             }
 
-            // reset long name
-            // in case the next short directory entry does not have associated long name entries
-            // it must not use the long name from a previous entry
-            longName[0] = '\0';
-
-
             // we increase the index in the entry array
             index++;
-
         } while (FREE_ALL != pEntry[index].DIR_Name[0]);
     }
     __finally
@@ -1455,4 +1232,4 @@ FatQueryDirectory(
     }
 
     return status;
-}
+}
\ No newline at end of file
diff --git a/src/FAT32/src/fat_utils.c b/src/FAT32/src/fat_utils.c
index 760485b..f8449e5 100644
--- a/src/FAT32/src/fat_utils.c
+++ b/src/FAT32/src/fat_utils.c
@@ -3,6 +3,7 @@
 #include "fat_utils.h"
 
 static
+SAL_SUCCESS
 STATUS
 _ConvertFatDateToDate(
     IN      FATDATE*    FatDate,
@@ -10,6 +11,7 @@ _ConvertFatDateToDate(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _ConvertFatTimeToTime(
     IN      FATTIME*    FatTime,
@@ -30,20 +32,12 @@ _ConvertTimeToFatTime(
     OUT     FATTIME*    FatTime
     );
 
-static
-STATUS
-_AddNewClusterToChain(
-    IN      PFAT_DATA       FatData,
-    IN      QWORD           LastClusterFromChain,
-    OUT     QWORD*          ReservedCluster
-);
-
+SAL_SUCCESS
 STATUS
 NextSectorInClusterChain(
     IN      PFAT_DATA       FatData,
     IN      QWORD           CurrentSector,
-    OUT     QWORD*          NextSector,
-    IN      BOOLEAN         ExtendChain
+    OUT     QWORD*          NextSector
     )
 {
     STATUS status;
@@ -73,24 +67,16 @@ NextSectorInClusterChain(
         return status;
     }
 
-    // we check if we reached the end of chain
-    if (FAT32_EOC(nextCluster))
+    nextCluster = nextCluster & FAT32_CLUSTER_MASK;
+
+    // we check to see if it's a valid cluster
+    if ((nextCluster >= FAT32_BAD_CLUSTER) || (0 == nextCluster))
     {
-        if (!ExtendChain)
-        {
         // arrived to the end of the cluster chain
         *NextSector = 0;
         return status;
     }
 
-        status = _AddNewClusterToChain(FatData, currentCluster, &nextCluster);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("AddNewClusterToChain", status);
-            return status;
-        }
-    }
-
     // we get the sector belonging to the found cluster
     status = FirstSectorOfCluster(FatData, nextCluster, NextSector);
     if (!SUCCEEDED(status))
@@ -102,6 +88,7 @@ NextSectorInClusterChain(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 NextClusterInChain(
     IN      PFAT_DATA       FatData,
@@ -110,412 +97,56 @@ NextClusterInChain(
     )
 {
     STATUS status;
-    FAT32_ENTRY* pFat32Entries;        // pointer to a FAT table
+    BYTE* pFat32Entries;        // pointer to a FAT table
     QWORD sectorNumber;
-    QWORD indexInSector;
-    QWORD bytesToReadWrite;
+    QWORD offsetInSector;
+    QWORD bytesToRead;
     QWORD offset;
-    QWORD nextCluster;
 
     ASSERT(NULL != FatData);
     ASSERT(NULL != NextCluster);
 
-    status = STATUS_UNSUCCESSFUL;
+    status = STATUS_SUCCESS;
     pFat32Entries = NULL;
-    nextCluster = 0;
 
-    sectorNumber = FatData->ReservedSectors + (CurrentCluster * (sizeof(FAT32_ENTRY)) / FatData->BytesPerSector);
-    indexInSector = CurrentCluster % (FatData->BytesPerSector / sizeof(FAT32_ENTRY));
-    bytesToReadWrite = FatData->BytesPerSector;
+    // each FAT32 entry occupies a DWORD
+    sectorNumber = FatData->ReservedSectors + ((sizeof(DWORD) * CurrentCluster) / FatData->BytesPerSector);
+    offsetInSector = (sizeof(DWORD) * CurrentCluster) % FatData->BytesPerSector;
+    bytesToRead = FatData->BytesPerSector;
     offset = sectorNumber * FatData->BytesPerSector;
 
-    __try
-    {
-        pFat32Entries = (FAT32_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, FatData->BytesPerSector, HEAP_TEMP_TAG, 0);
+    pFat32Entries = (PBYTE) ExAllocatePoolWithTag(PoolAllocateZeroMemory, FatData->BytesPerSector, HEAP_TEMP_TAG, 0 );
     if (NULL == pFat32Entries)
     {
-            status = STATUS_HEAP_NO_MORE_MEMORY;
         // could not allocate memory for a FAT32 sector
-            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", FatData->BytesPerSector);
-            __leave;
+        LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", FatData->BytesPerSector);
+        return STATUS_HEAP_NO_MORE_MEMORY;
     }
 
     // We read the sector
-        status = IoReadDevice(
-            FatData->VolumeDevice,
+    status = IoReadDevice(FatData->VolumeDevice,
                           pFat32Entries,
-            &bytesToReadWrite,
+                          &bytesToRead,
                           offset
                           );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("IoReadDevice", status);
-            __leave;
-        }
-        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-
-        nextCluster = pFat32Entries[indexInSector] & FAT32_CLUSTER_MASK;
-
-        if (0 == nextCluster)
-        {
-            LOG_TRACE_FILESYSTEM("Found zero in cluster chain");
-            // has to be treated as EOC marker
-            nextCluster = FAT32_EOC_MARK;
-
-            // write EOC marker back to disk, such that the cluster is not treated as a free one
-            pFat32Entries[indexInSector] &= ~FAT32_CLUSTER_MASK;    // we need to preserve the 4 reserved bits
-            pFat32Entries[indexInSector] |= FAT32_EOC_MARK;            // we add the EOC mark
-
-            status = IoWriteDevice(
-                FatData->VolumeDevice,
-                pFat32Entries,
-                &bytesToReadWrite,
-                offset
-            );
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("IoWriteDevice", status);
-                __leave;
-            }
-            ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-        }
-        else if (FAT32_BAD_CLUSTER == nextCluster)
-        {
-            // maybe we should cut off the cluster chain, so it doesn't reach the bad cluster
-            nextCluster = FAT32_EOC_MARK;
-        }
-
-        status = STATUS_SUCCESS;
-    }
-    __finally
-    {
-        *NextCluster = nextCluster;
-
-        // We free the memory allocated
-        if (NULL != pFat32Entries)
-        {
-            ExFreePoolWithTag(pFat32Entries, HEAP_TEMP_TAG);
-            pFat32Entries = NULL;
-        }
-    }
-
         return status;
     }
+    ASSERT(bytesToRead == FatData->BytesPerSector);
 
-static
-STATUS
-_FirstFreeCluster(
-    IN      PFAT_DATA       FatData,
-    IN      QWORD           FirstCheckedCluster,
-    IN      BOOLEAN         MarkReserved,
-    OUT     QWORD*          FreeCluster
-)
-{
-    STATUS status = STATUS_UNSUCCESSFUL;
-    FAT32_ENTRY* pFat32Entries = NULL;        // pointer to a FAT table
-    QWORD firstCheckedCluster = FirstCheckedCluster;
-    QWORD entriesPerFat = 0;
-    QWORD sectorsPerFat = 0;
-    QWORD firstFatSector = 0;
-    QWORD currentSector = 0;
-    QWORD bytesToReadWrite = 0;
-    QWORD indexInSector = 0;
-    QWORD clusterIndex = 0;
-
-    __try
-    {
-        pFat32Entries = (FAT32_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, FatData->BytesPerSector, HEAP_TEMP_TAG, 0);
-        if (NULL == pFat32Entries)
-        {
-            status = STATUS_HEAP_NO_MORE_MEMORY;
-            // could not allocate memory for a FAT32 sector
-            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", FatData->BytesPerSector);
-            __leave;
-        }
-
-        bytesToReadWrite = FatData->BytesPerSector; // read the FAT sector by sector
-
-        firstFatSector = FatData->ReservedSectors;
-        entriesPerFat = FatData->CountOfClusters + 2;
-        sectorsPerFat = entriesPerFat * sizeof(FAT32_ENTRY) / FatData->BytesPerSector;
-
-        // if search should begin after the last cluster
-        if (entriesPerFat <= firstCheckedCluster)
-        {
-            status = STATUS_SUCCESS;
-            __leave;
-        }
-
-        if (FAT32_UNKNOWN == firstCheckedCluster)
-        {
-            firstCheckedCluster = 2;
-        }
-
-        currentSector = firstFatSector + (firstCheckedCluster * sizeof(FAT32_ENTRY) / FatData->BytesPerSector);
-        indexInSector = firstCheckedCluster % (FatData->BytesPerSector / sizeof(FAT32_ENTRY));
-        // for each sector of the FAT
-        for (; currentSector < sectorsPerFat; currentSector++)
-        {
-            // We read the sector
-            status = IoReadDevice(
-                FatData->VolumeDevice,
-                pFat32Entries,
-                &bytesToReadWrite,
-                currentSector * FatData->BytesPerSector
-            );
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("IoReadDevice", status);
-                __leave;
-            }
-            ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-
-            // check all the entries in the current sector of the FAT
-            for (; indexInSector < FatData->BytesPerSector / sizeof(FAT32_ENTRY); indexInSector++)
-            {
-                if (0 == (pFat32Entries[indexInSector] & FAT32_CLUSTER_MASK)) // found free cluster
-                {
-                    if (MarkReserved)
-                    {
-                        // write EOC marker back to disk, such that the cluster is reserved
-                        pFat32Entries[indexInSector] &= ~FAT32_CLUSTER_MASK;    // we need to preserve the 4 reserved bits
-                        pFat32Entries[indexInSector] |= FAT32_EOC_MARK;         // we add the EOC mark
-
-                        status = IoWriteDevice(
-                            FatData->VolumeDevice,
-                            pFat32Entries,
-                            &bytesToReadWrite,
-                            currentSector * FatData->BytesPerSector
-                        );
-                        if (!SUCCEEDED(status))
-                        {
-                            LOG_FUNC_ERROR("IoWriteDevice", status);
-                            __leave;
-                        }
-                        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-                    }
-
-                    // clusterIndex = Index of sector inside FAT * Nr of FAT entryies per sector + FAT entry index in current sector
-                    clusterIndex = (currentSector - firstFatSector) * (FatData->BytesPerSector / sizeof(FAT32_ENTRY)) + indexInSector;
-
-                    ASSERT(2 <= clusterIndex && clusterIndex < entriesPerFat);
-                    ASSERT(FAT32_UNKNOWN != clusterIndex);
-
-                    currentSector = sectorsPerFat; // break outer for loop
-                    break;
-                }
-            }
-            // reset entry index
-            indexInSector = 0;
-        }
-    }
-    __finally
-    {
-        *FreeCluster = clusterIndex;
+    // We get the value from SectorOffset
+    *NextCluster = *((DWORD*)(&pFat32Entries[offsetInSector]));
 
     // We free the memory allocated
-        if (NULL != pFat32Entries)
-        {
+    ASSERT(NULL != pFat32Entries);
     ExFreePoolWithTag(pFat32Entries, HEAP_TEMP_TAG);
-            pFat32Entries = NULL;
-        }
-    }
-
-    return status;
-}
-
-static
-STATUS
-_AddNewClusterToChain(
-    IN      PFAT_DATA       FatData,
-    IN      QWORD           LastClusterFromChain,
-    OUT     QWORD*          ReservedCluster
-)
-{
-    ASSERT(FatData != NULL);
-    ASSERT(ReservedCluster != NULL);
-
-    ASSERT(!FAT32_EOC(LastClusterFromChain));
-
-    STATUS status = STATUS_UNSUCCESSFUL;
-    FSINFO* pFsInfo = NULL;            // pointer to FSInfo
-    FAT32_ENTRY* pFat32Entries = NULL;        // pointer to a FAT table
-    QWORD bytesToReadWrite = 0;
-    QWORD freeCluster = 0;
-    QWORD reservedCluster = 0;
-    QWORD sectorFromFat = 0;
-    QWORD indexInSector = 0;
-
-    __try
-    {
-        pFsInfo = (FSINFO*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(FSINFO), HEAP_TEMP_TAG, 0);
-        if (NULL == pFsInfo)
-        {
-            status = STATUS_HEAP_NO_MORE_MEMORY;
-            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(FSINFO));
-            __leave;
-        }
-
-        bytesToReadWrite = sizeof(FSINFO);
-        status = IoReadDevice(
-            FatData->VolumeDevice,
-            pFsInfo,
-            &bytesToReadWrite,
-            1 * FatData->BytesPerSector
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoReadDevice", status);
-            __leave;
-        }
-        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-
-        // if there are no more free clusters we fail
-        if (0 == pFsInfo->FSI_Free_Count)
-        {
-            pFsInfo->FSI_Nxt_Free = FAT32_UNKNOWN;
-
-            status = STATUS_DISK_FULL;
-            __leave;
-        }
-
-        status = _FirstFreeCluster(FatData, pFsInfo->FSI_Nxt_Free, TRUE, &reservedCluster);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("FirstFreeCluster", status);
-            __leave;
-        }
-
-        if (0 == reservedCluster) // no free cluster found
-        {
-            // FSI_Free_Count was not zero, but there was no free cluster
-            ASSERT(FAT32_UNKNOWN == pFsInfo->FSI_Free_Count);
-
-            pFsInfo->FSI_Free_Count = 0;
-            pFsInfo->FSI_Nxt_Free = FAT32_UNKNOWN;
-
-            status = STATUS_DISK_FULL;
-            __leave;
-        }
-
-        // a free cluster was reserved
-        // write it to the end of the cluster chain
-        pFat32Entries = (FAT32_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, FatData->BytesPerSector, HEAP_TEMP_TAG, 0);
-        if (NULL == pFat32Entries)
-        {
-            status = STATUS_HEAP_NO_MORE_MEMORY;
-            // could not allocate memory for a FAT32 sector
-            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", FatData->BytesPerSector);
-            __leave;
-        }
-
-        sectorFromFat = FatData->ReservedSectors + (LastClusterFromChain * sizeof(FAT32_ENTRY) / FatData->BytesPerSector);
-        indexInSector = LastClusterFromChain % (FatData->BytesPerSector / sizeof(FAT32_ENTRY));
-
-        bytesToReadWrite = FatData->BytesPerSector;
-        // We read the sector
-        status = IoReadDevice(
-            FatData->VolumeDevice,
-            pFat32Entries,
-            &bytesToReadWrite,
-            sectorFromFat * FatData->BytesPerSector
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoReadDevice", status);
-            __leave;
-        }
-        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-
-        pFat32Entries[indexInSector] &= ~FAT32_CLUSTER_MASK;    // we need to preserve the 4 reserved bits
-        pFat32Entries[indexInSector] |= (DWORD)reservedCluster;
-
-        status = IoWriteDevice(
-            FatData->VolumeDevice,
-            pFat32Entries,
-            &bytesToReadWrite,
-            sectorFromFat * FatData->BytesPerSector
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoWriteDevice", status);
-            __leave;
-        }
-        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-
-        // Update the FSI_Nxt_Free and FSI_Free_Count
-
-        // fatgen103.pdf:
-        // Typically this value is set to the last cluster number that the driver allocated.
-        pFsInfo->FSI_Nxt_Free = (DWORD)reservedCluster;
-
-        if (FAT32_UNKNOWN == pFsInfo->FSI_Free_Count)
-        {
-            // calculate remaining free clusters
-            pFsInfo->FSI_Free_Count = 0;
-
-            freeCluster = reservedCluster;
-
-            for(;;)
-            {
-                status = _FirstFreeCluster(FatData, freeCluster + 1, FALSE, &freeCluster);
-                if (!SUCCEEDED(status))
-                {
-                    LOG_FUNC_ERROR("FirstFreeCluster", status);
-                    __leave;
-                }
-
-                if (0 == freeCluster)
-                {
-                    break;
-                }
-
-                pFsInfo->FSI_Free_Count++;
-            }
-        }
-        else // FSI_Free_Count != FAT32_UNKNOWN or 0
-        {
-            pFsInfo->FSI_Free_Count--;
-        }
-
-    }
-    __finally
-    {
-        *ReservedCluster = reservedCluster;
-
-        // Write the FsInfo back to the disk
-        // (placed here in case of __leave when disk is full)
-        bytesToReadWrite = sizeof(FSINFO);
-        status = IoWriteDevice(
-            FatData->VolumeDevice,
-            pFsInfo,
-            &bytesToReadWrite,
-            1 * FatData->BytesPerSector
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoWriteDevice", status);
-        }
-        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
-
-        // We free the memory allocated
-        if (NULL != pFsInfo)
-        {
-            ExFreePoolWithTag(pFsInfo, HEAP_TEMP_TAG);
-            pFsInfo = NULL;
-        }
 
-        // We free the memory allocated
-        if (NULL != pFat32Entries)
-        {
-            ExFreePoolWithTag(pFat32Entries, HEAP_TEMP_TAG);
-            pFat32Entries = NULL;
-        }
-    }
-
-    return status;
+    return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 FirstSectorOfCluster(
     IN      PFAT_DATA   FatData,
@@ -542,10 +173,11 @@ FirstSectorOfCluster(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 ClusterOfSector(
     IN      PFAT_DATA   FatData,
-    IN      QWORD       Sector,
+    IN      QWORD       Sector, 
     OUT     QWORD*      Cluster
     )
 {
@@ -567,162 +199,7 @@ ClusterOfSector(
     return STATUS_SUCCESS;
 }
 
-STATUS
-GetDirEntryFromSector(
-    IN      PFAT_DATA   FatData,
-    IN      QWORD       EntrySector,
-    IN      QWORD       DirFirstSector, // search criterion
-    OUT     QWORD*      EntryIndex,
-    OUT     DIR_ENTRY*  DirEntry
-)
-{
-    STATUS status = STATUS_UNSUCCESSFUL;
-    LONG_DIR_ENTRY* pLongEntry = NULL;
-    DIR_ENTRY* pDirEntryArray = NULL;
-    QWORD index = 0;
-    QWORD bytesToRead = 0;
-    QWORD dirFstClusterToSearch = 0;
-
-    __try
-    {
-        bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
-
-        pDirEntryArray = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
-        if (NULL == pDirEntryArray)
-        {
-            status = STATUS_HEAP_NO_MORE_MEMORY;
-            // malloc failed
-            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
-            __leave;
-        }
-
-        status = IoReadDevice(FatData->VolumeDevice,
-            pDirEntryArray,
-            &bytesToRead,
-            EntrySector * FatData->BytesPerSector
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoReadDevice", status);
-            __leave;
-        }
-        ASSERT(bytesToRead == FatData->BytesPerSector * FatData->SectorsPerCluster);
-
-        status = ClusterOfSector(FatData, DirFirstSector, &dirFstClusterToSearch);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("ClusterOfSector", status);
-            __leave;
-        }
-
-        for (index = 0; index < bytesToRead / sizeof(DIR_ENTRY); index++)
-        {
-            if ((FREE_ENTRY == pDirEntryArray[index].DIR_Name[0]) ||
-                (FREE_JAP_ENTRY == pDirEntryArray[index].DIR_Name[0]))
-            {
-                // this entry is empty
-                continue;
-            }
-
-            pLongEntry = (LONG_DIR_ENTRY*)&(pDirEntryArray[index]);
-
-            if ((pLongEntry->LDIR_Attr & ATTR_LONG_NAME_MASK) == ATTR_LONG_NAME)
-            {
-                // might be used in the future
-
-                continue;
-            }
-
-            if (dirFstClusterToSearch == WORDS_TO_DWORD(pDirEntryArray[index].DIR_FstClusHI, pDirEntryArray[index].DIR_FstClusLO))
-            {
-                memcpy(DirEntry, &pDirEntryArray[index], sizeof(DIR_ENTRY));
-                *EntryIndex = index;
-
-                status = STATUS_SUCCESS;
-                __leave;
-            }
-        }
-
-        *EntryIndex = MAX_DWORD;
-        status = STATUS_ELEMENT_NOT_FOUND;
-    }
-    __finally
-    {
-        if (NULL != pDirEntryArray)
-        {
-            ExFreePoolWithTag(pDirEntryArray, HEAP_TEMP_TAG);
-            pDirEntryArray = NULL;
-        }
-    }
-
-    return status;
-}
-
-STATUS
-WriteDirEntryToSector(
-    IN      PFAT_DATA   FatData,
-    IN      QWORD       EntrySector,
-    IN      QWORD       EntryIndex,
-    IN      DIR_ENTRY*  DirEntry
-)
-{
-    STATUS status = STATUS_UNSUCCESSFUL;
-    DIR_ENTRY* pDirEntryArray = NULL;
-    QWORD bytesToReadWrite = 0;
-
-    __try
-    {
-        bytesToReadWrite = FatData->BytesPerSector * FatData->SectorsPerCluster;
-
-        pDirEntryArray = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToReadWrite, HEAP_TEMP_TAG, 0);
-        if (NULL == pDirEntryArray)
-        {
-            status = STATUS_HEAP_NO_MORE_MEMORY;
-            // malloc failed
-            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToReadWrite);
-            __leave;
-        }
-
-        status = IoReadDevice(FatData->VolumeDevice,
-            pDirEntryArray,
-            &bytesToReadWrite,
-            EntrySector * FatData->BytesPerSector
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoReadDevice", status);
-            __leave;
-        }
-        ASSERT(bytesToReadWrite == FatData->BytesPerSector * FatData->SectorsPerCluster);
-
-        memcpy(&pDirEntryArray[EntryIndex], (PVOID)DirEntry, sizeof(DIR_ENTRY));
-
-        status = IoWriteDevice(FatData->VolumeDevice,
-            pDirEntryArray,
-            &bytesToReadWrite,
-            EntrySector * FatData->BytesPerSector
-        );
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoWriteDevice", status);
-            __leave;
-        }
-        ASSERT(bytesToReadWrite == FatData->BytesPerSector * FatData->SectorsPerCluster);
-
-        status = STATUS_SUCCESS;
-    }
-    __finally
-    {
-        if (NULL != pDirEntryArray)
-        {
-            ExFreePoolWithTag(pDirEntryArray, HEAP_TEMP_TAG);
-            pDirEntryArray = NULL;
-        }
-    }
-
-    return status;
-}
-
+SAL_SUCCESS
 STATUS
 ConvertFatDateTimeToDateTime(
     IN      FATDATE*    FatDate,
@@ -766,6 +243,7 @@ ConvertDateTimeToFatDateTime(
     _ConvertTimeToFatTime(&DateTime->Time, FatTime);
 }
 
+SAL_SUCCESS
 STATUS
 ConvertFatNameToName(
     IN_READS(SHORT_NAME_CHARS)      char*       FatName,
@@ -818,7 +296,7 @@ ConvertFatNameToName(
         }
     }
     extName[i] = '\0';
-
+    
     nameLen = strlen(normalName) + i + ( ( 0 != i ) ? 1 : 0 );
     *ActualNameLength = nameLen;
     if (nameLen >= BufferSize)
@@ -840,70 +318,8 @@ ConvertFatNameToName(
     return status;
 }
 
-STATUS
-WritePartialLongFatNameToName(
-    IN                          LONG_DIR_ENTRY* LongDirEntry,
-    IN                          DWORD           BufferSize,
-    INOUT_UPDATES(BufferSize)   char*           Buffer
-)
-{
-    ASSERT(NULL != LongDirEntry);
-    ASSERT(0 != BufferSize);
-    ASSERT(NULL != Buffer);
-
-    STATUS status = STATUS_SUCCESS;
-    DWORD entryOrdinal = (LongDirEntry->LDIR_Ord & ~LONG_NAME_ORD_END_MASK) - 1;
-    BOOLEAN lastLongEntry = IsBooleanFlagOn(LongDirEntry->LDIR_Ord, LONG_NAME_ORD_END_MASK);
-    DWORD bufferWriteIndex = 0;
-    DWORD i = 0;
-    DWORD j = 0;
-
-    BYTE const* longNames[3] = { 0 };
-    DWORD longNameLengths[3] = { 0 };
-
-    longNames[0] = LongDirEntry->LDIR_Name1;
-    longNames[1] = LongDirEntry->LDIR_Name2;
-    longNames[2] = LongDirEntry->LDIR_Name3;
-
-    longNameLengths[0] = LONG_NAME1_CHARS * sizeof(WCHAR);
-    longNameLengths[1] = LONG_NAME2_CHARS * sizeof(WCHAR);
-    longNameLengths[2] = LONG_NAME3_CHARS * sizeof(WCHAR);
-
-    // calculate position of partial long name in the final name
-    bufferWriteIndex = LONG_NAME_TOTAL_CHARS * entryOrdinal;
-
-    // for each array of characters in the long directory entry
-    for (j = 0; j < ARRAYSIZE(longNames); j++)
-    {
-        // for each ascii character
-        for (i = 0; i < longNameLengths[j]; i += sizeof(WCHAR))
-        {
-            if ('\0' == longNames[j][i])
-            {
-                j = ARRAYSIZE(longNames); // break outer loop too
-                break;
-            }
-
-            if (bufferWriteIndex >= BufferSize - 1)
-            {
-                return STATUS_BUFFER_TOO_SMALL;
-            }
-
-            Buffer[bufferWriteIndex] = longNames[j][i];
-
-            bufferWriteIndex++;
-        }
-    }
-
-    if (lastLongEntry)
-    {
-        Buffer[bufferWriteIndex] = '\0';
-    }
-
-    return status;
-}
-
 static
+SAL_SUCCESS
 STATUS
 _ConvertFatDateToDate(
     IN      FATDATE*    FatDate,
@@ -935,6 +351,7 @@ _ConvertFatDateToDate(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _ConvertFatTimeToTime(
     IN      FATTIME*    FatTime,
@@ -988,7 +405,7 @@ _ConvertDateToFatDate(
 }
 
 static
-void
+void 
 _ConvertTimeToFatTime(
     IN      TIME*       RealTime,
     OUT     FATTIME*    FatTime
diff --git a/src/HAL/HAL.vcxproj b/src/HAL/HAL.vcxproj
index 74bb6a0..ddacad3 100644
--- a/src/HAL/HAL.vcxproj
+++ b/src/HAL/HAL.vcxproj
@@ -5,10 +5,6 @@
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}</ProjectGuid>
@@ -23,12 +19,6 @@
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
     <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.props" />
@@ -38,9 +28,6 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <LinkIncremental>true</LinkIncremental>
@@ -50,14 +37,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <LinkIncremental>true</LinkIncremental>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <PrecompiledHeader>
@@ -71,46 +50,7 @@
       <TreatWarningAsError>true</TreatWarningAsError>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
       <OmitFramePointers>true</OmitFramePointers>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <ShowIncludes>false</ShowIncludes>
-      <EnablePREfast>true</EnablePREfast>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <SDLCheck>true</SDLCheck>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-    <YASM>
-      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
-    </YASM>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc</AdditionalIncludeDirectories>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <OmitFramePointers>true</OmitFramePointers>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -140,7 +80,6 @@
     <ClCompile Include="src\cmos.c" />
     <ClCompile Include="src\gdt.c" />
     <ClCompile Include="src\hal.c" />
-    <ClCompile Include="src\hw_fpu.c" />
     <ClCompile Include="src\idt.c" />
     <ClCompile Include="src\ioapic.c" />
     <ClCompile Include="src\lapic.c" />
@@ -153,7 +92,6 @@
     <ClCompile Include="src\rtc.c" />
     <ClCompile Include="src\serial.c" />
     <ClCompile Include="src\tss.c" />
-    <ClCompile Include="src\vmx.c" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="headers\hal_base.h" />
@@ -163,12 +101,8 @@
     <ClInclude Include="inc\apic_common.h" />
     <ClInclude Include="inc\cmos.h" />
     <ClInclude Include="inc\cpu.h" />
-    <ClInclude Include="inc\cpuid_leaf.h" />
-    <ClInclude Include="inc\cpu_if.h" />
-    <ClInclude Include="inc\cpu_utils.h" />
     <ClInclude Include="inc\gdt.h" />
     <ClInclude Include="inc\hal.h" />
-    <ClInclude Include="inc\hw_fpu.h" />
     <ClInclude Include="inc\idt.h" />
     <ClInclude Include="inc\int15.h" />
     <ClInclude Include="inc\ioapic.h" />
@@ -186,10 +120,6 @@
     <ClInclude Include="inc\rtc.h" />
     <ClInclude Include="inc\serial.h" />
     <ClInclude Include="inc\tss.h" />
-    <ClInclude Include="inc\vmcs_fields.h" />
-    <ClInclude Include="inc\vmx.h" />
-    <ClInclude Include="inc\vmx_exit.h" />
-    <ClInclude Include="inc\vmx_exit_reasons.h" />
     <ClInclude Include="inc\yasm_imports.h" />
   </ItemGroup>
   <ItemGroup>
diff --git a/src/HAL/HAL.vcxproj.filters b/src/HAL/HAL.vcxproj.filters
index b9eaae9..ad9e00c 100644
--- a/src/HAL/HAL.vcxproj.filters
+++ b/src/HAL/HAL.vcxproj.filters
@@ -16,9 +16,6 @@
     <Filter Include="Header Files\inc">
       <UniqueIdentifier>{fa602fc5-7cf9-45fb-8274-44905e052960}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Header Files\inc\Virtualization">
-      <UniqueIdentifier>{cb6e23e9-4765-4733-8e52-d8bf31ddc027}</UniqueIdentifier>
-    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="src\idt.c">
@@ -66,12 +63,6 @@
     <ClCompile Include="src\pcie.c">
       <Filter>Source Files</Filter>
     </ClCompile>
-    <ClCompile Include="src\vmx.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="src\hw_fpu.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="inc\yasm_imports.h">
@@ -158,30 +149,6 @@
     <ClInclude Include="headers\pci_common.h">
       <Filter>Header Files</Filter>
     </ClInclude>
-    <ClInclude Include="inc\vmx_exit_reasons.h">
-      <Filter>Header Files\inc\Virtualization</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\vmcs_fields.h">
-      <Filter>Header Files\inc\Virtualization</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\vmx.h">
-      <Filter>Header Files\inc\Virtualization</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\vmx_exit.h">
-      <Filter>Header Files\inc\Virtualization</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\hw_fpu.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\cpuid_leaf.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\cpu_utils.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
-    <ClInclude Include="inc\cpu_if.h">
-      <Filter>Header Files\inc</Filter>
-    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <YASM Include="src\_exports.yasm" />
diff --git a/src/HAL/headers/ioapic_registers.h b/src/HAL/headers/ioapic_registers.h
index f2ee40b..4b0eb57 100644
--- a/src/HAL/headers/ioapic_registers.h
+++ b/src/HAL/headers/ioapic_registers.h
@@ -12,8 +12,6 @@
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
@@ -28,7 +26,7 @@ STATIC_ASSERT(sizeof(IO_APIC_REGISTER) == PREDEFINED_IO_APIC_REGISTER_SIZE);
 
 typedef union _IO_APIC_REG_SEL
 {
-    struct
+    struct  
     {
         BYTE                    ApicAddress;
         BYTE                    __Reserved[3];
@@ -39,7 +37,7 @@ STATIC_ASSERT(sizeof(IO_APIC_REG_SEL) == PREDEFINED_IO_APIC_USABLE_REGISTER_SIZE
 
 typedef union _IO_APIC_ID_REGISTER
 {
-    struct
+    struct  
     {
         BYTE                __Reserved0[3];
 
@@ -52,7 +50,7 @@ STATIC_ASSERT(sizeof(IO_APIC_ID_REGISTER) == PREDEFINED_IO_APIC_USABLE_REGISTER_
 
 typedef union _IO_APIC_VERSION_REGISTER
 {
-    struct
+    struct  
     {
         BYTE                ApicVersion;
 
@@ -169,7 +167,7 @@ typedef union _IO_APIC_REDIR_TABLE_ENTRY
         // 1, Logical Mode IOREDTBLx[63:56] = Set of processors
         QWORD                   Destination             :  8;
     };
-    struct
+    struct  
     {
         DWORD                   LowDword;
         DWORD                   HighDword;
@@ -190,5 +188,6 @@ typedef struct _IO_APIC
     IO_APIC_REGISTER        IoRegEOI;
 } IO_APIC, *PIO_APIC;
 
-#pragma warning(pop)
+#pragma warning(default:4201)
+#pragma warning(default:4214)
 #pragma pack(pop)
\ No newline at end of file
diff --git a/src/HAL/headers/lapic_registers.h b/src/HAL/headers/lapic_registers.h
index 76522ea..2de9be8 100644
--- a/src/HAL/headers/lapic_registers.h
+++ b/src/HAL/headers/lapic_registers.h
@@ -27,8 +27,6 @@
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
@@ -36,7 +34,7 @@
 #pragma warning(disable:4201)
 typedef union _ICR_HIGH_REGISTER
 {
-    struct
+    struct  
     {
         DWORD           Reserved                :   24;
         DWORD           Destination             :   8;
@@ -47,7 +45,7 @@ STATIC_ASSERT(sizeof(ICR_HIGH_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
 
 typedef union _ICR_LOW_REGISTER
 {
-    struct
+    struct 
     {
         DWORD           Vector                  :   8;
         DWORD           DeliveryMode            :   3;
@@ -66,7 +64,7 @@ STATIC_ASSERT(sizeof(ICR_LOW_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
 
 typedef union _LAPIC_VERSION_REGISTER
 {
-    struct
+    struct  
     {
         BYTE            Version;
         BYTE            __Reserved0;
@@ -80,7 +78,7 @@ STATIC_ASSERT(sizeof(LAPIC_VERSION_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE
 
 typedef union _SVR_REGISTER
 {
-    struct
+    struct 
     {
         DWORD           Vector                  :    8;
         DWORD           ApicEnable              :    1;
@@ -99,22 +97,22 @@ typedef union _LVT_REGISTER
     {
         DWORD           Vector                  :    8;
 
-        // Reserved for Timer and Error
+        // Reserved for Timer and Error              
         DWORD           DeliveryMode            :    3;
 
         DWORD           __Reserved0             :    1;
 
         DWORD           DeliveryStatus          :    1;
 
-        // Valid only for LINT0 and LINT1
+        // Valid only for LINT0 and LINT1            
         DWORD           PinPolarity             :    1;
         DWORD           RemoteIRR               :    1;
         DWORD           TriggerMode             :    1;
 
-        // Valid for all
+        // Valid for all                             
         DWORD           Masked                  :    1;
 
-        // valid only for TIMER
+        // valid only for TIMER                      
         DWORD           TimerMode               :    2;
 
         DWORD           __Reserved1             :   13;
@@ -247,5 +245,6 @@ STATIC_ASSERT(FIELD_OFFSET(LAPIC,TimerInitialCount) == LAPIC_TIMER_INITIAL_COUNT
 STATIC_ASSERT(FIELD_OFFSET(LAPIC,TimerCurrentCount) == LAPIC_TIMER_CURRENT_COUNT_REGISTER_OFFSET );
 STATIC_ASSERT(FIELD_OFFSET(LAPIC,TimerDivideConfiguration) == LAPIC_TIMER_DIVIDE_REGISTER_OFFSET );
 
-#pragma warning(pop)
-#pragma pack(pop)
+#pragma warning(default:4201)
+#pragma warning(default:4214)
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src/HAL/inc/cpu.h b/src/HAL/inc/cpu.h
index d6c0249..a68f65e 100644
--- a/src/HAL/inc/cpu.h
+++ b/src/HAL/inc/cpu.h
@@ -1,46 +1,492 @@
 #pragma once
 
 #include "register.h"
-#include "hw_fpu.h"
-#include "cpuid_leaf.h"
-#include "cpu_if.h"
 
-typedef
-QWORD
-(__cdecl FUNC_ReadFsQword)(
-    IN              DWORD           Offset
-    );
+#define NO_OF_TOTAL_INTERRUPTS          256
+#define NO_OF_RESERVED_EXCEPTIONS       32
 
-extern FUNC_ReadFsQword                     __HALreadfsqword;
-
-#define NO_OF_TOTAL_INTERRUPTS              256
-#define NO_OF_RESERVED_EXCEPTIONS           32
-
-#define NO_OF_USABLE_INTERRUPTS             (NO_OF_TOTAL_INTERRUPTS - NO_OF_RESERVED_EXCEPTIONS)
+#define NO_OF_USABLE_INTERRUPTS         (NO_OF_TOTAL_INTERRUPTS - NO_OF_RESERVED_EXCEPTIONS)
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used : nameless struct/union
 #pragma warning(disable:4201)
 
-typedef struct _REGISTER_AREA
+// Control and system registers related information
+
+// CR0 related definitions
+#define CR0_PE                                      ((QWORD)1<<0)
+#define CR0_ET                                      ((QWORD)1<<4)
+#define CR0_NE                                      ((QWORD)1<<5)
+#define CR0_WP                                      ((QWORD)1<<16)
+#define CR0_NW                                      ((QWORD)1<<29)
+#define CR0_CD                                      ((QWORD)1<<30)
+#define CR0_PG                                      ((QWORD)1<<31)
+
+// CR4 related definitions
+#define CR4_PAE                                     ((QWORD)1<<5)
+#define CR4_VMXE                                    ((QWORD)1<<13)
+#define CR4_SMXE                                    ((QWORD)1<<14)
+#define CR4_PCIDE                                   ((QWORD)1<<17)
+#define CR4_OSXSAVE                                 ((QWORD)1<<18)
+#define CR4_SMEP                                    ((QWORD)1<<20)
+#define CR4_SMAP                                    ((QWORD)1<<21)
+
+// RFLAGS related definitions
+#define RFLAGS_CARRY_FLAG_BIT                       ((QWORD)1<<0)
+#define RFLAGS_RESERVED_BIT                         ((QWORD)1<<1)
+#define RFLAGS_TRAP_BIT                             ((QWORD)1<<8)
+#define RFLAGS_INTERRUPT_FLAG_BIT                   ((QWORD)1<<9)
+#define RFLAGS_DIRECTION_BIT                        ((QWORD)1<<10)
+#define RFLAGS_RESUME_FLAG_BIT                      ((QWORD)1<<16)
+
+typedef enum _CPUID_IDX
+{
+    CpuidIdxBasicInformation                    = 0x0,
+    CpuidIdxFeatureInformation,
+    CpuidIdxMonitorLeaf                         = 0x5,
+    CpuidIdxStructuredExtendedFeaturesLeaf      = 0x7,
+    CpuidIdxArchPerfMonLeaf                     = 0xA,
+    CpuidIdxExtendedMaxFunction                 = 0x8000'0000,
+    CpuidIdxExtendedFeatureInformation          = 0x8000'0001,
+    CpuidIdxProcessorAddressSizes               = 0x8000'0008,
+} CPUID_IDX;
+
+// CPUID related information
+
+// 0x0
+typedef struct _CPUID_BASIC_INFORMATION
+{
+    DWORD           MaxValueForBasicInfo;
+    DWORD           CpuIdString0;
+    DWORD           CpuidString2;
+    DWORD           CpuidString1;
+} CPUID_BASIC_INFORMATION, *PCPUID_BASIC_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_BASIC_INFORMATION) == sizeof(DWORD) * 4);
+
+// 0x1
+typedef struct _CPUID_EBX_FEATURE_INFORMATION
+{
+    BYTE            BrandIndex;
+
+    // This value * 8 => cache line size in bytes ( used by CLFLUSHOPT too)
+    BYTE            CLFlushLineSize;
+
+    BYTE            MaxNumberOfAddressableIds;
+
+    BYTE            ApicId;
+} CPUID_EBX_FEATURE_INFORMATION, *PCPUID_EBX_FEATURE_INFORMATION;    
+STATIC_ASSERT(sizeof(CPUID_EBX_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_ECX_FEATURE_INFORMATION
+{
+    DWORD           SSE3                        :   1;
+    DWORD           PCLMULQDQ                   :   1;
+    DWORD           DTES64                      :   1;
+    DWORD           MONITOR                     :   1;
+    DWORD           DS_CPL                      :   1;
+    DWORD           VMX                         :   1;
+    DWORD           SMX                         :   1;
+    DWORD           EIST                        :   1;
+    DWORD           TM2                         :   1;
+    DWORD           SSSE3                       :   1;
+    DWORD           CNXT_ID                     :   1;
+    DWORD           SDBG                        :   1;
+    DWORD           FMA                         :   1;
+    DWORD           CMPXCHG16B                  :   1;
+    DWORD           xTPRUpdateControl           :   1;
+    DWORD           PDCM                        :   1;
+    DWORD           __Reserved0                 :   1;
+    DWORD           PCID                        :   1;
+    DWORD           DCA                         :   1;
+    DWORD           SSE4_1                      :   1;
+    DWORD           SSE4_2                      :   1;
+    DWORD           x2APIC                      :   1;
+    DWORD           MOVBE                       :   1;
+    DWORD           POPCNT                      :   1;
+    DWORD           TSC_Deadline                :   1;
+    DWORD           AESNI                       :   1;
+    DWORD           XSAVE                       :   1;
+    DWORD           OSXSAVE                     :   1;
+    DWORD           AVX                         :   1;
+    DWORD           F16C                        :   1;
+    DWORD           RDRAND                      :   1;
+    DWORD           HV                          :   1;
+} CPUID_ECX_FEATURE_INFORMATION, *PCPUID_ECX_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_ECX_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_EDX_FEATURE_INFORMATION
+{
+    DWORD           FPU                         :   1;
+    DWORD           VME                         :   1;
+    DWORD           DE                          :   1;
+    DWORD           PSE                         :   1;
+    DWORD           TSC                         :   1;
+    DWORD           MSR                         :   1;
+    DWORD           PAE                         :   1;
+    DWORD           MCE                         :   1;
+    DWORD           CX8                         :   1;
+    DWORD           APIC                        :   1;
+    DWORD           __Reserved0                 :   1;
+    DWORD           SEP                         :   1;
+    DWORD           MTRR                        :   1;
+    DWORD           PGE                         :   1;
+    DWORD           MCA                         :   1;
+    DWORD           CMOV                        :   1;
+    DWORD           PAT                         :   1;
+    DWORD           PSE_36                      :   1;
+    DWORD           PSN                         :   1;
+    DWORD           CLFSH                       :   1;
+    DWORD           __Reserved1                 :   1;
+    DWORD           DS                          :   1;
+    DWORD           ACPI                        :   1;
+    DWORD           MMX                         :   1;
+    DWORD           FXSR                        :   1;
+    DWORD           SSE                         :   1;
+    DWORD           SSE2                        :   1;
+    DWORD           SS                          :   1;
+    DWORD           HTT                         :   1;
+    DWORD           TM                          :   1;
+    DWORD           __Reserved2                 :   1;
+    DWORD           PBE                         :   1;
+} CPUID_EDX_FEATURE_INFORMATION, *PCPUID_EDX_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EDX_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_FEATURE_INFORMATION
 {
-    QWORD                                           RegisterValues[RegisterR15 + 1];
+    DWORD                               eax;
+    CPUID_EBX_FEATURE_INFORMATION       ebx;
+    CPUID_ECX_FEATURE_INFORMATION       ecx;
+    CPUID_EDX_FEATURE_INFORMATION       edx;
+} CPUID_FEATURE_INFORMATION, *PCPUID_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_FEATURE_INFORMATION) == sizeof(DWORD) * 4);
 
-    QWORD                                           Rip;
+// 0x5
+typedef struct _CPUID_EAX_MONITOR_LEAF
+{
+    WORD                                SmallestMonitorLineSize;
+    WORD                                __Reserved0;
+} CPUID_EAX_MONITOR_LEAF, *PCPUID_EAX_MONITOR_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EAX_MONITOR_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_EBX_MONITOR_LEAF
+{
+    WORD                                LargestMonitorLineSize;
+    WORD                                __Reserved0;
+} CPUID_EBX_MONITOR_LEAF, *PCPUID_EBX_MONITOR_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EBX_MONITOR_LEAF) == sizeof(DWORD));
 
-    QWORD                                           Rflags;
-} REGISTER_AREA, *PREGISTER_AREA;
+typedef struct _CPUID_MONITOR_LEAF
+{
+    CPUID_EAX_MONITOR_LEAF              eax;
+    CPUID_EBX_MONITOR_LEAF              ebx;
+    DWORD                               ecx;
+    DWORD                               edx;
+} CPUID_MONITOR_LEAF, *PCPUID_MONITOR_LEAF;
+STATIC_ASSERT(sizeof(CPUID_MONITOR_LEAF) == sizeof(DWORD) * 4);
+
+// 0x7, 0x0
+typedef struct _CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF
+{
+    DWORD                               FSGSBASE                                : 1;
+    DWORD                               IA32_TSC_ADJUST_MSR                     : 1;
+    DWORD                               SGX                                     : 1;
+    DWORD                               BMI1                                    : 1;
+    DWORD                               HLE                                     : 1;
+    DWORD                               AVX2                                    : 1;
+    DWORD                               FP_EXCEPTIN_ONLY                        : 1;
+    DWORD                               SMEP                                    : 1;
+    DWORD                               BMI2                                    : 1;
+    DWORD                               EnhancedRepMovsb                        : 1;
+    DWORD                               INVPCID                                 : 1;
+    DWORD                               RTM                                     : 1;
+    DWORD                               RDTM                                    : 1;
+    DWORD                               DeprecatesFpuDsCs                       : 1;
+    DWORD                               MPX                                     : 1;
+    DWORD                               RDTA                                    : 1;
+    DWORD                               __Reserved16_17                         : 2;
+    DWORD                               RDSEED                                  : 1;
+    DWORD                               ADX                                     : 1;
+    DWORD                               SMAP                                    : 1;
+    DWORD                               __Reserved21_22                         : 2;
+    DWORD                               CLFLUSHOPT                              : 1;
+    DWORD                               __Reserved24                            : 1;
+    DWORD                               ProcessorTrace                          : 1;
+    DWORD                               __Reserved26_28                         : 3;
+    DWORD                               SHA                                     : 1;
+    DWORD                               __Reserved30_31                         : 2;
+} CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF, *PCPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF) == sizeof(DWORD));
 
-typedef struct _COMPLETE_PROCESSOR_STATE
+typedef struct _CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF
 {
-    XSAVE_AREA                                      XsaveArea;
+    DWORD                               PREFETCHWT1                             : 1;
+    DWORD                               __Reserved1                             : 1;
+    DWORD                               UMIP                                    : 1;
+    DWORD                               PKU                                     : 1;
+    DWORD                               OSPKE                                   : 1;
+    DWORD                               __Reserved5_16                          : 12;
+    DWORD                               MAWAU                                   : 5;
+    DWORD                               RDPID                                   : 1;
+    DWORD                               __Reserved23_29                         : 7;
+    DWORD                               SGX_LC                                  : 1;
+    DWORD                               __Reserved31                            : 1;
+} CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF, *PCPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF;
+STATIC_ASSERT(sizeof(CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF) == sizeof(DWORD));
 
-    REGISTER_AREA                                   RegisterArea;
-} COMPLETE_PROCESSOR_STATE, *PCOMPLETE_PROCESSOR_STATE;
-#pragma warning(pop)
+typedef struct _CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF
+{
+    DWORD                                               MaxSubleaf;
+    CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    ebx;
+    CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    ecx;
+    DWORD                                               __Reserved;
+} CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF, *PCPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF;
+STATIC_ASSERT(sizeof(CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF) == sizeof(DWORD) * 4);
+
+// 0xA
+typedef struct _CPUID_EAX_ARCH_PERF_MON_LEAF
+{
+    BYTE                                VersionId;
+    BYTE                                NumberOfPmcsPerCpu;
+    BYTE                                BitWidth;
+    BYTE                                LengthOfEbxBitVector;
+} CPUID_EAX_ARCH_PERF_MON_LEAF, *PCPUID_EAX_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EAX_ARCH_PERF_MON_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_EBX_ARCH_PERF_MON_LEAF
+{
+    DWORD                               CoreCycleEventNotAvail                  : 1;
+    DWORD                               InstructionRetiredEventNotAvail         : 1;
+    DWORD                               ReferenceCyclesEventNotAvail            : 1;
+    DWORD                               LastLevelCacheReferenceEventNotAvail    : 1;
+    DWORD                               LastLevelCacheMissesEventNotAvail       : 1;
+    DWORD                               BranchInstructionRetiredEventNotAvail   : 1;
+    DWORD                               BranchMispredictRetiredEventNotAvail    : 1;
+    DWORD                               __Reserved7_31                          : 25;
+} CPUID_EBX_ARCH_PERF_MON_LEAF, *PCPUID_EBX_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EBX_ARCH_PERF_MON_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_EDX_ARCH_PERF_MON_LEAF
+{
+    // If VersionID > 1
+    DWORD                               NoOfFixedPmcs                           : 5;
+
+    // If VersionID > 1
+    DWORD                               BitWidthOfFixedPmcs                     : 8;
+
+    DWORD                               __Reserved13_31                         : 19;
+} CPUID_EDX_ARCH_PERF_MON_LEAF, *PCPUID_EDX_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EDX_ARCH_PERF_MON_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_ARCH_PERF_MON_LEAF
+{
+    CPUID_EAX_ARCH_PERF_MON_LEAF        eax;
+    CPUID_EBX_ARCH_PERF_MON_LEAF        ebx;
+    DWORD                               ecx;
+    CPUID_EDX_ARCH_PERF_MON_LEAF        edx;
+} CPUID_ARCH_PERF_MON_LEAF, *PCPUID_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_ARCH_PERF_MON_LEAF) == sizeof(DWORD) * 4);
+
+// 0x8000'0000
+typedef struct _CPUID_EXTENDED_CPUID_INFORMATION
+{
+    DWORD                               MaxValueForExtendedInfo;
+    DWORD                               __Reserved0;
+    DWORD                               __Reserved1;
+    DWORD                               __Reserved2;
+} CPUID_EXTENDED_CPUID_INFORMATION, *PCPUID_EXTENDED_CPUID_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EXTENDED_CPUID_INFORMATION) == sizeof(DWORD) * 4);
+
+// 0x8000'0001
+typedef struct _CPUID_ECX_EXTENDED_FEATURE_INFORMATION
+{
+    DWORD                               LahfSahf            : 1;
+    DWORD                               __Reserved0         : 4;
+    DWORD                               LZCNT               : 1;
+    DWORD                               __Reserved1         : 2;
+    DWORD                               PREFETCHW           : 1;
+    DWORD                               __Reserved2         : 23;
+} CPUID_ECX_EXTENDED_FEATURE_INFORMATION, *PCPUID_ECX_EXTENDED_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_ECX_EXTENDED_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_EDX_EXTENDED_FEATURE_INFORMATION
+{
+    DWORD                               __Reserved0         : 11;
+    DWORD                               Syscall             : 1;
+    DWORD                               __Reserved1         : 8;
+    DWORD                               ExecuteDisable      : 1;
+    DWORD                               __Reserved2         : 5;
+    DWORD                               LargePages          : 1;
+    DWORD                               RDTSCP              : 1;
+    DWORD                               __Reserved3         : 1;
+    DWORD                               Intel64             : 1;
+    DWORD                               __Reserved4         : 2;
+} CPUID_EDX_EXTENDED_FEATURE_INFORMATION, *PCPUID_EDX_EXTENDED_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EDX_EXTENDED_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_EXTENDED_FEATURE_INFORMATION
+{
+    DWORD                                   ExtendedProcessorSignature;
+    DWORD                                   __Reserved;
+    CPUID_ECX_EXTENDED_FEATURE_INFORMATION  ecx;
+    CPUID_EDX_EXTENDED_FEATURE_INFORMATION  edx;
+} CPUID_EXTENDED_FEATURE_INFORMATION, *PCPUID_EXTENDED_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EXTENDED_FEATURE_INFORMATION) == sizeof(DWORD) * 4);
+
+// 0x8000'0008
+typedef struct _CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION
+{
+    BYTE                                    PhysicalAddressBits;
+    BYTE                                    LinearAddressBits;
+    WORD                                    __Reserved;
+} CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION, *PCPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION
+{
+    CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION   eax;
+    DWORD                                           __Reserved0;
+    DWORD                                           __Reserved1;
+    DWORD                                           __Reserved2;
+} CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION, *PCPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION) == sizeof(DWORD) * 4);
+
+// structure retrieved by __cpuid operations
+typedef struct _CPUID_INFO
+{
+    union {
+        int values[4];
+        struct {
+            DWORD eax;
+            DWORD ebx;
+            DWORD ecx;
+            DWORD edx;
+        };
+        // 0x0
+        CPUID_BASIC_INFORMATION                     BasicInformation;
+
+        // 0x1
+        CPUID_FEATURE_INFORMATION                   FeatureInformation;
+        
+        // 0x5
+        CPUID_MONITOR_LEAF                          MonitorLeaf;
+
+        // 0x7
+        CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    StructuredExtendedFeatures;
+
+        // 0xA
+        CPUID_ARCH_PERF_MON_LEAF                    ArchitecturalPerfMonLeaf;
+    
+        // 0x8000'0000
+        CPUID_EXTENDED_CPUID_INFORMATION            ExtendedInformation;
+
+        // 0x8000'0001
+        CPUID_EXTENDED_FEATURE_INFORMATION          ExtendedFeatures;
+
+        // 0x8000'0008
+        CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION   CpuAddressSizes;
+    };
+} CPUID_INFO, *PCPUID_INFO;
+STATIC_ASSERT(sizeof(CPUID_INFO) == sizeof(DWORD) * 4);
+
+#pragma warning(default:4201)
+#pragma pack(pop)
+
+// define explicit packing for exported structures
+#pragma pack(push,8)
+typedef struct _PROCESSOR_STATE
+{
+    QWORD       RegisterValues[RegisterR15 + 1];
+
+    QWORD       Rip;
+
+    QWORD       Rflags;
+} PROCESSOR_STATE, *PPROCESSOR_STATE;
 #pragma pack(pop)
 
-#include "cpu_utils.h"
+__forceinline
+extern
+void
+CpuClearDirectionFlag(
+    void
+    )
+{
+    __writeeflags(__readeflags() & (~RFLAGS_DIRECTION_BIT));
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrGetState(
+    void
+    )
+{
+    return IsBooleanFlagOn(__readeflags(), RFLAGS_INTERRUPT_FLAG_BIT);
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrSetState(
+    const      INTR_STATE         IntrState
+    )
+{
+    QWORD rFlags = __readeflags();
+    QWORD newFlags = IntrState ? ( rFlags | RFLAGS_INTERRUPT_FLAG_BIT ) : ( rFlags & ( ~RFLAGS_INTERRUPT_FLAG_BIT));
+
+    __writeeflags(newFlags);
+
+    return IsBooleanFlagOn(rFlags, RFLAGS_INTERRUPT_FLAG_BIT);
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrDisable(
+    void
+    )
+{
+    return CpuIntrSetState(FALSE);
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrEnable(
+    void
+    )
+{
+    return CpuIntrSetState(TRUE);
+}
+
+typedef BYTE APIC_ID;
+
+__forceinline
+extern
+APIC_ID
+CpuGetApicId(
+    void
+    )
+{
+    CPUID_INFO cpuId;
+
+    __cpuid(cpuId.values, CpuidIdxFeatureInformation);
+
+    return cpuId.FeatureInformation.ebx.ApicId;
+}
+
+__forceinline
+extern
+BOOLEAN
+CpuIsIntel(
+    void
+    )
+{
+    CPUID_INFO cpuId;
+
+    __cpuid(cpuId.values, CpuidIdxBasicInformation);
+
+    return ( cpuId.ebx == 'uneG' &&
+             cpuId.edx == 'Ieni' &&
+             cpuId.ecx == 'letn' );
+}
\ No newline at end of file
diff --git a/src/HAL/inc/gdt.h b/src/HAL/inc/gdt.h
index 6c9ded5..c200189 100644
--- a/src/HAL/inc/gdt.h
+++ b/src/HAL/inc/gdt.h
@@ -51,8 +51,6 @@ typedef enum _NON_SYSTEM_SEGMENT_TYPES
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 //warning C4214: nonstandard extension used : bit field types other than int
 #pragma warning(disable:4214)
 
@@ -118,7 +116,7 @@ typedef struct _GDT
     SEGMENT_DESCRIPTOR*     Base;
 } GDT, *PGDT;
 STATIC_ASSERT(sizeof(GDT) == PREDEFINED_GDT_SIZE);
-#pragma warning(pop)
+#pragma warning(default:4214)
 #pragma pack(pop)
 
 typedef enum _SEGMENT_DESCRIPTOR_FLAGS
diff --git a/src/HAL/inc/hw_fpu.h b/src/HAL/inc/hw_fpu.h
index ea6bbec..30304bf 100644
--- a/src/HAL/inc/hw_fpu.h
+++ b/src/HAL/inc/hw_fpu.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#define INCLUDE_FP_SUPPORT                  0
-
 typedef QWORD XCR0_SAVED_STATE;
 
 #define XCR0_SAVED_STATE_x87_MMX            (1ULL<<0)
diff --git a/src/HAL/inc/idt.h b/src/HAL/inc/idt.h
index 205e904..0587e96 100644
--- a/src/HAL/inc/idt.h
+++ b/src/HAL/inc/idt.h
@@ -24,6 +24,7 @@ IdtInitialize(
 // Parameter:    IN BOOLEAN Present
 // Parameter:    IN PVOID HandlerAddress - Address of interrupt handler
 //******************************************************************************
+SAL_SUCCESS
 STATUS
 IdtInstallDescriptor(
     IN                  BYTE            InterruptIndex,
diff --git a/src/HAL/inc/lapic.h b/src/HAL/inc/lapic.h
index aa9eb51..c1d6b5e 100644
--- a/src/HAL/inc/lapic.h
+++ b/src/HAL/inc/lapic.h
@@ -11,7 +11,7 @@ LapicInitialize(
 void
 LapicSetLogicalApicId(
     IN      PVOID                           ApicBaseAddress,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_ID                         LogicalApicId,
     IN      BYTE                            DestinationFormat
     );
@@ -33,12 +33,12 @@ void
 LapicConfigureTimer(
     IN      PVOID                           ApicBaseAddress,
     IN      BYTE                            TimerInterruptVector,
-    IN     _Strict_type_match_
+    IN     _Strict_type_match_ 
             APIC_DIVIDE_VALUE               DivideValue
     );
 
 void
-LapicSetTimerInterval(
+LapicEnableTimer(
     IN      PVOID                           ApicBaseAddress,
     IN      DWORD                           TimerCount
     );
@@ -58,11 +58,11 @@ LapicSendEOI(
 void
 LapicSendIpi(
     IN      PVOID                           ApicBaseAddress,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_ID                         ApicId,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_DELIVERY_MODE              DeliveryMode,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_DESTINATION_SHORTHAND      DestinationShorthand,
     IN      _Strict_type_match_
             APIC_DESTINATION_MODE           DestinationMode,
diff --git a/src/HAL/inc/msr.h b/src/HAL/inc/msr.h
index 904f8fd..ea2c015 100644
--- a/src/HAL/inc/msr.h
+++ b/src/HAL/inc/msr.h
@@ -143,7 +143,7 @@
 #define     IA32_PEBS_ENABLE                        0x000003F1
 
 //
-//
+// 
 // VMX based MSR's
 //
 //
@@ -291,8 +291,6 @@
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
@@ -308,7 +306,8 @@ typedef union _IA32_STAR_MSR_DATA
 } IA32_STAR_MSR_DATA, *PIA32_STAR_MSR_DATA;
 STATIC_ASSERT(sizeof(IA32_STAR_MSR_DATA) == MSR_DATA_SIZE);
 
-#pragma warning(pop)
+#pragma warning(default:4201)
+
 #pragma pack(pop)
 
 #define     IA32_STAR                           0xC0000081
diff --git a/src/HAL/inc/pci.h b/src/HAL/inc/pci.h
index ba25bc7..a516829 100644
--- a/src/HAL/inc/pci.h
+++ b/src/HAL/inc/pci.h
@@ -40,6 +40,7 @@ typedef struct _PCI_DEVICE_DESCRIPTION
 //               function will return STATUS_DEVICE_NO_MORE_DEVICES until a call
 //               with ResetSearch == TRUE will be made.
 //******************************************************************************
+SAL_SUCCESS
 STATUS
 PciRetrieveNextDevice(
     IN      BOOLEAN         ResetSearch,
diff --git a/src/HAL/inc/pci_registers.h b/src/HAL/inc/pci_registers.h
index 5131946..ad8c368 100644
--- a/src/HAL/inc/pci_registers.h
+++ b/src/HAL/inc/pci_registers.h
@@ -81,8 +81,6 @@ typedef enum _PCI_BRIDGE_SUBCLASS
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
@@ -123,7 +121,7 @@ STATIC_ASSERT(sizeof(PCI_BAR) == PREDEFINED_PCI_BAR_SIZE);
 
 typedef union _PCI_STATUS_REGISTER
 {
-    struct
+    struct  
     {
         WORD            __Reserved0         :   3;
         WORD            InterruptStatus     :   1;
@@ -136,7 +134,7 @@ STATIC_ASSERT(sizeof(PCI_STATUS_REGISTER) == PREDEFINED_PCI_STATUS_SIZE);
 
 typedef union _PCI_COMMAND_REGISTER
 {
-    struct
+    struct  
     {
         // Controls a device's response to I/O Space accesses. A value of 0
         // disables the device response.A value of 1 allows the device to
@@ -221,7 +219,7 @@ STATIC_ASSERT(sizeof(PCI_COMMAND_REGISTER) == PREDEFINED_PCI_COMMAND_SIZE);
 
 typedef union _PCI_HEADER_TYPE_REGISTER
 {
-    struct
+    struct  
     {
         // Bits 6 through 0 identify the layout of the
         // second part of the predefined header.The encoding 00h specifies
@@ -233,7 +231,7 @@ typedef union _PCI_HEADER_TYPE_REGISTER
         BYTE            Layout              :   7;
 
         // Bit 7 in this register is used to identify a multi - function device.
-        // If the bit is 0, then the device is single function. If the bit is 1,
+        // If the bit is 0, then the device is single function. If the bit is 1, 
         // then the device has multiple functions.
         BYTE            Multifunction       :   1;
     };
@@ -256,7 +254,7 @@ typedef BYTE PCI_CAPABILITY_ID;
 typedef struct _PCI_CAPABILITY_HEADER
 {
     PCI_CAPABILITY_ID           CapabilityId;
-
+   
     BYTE                        NextPointer;
 } PCI_CAPABILITY_HEADER, *PPCI_CAPABILITY_HEADER;
 STATIC_ASSERT(sizeof(PCI_CAPABILITY_HEADER) == PREDEFINED_PCI_CAPABILITY_HEADER_SIZE);
@@ -287,7 +285,7 @@ STATIC_ASSERT(sizeof(PCI_MSI_ADDRESS_REGISTER) == PREDEFINED_PCI_MSI_ADDRESS_REG
 
 typedef volatile union _PCI_MSI_DATA_REGISTER
 {
-    struct
+    struct  
     {
         BYTE        Vector;
 
@@ -305,7 +303,7 @@ typedef volatile struct _PCI_CAPABILITY_MSI
     PCI_CAPABILITY_HEADER               Header;
     union
     {
-        struct
+        struct  
         {
             // RW
             BYTE                        MsiEnable                   :   1;
@@ -333,7 +331,7 @@ typedef volatile struct _PCI_CAPABILITY_MSI
         {
             PCI_MSI_DATA_REGISTER       MessageData;
         } Capability32Bit;
-        struct
+        struct  
         {
             DWORD                       MessageAddressHigher;
             PCI_MSI_DATA_REGISTER       MessageData;
@@ -430,7 +428,7 @@ STATIC_ASSERT(sizeof(PCI_BRIDGE_HEADER) == PREDEFINED_PCI_BRIDGE_HEADER_SIZE);
 
 typedef volatile struct _PCI_COMMON_HEADER
 {
-    // PCI Specification 3.0 Section 6.1
+    // PCI Specification 3.0 Section 6.1 
     // The first 16 bytes are defined the same for all types of devices.
     WORD                            VendorID;
     WORD                            DeviceID;
@@ -459,5 +457,6 @@ typedef volatile struct _PCI_COMMON_HEADER
 } PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;
 STATIC_ASSERT(sizeof(PCI_COMMON_HEADER) == PREDEFINED_PCI_COMMON_HEADER_SIZE);
 
-#pragma warning(pop)
-#pragma pack(pop)
+#pragma warning(default:4201)
+#pragma warning(default:4214)
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src/HAL/inc/pcie.h b/src/HAL/inc/pcie.h
index 71e667c..9c61a15 100644
--- a/src/HAL/inc/pcie.h
+++ b/src/HAL/inc/pcie.h
@@ -9,6 +9,7 @@ typedef struct _PCI_ROOT_COMPLEX
     BYTE            EndBusNumber;
 } PCI_ROOT_COMPLEX, *PPCI_ROOT_COMPLEX;
 
+SAL_SUCCESS
 STATUS
 PciExpressRetrieveNextDevice(
     IN      PPCI_ROOT_COMPLEX           PciRootComplex,
diff --git a/src/HAL/inc/pte.h b/src/HAL/inc/pte.h
index 9aeb7bd..47863c7 100644
--- a/src/HAL/inc/pte.h
+++ b/src/HAL/inc/pte.h
@@ -2,9 +2,6 @@
 
 #define MAXPHYADDR                                  52
 
-#define PAGING_TABLES_FIRST_LEVEL                   1
-#define PAGING_TABLES_LAST_LEVEL                    4
-
 // 63:48 must equal bit 47 for the address to be canonical
 #define VA_HIGHEST_VALID_BIT                                        47
 
@@ -33,9 +30,6 @@
 typedef WORD PCID;
 
 #pragma pack(push,1)
-
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
@@ -49,13 +43,13 @@ typedef union _PML4
 {
     union
     {
-        struct
+        struct 
         {
             QWORD           PCID                :   PCID_NO_OF_BITS;
             QWORD           PhysicalAddress     :   MAXPHYADDR - 12;
             QWORD           Reserved            :   64 - MAXPHYADDR;
         } Pcide;
-        struct
+        struct 
         {
             QWORD           Ignored0            :   3;
             QWORD           PWT                 :   1;
@@ -113,14 +107,14 @@ typedef struct _PDPT_ENTRY_1G
     QWORD           UserSupervisor      :   1;
     QWORD           PWT                 :   1;
     QWORD           PCD                 :   1;
-    QWORD           Accessed            :   1;
+    QWORD           Accessed            :   1;   
     QWORD           Dirty               :   1;
     QWORD           PageSize            :   1;  // Must be 1
     QWORD           Global              :   1;
     QWORD           Ignored             :   3;
     QWORD           PAT                 :   1;
     QWORD           Reserved            :   17;
-    QWORD           PhysicalAddress     :   MAXPHYADDR-30;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-30;          
     QWORD           Ignored2            :   11;
     QWORD           XD                  :   1;
 } PDPT_ENTRY_1G, *PPDTP_ENTRY_1G;
@@ -134,7 +128,7 @@ typedef struct _PD_ENTRY_PT
     QWORD           UserSupervisor      :   1;
     QWORD           PWT                 :   1;
     QWORD           PCD                 :   1;
-    QWORD           Accessed            :   1;
+    QWORD           Accessed            :   1;   
     QWORD           Ignored0            :   1;
     QWORD           PageSize            :   1;  // Must be 0
     QWORD           Ignored1            :   4;
@@ -142,7 +136,7 @@ typedef struct _PD_ENTRY_PT
     QWORD           Ignored2            :   11;
     QWORD           XD                  :   1;
 } PD_ENTRY_PT, *PPD_ENTRY_PT;
-STATIC_ASSERT( sizeof( PD_ENTRY_PT ) == sizeof( QWORD ) );
+STATIC_ASSERT( sizeof( PD_ENTRY_PT ) == sizeof( QWORD ) );   
 
 // PD_ENTRY that maps a 2-MByte Page
 typedef struct _PD_ENTRY_2MB
@@ -152,14 +146,14 @@ typedef struct _PD_ENTRY_2MB
     QWORD           UserSupervisor      :   1;
     QWORD           PWT                 :   1;
     QWORD           PCD                 :   1;
-    QWORD           Accessed            :   1;
+    QWORD           Accessed            :   1;   
     QWORD           Dirty               :   1;
     QWORD           PageSize            :   1;  // Must be 1
     QWORD           Global              :   1;
     QWORD           Ignored             :   3;
     QWORD           PAT                 :   1;
     QWORD           Reserved            :   8;
-    QWORD           PhysicalAddress     :   MAXPHYADDR-21;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-21;          
     QWORD           Ignored2            :   11;
     QWORD           XD                  :   1;
 } PD_ENTRY_2MB, *PPD_ENTRY_2MB;
@@ -172,12 +166,12 @@ typedef struct _PT_ENTRY
     QWORD           UserSupervisor      :   1;
     QWORD           PWT                 :   1;
     QWORD           PCD                 :   1;
-    QWORD           Accessed            :   1;
+    QWORD           Accessed            :   1;   
     QWORD           Dirty               :   1;
     QWORD           PAT                 :   1;
     QWORD           Global              :   1;
     QWORD           Ignored0            :   3;
-    QWORD           PhysicalAddress     :   MAXPHYADDR-12;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-12;          
     QWORD           Ignored1            :   11;
     QWORD           XD                  :   1;
 } PT_ENTRY, *PPT_ENTRY;
@@ -200,7 +194,7 @@ typedef struct _PDPT_PAE_ENTRY_PD
     QWORD           Reserved0           :   2;
     QWORD           PWT                 :   1;
     QWORD           PCD                 :   1;
-    QWORD           Reserved1           :   4;
+    QWORD           Reserved1           :   4;   
     QWORD           Ignored0            :   3;
     QWORD           PhysicalAddress     :   MAXPHYADDR-12;
     QWORD           Reserved2           :   12;
@@ -252,12 +246,12 @@ typedef struct _PT_PAE_ENTRY
     QWORD           UserSupervisor      :   1;
     QWORD           PWT                 :   1;
     QWORD           PCD                 :   1;
-    QWORD           Accessed            :   1;
+    QWORD           Accessed            :   1;   
     QWORD           Dirty               :   1;
     QWORD           PAT                 :   1;
     QWORD           Global              :   1;
     QWORD           Ignored             :   3;
-    QWORD           PhysicalAddress     :   MAXPHYADDR-12;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-12;          
     QWORD           Reserved            :   11;
     QWORD           XD                  :   1;
 } PT_PAE_ENTRY, *PPT_PAE_ENTRY;
@@ -340,7 +334,8 @@ typedef struct _PTE_MAP_FLAGS
     WORD            __Reserved0          :    7;
 } PTE_MAP_FLAGS, *PPTE_MAP_FLAGS;
 STATIC_ASSERT(sizeof(PTE_MAP_FLAGS) == sizeof(WORD));
-#pragma warning(pop)
+#pragma warning(default:4214)
+#pragma warning(default:4201)
 #pragma pack(pop)
 
 void
@@ -368,17 +363,4 @@ PteLargePageGetPhysicalAddress(
 BOOLEAN
 PteIsPresent(
     IN          PVOID           PageTable
-    );
-
-__forceinline
-void
-PageInvalidateTlb(
-    IN          PVOID           Page
-    )
-{
-    // This is a HACK done to prevent a Visual C compiler bug which sometimes (if 2 __invlpg are one after another)
-    // causes the __invlpg to generate a swapgs instruction :|
-    // Yeah, good job Microsoft...
-    _ReadWriteBarrier();
-    __invlpg(Page);
-}
+    );
\ No newline at end of file
diff --git a/src/HAL/inc/register.h b/src/HAL/inc/register.h
index e7b125d..3050ccf 100644
--- a/src/HAL/inc/register.h
+++ b/src/HAL/inc/register.h
@@ -1,39 +1,5 @@
 #pragma once
 
-// Control and system registers related information
-
-// CR0 related definitions
-#define CR0_PE                                      ((QWORD)1<<0)
-#define CR0_EM                                      ((QWORD)1<<2)
-#define CR0_ET                                      ((QWORD)1<<4)
-#define CR0_NE                                      ((QWORD)1<<5)
-#define CR0_WP                                      ((QWORD)1<<16)
-#define CR0_NW                                      ((QWORD)1<<29)
-#define CR0_CD                                      ((QWORD)1<<30)
-#define CR0_PG                                      ((QWORD)1<<31)
-
-// CR4 related definitions
-#define CR4_PAE                                     ((QWORD)1<<5)
-#define CR4_OSFXSR                                  ((QWORD)1<<9)
-#define CR4_OSXMMEXCPT                              ((QWORD)1<<10)
-#define CR4_VMXE                                    ((QWORD)1<<13)
-#define CR4_SMXE                                    ((QWORD)1<<14)
-#define CR4_PCIDE                                   ((QWORD)1<<17)
-#define CR4_OSXSAVE                                 ((QWORD)1<<18)
-#define CR4_SMEP                                    ((QWORD)1<<20)
-#define CR4_SMAP                                    ((QWORD)1<<21)
-
-// Extended control registers
-#define XCR0_INDEX                                  0
-
-// RFLAGS related definitions
-#define RFLAGS_CARRY_FLAG_BIT                       ((QWORD)1<<0)
-#define RFLAGS_RESERVED_BIT                         ((QWORD)1<<1)
-#define RFLAGS_TRAP_BIT                             ((QWORD)1<<8)
-#define RFLAGS_INTERRUPT_FLAG_BIT                   ((QWORD)1<<9)
-#define RFLAGS_DIRECTION_BIT                        ((QWORD)1<<10)
-#define RFLAGS_RESUME_FLAG_BIT                      ((QWORD)1<<16)
-
 typedef enum
 {
     RegisterRax,
@@ -65,20 +31,4 @@ typedef enum
     CR6,
     CR7,
     CR8
-} ControlRegisterIndexes;
-
-
-typedef enum
-{
-    SelectorFirst,
-
-    SelectorES = SelectorFirst,
-    SelectorCS,
-    SelectorSS,
-    SelectorDS,
-    selectorFS,
-    SelectorGS,
-    SelectorTR,
-
-    SelectorReserved = SelectorTR + 1
-} SelectorIndex;
+} ControlRegisterIndexes;
\ No newline at end of file
diff --git a/src/HAL/inc/tss.h b/src/HAL/inc/tss.h
index d3937d5..cd3f64d 100644
--- a/src/HAL/inc/tss.h
+++ b/src/HAL/inc/tss.h
@@ -7,14 +7,11 @@
 #define NO_OF_IST               7
 
 #pragma pack(push,1)
-
-#pragma warning(push)
-
 //warning C4214: nonstandard extension used : bit field types other than int
 #pragma warning(disable:4214)
 
 // 7.7, Vol 3, No. 56
-typedef struct _TSS
+typedef struct _TSS 
 {
     DWORD           Reserved0;
 
@@ -84,7 +81,7 @@ typedef struct _TSS_DESCRIPTOR
 
 } TSS_DESCRIPTOR, *PTSS_DESCRIPTOR;
 STATIC_ASSERT(sizeof(TSS_DESCRIPTOR) == PREDEFINED_TSS_DESC_SIZE);
-#pragma warning(pop)
+#pragma warning(default:4214)
 #pragma pack(pop)
 
 //******************************************************************************
@@ -97,6 +94,7 @@ STATIC_ASSERT(sizeof(TSS_DESCRIPTOR) == PREDEFINED_TSS_DESC_SIZE);
 // Parameter:    IN PVOID StackBase - Stack to use in TSS
 // Parameter:    IN BYTE StackIndex - Index to use for stack
 //******************************************************************************
+SAL_SUCCESS
 STATUS
 TssInstall(
     OUT     PTSS        Tss,
diff --git a/src/HAL/src/_exports.yasm b/src/HAL/src/_exports.yasm
index 693a434..a9c64fa 100644
--- a/src/HAL/src/_exports.yasm
+++ b/src/HAL/src/_exports.yasm
@@ -4,7 +4,6 @@ global __ltr
 global __sgdt
 global __reloadGDT
 global __changeStack
-global __HALreadfsqword
 
 align 0x10, db 0
 [BITS 64]
@@ -100,10 +99,4 @@ __changeStack:
 
     cld
 
-    ret
-
-align 0x10, db 0
-[bits 64]
-__HALreadfsqword:
-    mov rax, [fs:ecx]
-    ret
+    ret
\ No newline at end of file
diff --git a/src/HAL/src/gdt.c b/src/HAL/src/gdt.c
index 89ad938..dcfef6a 100644
--- a/src/HAL/src/gdt.c
+++ b/src/HAL/src/gdt.c
@@ -53,9 +53,9 @@ GdtInstallDescriptor(
     // check if system descriptor
     sysDescriptor = IsBitSet(Flags, SegmentDescriptorSystemDescriptor);
 
-    tssDescriptor = sysDescriptor && ((SystemSegment64BitTssAvailable == Type) || (SystemSegment64BitTssBusy == Type));
+    tssDescriptor = sysDescriptor & ((SystemSegment64BitTssAvailable == Type) || (SystemSegment64BitTssBusy == Type));
 
-    if (sysDescriptor && !tssDescriptor)
+    if (sysDescriptor & !tssDescriptor)
     {
         // we can't install other system descriptors except TSS ones
         return STATUS_INVALID_PARAMETER3;
diff --git a/src/HAL/src/hw_fpu.c b/src/HAL/src/hw_fpu.c
index c70808b..c0d0ac8 100644
--- a/src/HAL/src/hw_fpu.c
+++ b/src/HAL/src/hw_fpu.c
@@ -56,13 +56,11 @@ HalActivateFpu(
     void
     )
 {
-#if INCLUDE_FP_SUPPORT
     // We have nothing here, no commonlib, no runtime support if something
     // goes wrong => we need to halt
     if (!_HalCheckBasicFpuFeatures()) __halt();
 
     _HalEnableFpu();
-#endif
 }
 #pragma optimize( "", on )
 
@@ -120,7 +118,6 @@ HalSetActiveFpuFeatures(
     _In_        XCR0_SAVED_STATE            Features
     )
 {
-#if INCLUDE_FP_SUPPORT
     if (!_HalCheckRequestedFpuFeatures(Features))
     {
         return STATUS_CPU_UNSUPPORTED_FEATURE;
@@ -132,9 +129,6 @@ HalSetActiveFpuFeatures(
     {
         return STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE;
     }
-#else
-    UNREFERENCED_PARAMETER(Features);
-#endif // INCLUDE_FP_SUPPORT
 
     return STATUS_SUCCESS;
 }
@@ -145,7 +139,6 @@ HalGetActiveFpuFeatures(
     _Out_opt_   DWORD*                      AvailableFeaturesSaveSize
     )
 {
-#if INCLUDE_FP_SUPPORT
     if (ActivatedFeaturesSaveSize != NULL || AvailableFeaturesSaveSize != NULL)
     {
         CPUID_INFO cpuidFeatInfo;
@@ -164,10 +157,4 @@ HalGetActiveFpuFeatures(
     }
 
     return _xgetbv(XCR0_INDEX);
-#else
-    if (ActivatedFeaturesSaveSize != NULL) *ActivatedFeaturesSaveSize = 0;
-    if (AvailableFeaturesSaveSize != NULL) *AvailableFeaturesSaveSize = 0;
-
-    return MAX_QWORD;
-#endif // INCLUDE_FP_SUPPORT
 }
diff --git a/src/HAL/src/idt.c b/src/HAL/src/idt.c
index 76ec794..2d2c6ec 100644
--- a/src/HAL/src/idt.c
+++ b/src/HAL/src/idt.c
@@ -7,8 +7,6 @@
 #define PREDEFINED_IDT_ENTRY_SIZE               16
 
 #pragma pack(push,1)
-
-#pragma warning(push)
 //warning C4214: nonstandard extension used : bit field types other than int
 #pragma warning(disable:4214)
 // 6.14.1, Vol 3, No. 56
@@ -24,7 +22,7 @@ typedef struct _IDT_ENTRY
     // IST = Interrupt Stack Table
     // if set to 0 will use legacy stack switching
     // else will use IST entry from TSS
-    WORD            IST                 : 3;
+    WORD            IST                 : 3;    
     WORD            Reserved0           : 5;    // these must be 0 on x64
     WORD            Type                : 4;
     WORD            Reserved1           : 1;    // 0
@@ -35,7 +33,7 @@ typedef struct _IDT_ENTRY
     DWORD           Reserved;
 } IDT_ENTRY, *PIDT_ENTRY;
 STATIC_ASSERT( sizeof( IDT_ENTRY ) == PREDEFINED_IDT_ENTRY_SIZE );
-#pragma warning(pop)
+#pragma warning(default:4214)
 
 typedef struct _IDT
 {
@@ -67,6 +65,7 @@ IdtInitialize(
     IdtReload();
 }
 
+SAL_SUCCESS
 STATUS
 IdtInstallDescriptor(
     IN                  BYTE            InterruptIndex,
diff --git a/src/HAL/src/lapic.c b/src/HAL/src/lapic.c
index 40d571b..a69c6d1 100644
--- a/src/HAL/src/lapic.c
+++ b/src/HAL/src/lapic.c
@@ -66,7 +66,7 @@ LapicSetLogicalApicId(
     ASSERT (NULL != pLapic);
 
     memzero(&ldrRegister, sizeof(LDR_REGISTER));
-
+    
     dfrRegister.Raw = MAX_DWORD;
     dfrRegister.Model = DestinationFormat;
 
@@ -133,11 +133,11 @@ LapicSendEOI(
 void
 LapicSendIpi(
     IN      PVOID                           ApicBaseAddress,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_ID                         ApicId,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_DELIVERY_MODE              DeliveryMode,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_DESTINATION_SHORTHAND      DestinationShorthand,
     IN      _Strict_type_match_
             APIC_DESTINATION_MODE           DestinationMode,
@@ -201,7 +201,7 @@ LapicGetTimerCount(
     pLapic = (PLAPIC)ApicBaseAddress;
 
     ASSERT(NULL != pLapic);
-
+    
     return pLapic->TimerCurrentCount.Value;
 }
 
@@ -209,7 +209,7 @@ void
 LapicConfigureTimer(
     IN      PVOID                           ApicBaseAddress,
     IN      BYTE                            TimerInterruptVector,
-    IN      _Strict_type_match_
+    IN      _Strict_type_match_ 
             APIC_DIVIDE_VALUE               DivideValue
     )
 {
@@ -239,7 +239,7 @@ LapicConfigureTimer(
 }
 
 void
-LapicSetTimerInterval(
+LapicEnableTimer(
     IN      PVOID                           ApicBaseAddress,
     IN      DWORD                           TimerCount
     )
@@ -260,11 +260,11 @@ LapicConfigureLvtRegisters(
     )
 {
     PLAPIC pLapic;
-
+    
     pLapic = (PLAPIC)ApicBaseAddress;
 
     ASSERT(NULL != pLapic);
-
+    
     // configure LINT vectors
     _LapicConfigureLocalInts(pLapic);
 
diff --git a/src/HAL/src/pci.c b/src/HAL/src/pci.c
index 8968b72..c5db1b8 100644
--- a/src/HAL/src/pci.c
+++ b/src/HAL/src/pci.c
@@ -5,22 +5,19 @@
 #define PCI_CONFIG_ADDRESS                              0xCF8
 #define PCI_CONFIG_DATA                                 0xCFC
 
-#pragma pack(push,1)
-
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
+#pragma pack(push,1)
 typedef union _PCI_CONFIG_REGISTER
 {
     struct
     {
-        // Since all reads and writes must be both 32-bits and aligned to work on all
-        // implementations, the two lowest bits of PCI_CONFIG_REGISTER must always be zero,
+        // Since all reads and writes must be both 32-bits and aligned to work on all 
+        // implementations, the two lowest bits of PCI_CONFIG_REGISTER must always be zero, 
         // with the remaining six bits allowing you to choose each of the 64 32-bit words.
         BYTE    __Reserved0                 : 2;
 
@@ -35,9 +32,12 @@ typedef union _PCI_CONFIG_REGISTER
 } PCI_CONFIG_REGISTER, *PPCI_CONFIG_REGISTER;
 STATIC_ASSERT(sizeof(PCI_CONFIG_REGISTER) == sizeof(DWORD));
 
-#pragma warning(pop)
 #pragma pack(pop)
 
+#pragma warning(default:4214)
+
+#pragma warning(default:4201)
+
 #define PCI_SET_CONFIG_REGISTER(X,Bus,Dev,Func,Reg)     \
             memzero(&(X), sizeof(PCI_CONFIG_REGISTER)); \
             (X).EnableBit = 1;                          \
@@ -85,10 +85,11 @@ BOOLEAN
 _PciRetrieveDevice(
     IN      PCI_DEVICE_LOCATION DeviceLocation,
     IN      WORD                BytesToRead,
-    OUT_WRITES_BYTES_ALL(BytesToRead)
+    OUT_WRITES_BYTES_ALL(BytesToRead)     
             PPCI_DEVICE_DESCRIPTION         PciDevice
     );
 
+SAL_SUCCESS
 STATUS
 PciRetrieveNextDevice(
     IN      BOOLEAN         ResetSearch,
@@ -125,7 +126,7 @@ PciRetrieveNextDevice(
         return STATUS_DEVICE_NO_MORE_DEVICES;
     }
 
-    do
+    do 
     {
         foundDevice = _PciRetrieveDevice(__currentDeviceLocation, BytesToRead, PciDevice);
 
@@ -165,7 +166,7 @@ BOOLEAN
 _PciRetrieveDevice(
     IN      PCI_DEVICE_LOCATION DeviceLocation,
     IN      WORD                BytesToRead,
-    OUT_WRITES_BYTES_ALL(BytesToRead)
+    OUT_WRITES_BYTES_ALL(BytesToRead)     
             PPCI_DEVICE_DESCRIPTION         PciDevice
     )
 {
diff --git a/src/HAL/src/pcie.c b/src/HAL/src/pcie.c
index 35a1908..87868e7 100644
--- a/src/HAL/src/pcie.c
+++ b/src/HAL/src/pcie.c
@@ -7,6 +7,7 @@
                                                                            ((QWORD)(Dev)<<15)     + \
                                                                            ((QWORD)(Func)<<12))
 
+SAL_SUCCESS
 STATUS
 PciExpressRetrieveNextDevice(
     IN      PPCI_ROOT_COMPLEX           PciRootComplex,
diff --git a/src/HAL/src/pit.c b/src/HAL/src/pit.c
index 2b5f120..2b76ab0 100644
--- a/src/HAL/src/pit.c
+++ b/src/HAL/src/pit.c
@@ -36,9 +36,6 @@
 #define PIT_COMM_ACCESS_LO_HI                               0x03
 
 #pragma pack(push,1)
-
-#pragma warning(push)
-
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
@@ -47,8 +44,8 @@
 
 typedef union _PIT_COMMAND_REGISTER
 {
-    struct
-    {
+    struct  
+    {    
         BYTE            BcdMode             :   1;
         BYTE            OperatingMode       :   3;
         BYTE            AccessMode          :   2;
@@ -58,7 +55,8 @@ typedef union _PIT_COMMAND_REGISTER
 } PIT_COMMAND_REGISTER, *PPIT_COMMAND_REGISTER;
 STATIC_ASSERT(sizeof(PIT_COMMAND_REGISTER) == sizeof(BYTE));
 
-#pragma warning(pop)
+#pragma warning(default:4201)
+#pragma warning(default:4214)
 #pragma pack(pop)
 
 static
@@ -81,6 +79,7 @@ PitSetTimer(
     IN      BOOLEAN     Periodic
     )
 {
+    BYTE value;
     DWORD initialCount;
 
     ASSERT( 0 != Microseconds && Microseconds <= SEC_IN_US);
@@ -88,13 +87,13 @@ PitSetTimer(
     initialCount = PIT_FREQUENCY_HZ / (SEC_IN_US / Microseconds);
     ASSERT( initialCount <= MAX_WORD);
 
-    if (!Periodic)
-    {
-        BYTE value;
-
-        // get current gate controls
-        value = __inbyte(PIT_CONTROL_REG_PORT);
+    value = 0;
+    
+    // get current gate controls
+    value = __inbyte(PIT_CONTROL_REG_PORT);
 
+    if( !Periodic )
+    {
         // 0xFD is used to disable speaker output (bit #1)
         // bit0 enables channel 2
         __outbyte(PIT_CONTROL_REG_PORT, (value & (~PIT_CONTROL_SPEAKER_OUTPUT)) | PIT_CONTROL_CH2_INPUT);
diff --git a/src/HAL/src/tss.c b/src/HAL/src/tss.c
index 84f5202..434a401 100644
--- a/src/HAL/src/tss.c
+++ b/src/HAL/src/tss.c
@@ -1,6 +1,7 @@
 #include "hal_base.h"
 #include "tss.h"
 
+SAL_SUCCESS
 STATUS
 TssInstall(
     OUT     PTSS        Tss,
diff --git a/src/HAL9000.sln b/src/HAL9000.sln
index f0c83b5..a2f5d01 100644
--- a/src/HAL9000.sln
+++ b/src/HAL9000.sln
@@ -1,7 +1,7 @@
 
 Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.0.30517.126
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL9000", "HAL9000\HAL9000.vcxproj", "{79A21DCA-19AF-4F8E-9B83-62D7CF504104}"
 	ProjectSection(ProjectDependencies) = postProject
@@ -9,7 +9,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL9000", "HAL9000\HAL9000.
 		{9412F640-A271-4661-B437-5932E9B95C26} = {9412F640-A271-4661-B437-5932E9B95C26}
 		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D} = {4DA7677D-D0E7-44EC-B350-F7170E0ED84D}
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A} = {E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E} = {0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1} = {02EC2CAD-C1E9-45FB-96AC-27976A9300F1}
@@ -59,7 +58,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AppHelloWorld", "Usermode\A
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CopyUmAppsToVm", "Usermode\CopyUmAppsToVm\CopyUmAppsToVm.vcxproj", "{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}"
 	ProjectSection(ProjectDependencies) = postProject
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9} = {D4EF4101-8E74-45C4-93B0-1AC3F29399B9}
 		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4} = {A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}
 		{61E34105-4020-4582-9F7C-E86DB0BDD7BD} = {61E34105-4020-4582-9F7C-E86DB0BDD7BD}
 		{F092D608-D31B-4E30-9650-11058BD45093} = {F092D608-D31B-4E30-9650-11058BD45093}
@@ -75,32 +73,23 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CopyUmAppsToVm", "Usermode\
 		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86} = {AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}
 		{89F0CC41-F7A4-46B8-B680-776EA30B3626} = {89F0CC41-F7A4-46B8-B680-776EA30B3626}
 		{D6247145-847F-4337-877E-E5F2ADAF3D37} = {D6247145-847F-4337-877E-E5F2ADAF3D37}
-		{833F5049-D661-4297-842C-D9C9AC8469C0} = {833F5049-D661-4297-842C-D9C9AC8469C0}
 		{30DB9549-4343-4EBC-AC4F-72F98EBD0632} = {30DB9549-4343-4EBC-AC4F-72F98EBD0632}
 		{B3D30950-51C0-44A6-84B3-AFE6203E8851} = {B3D30950-51C0-44A6-84B3-AFE6203E8851}
 		{60070351-33A9-4935-9BA4-8EC021CB47B7} = {60070351-33A9-4935-9BA4-8EC021CB47B7}
-		{E6B41356-895B-419D-93A4-8746C086F7E8} = {E6B41356-895B-419D-93A4-8746C086F7E8}
-		{D6919C57-7503-4F41-914E-4F0A5642D795} = {D6919C57-7503-4F41-914E-4F0A5642D795}
 		{752C9059-8C84-4FFD-938A-055E76E6BD2D} = {752C9059-8C84-4FFD-938A-055E76E6BD2D}
 		{E757415D-952B-41EB-91D2-678ED2A21241} = {E757415D-952B-41EB-91D2-678ED2A21241}
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39} = {2BF11960-6B4A-46CE-92C0-21C30FF1AB39}
 		{31D6EE61-177E-4CFB-A8E6-B16015C12E04} = {31D6EE61-177E-4CFB-A8E6-B16015C12E04}
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2} = {A2CF4462-C6E6-441B-ADD4-352E0D0871B2}
 		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B} = {9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}
 		{6505AA65-A3C0-4792-BDEE-0E7BE0425639} = {6505AA65-A3C0-4792-BDEE-0E7BE0425639}
 		{D157B165-F35B-4D6A-B23D-90596B0328FD} = {D157B165-F35B-4D6A-B23D-90596B0328FD}
 		{5E6E5E67-1760-4744-8483-478B41F5D3E2} = {5E6E5E67-1760-4744-8483-478B41F5D3E2}
-		{E1BC4F68-4192-4408-B94D-B161C6133C73} = {E1BC4F68-4192-4408-B94D-B161C6133C73}
-		{73243670-829F-4E0C-B332-EC673749FAD4} = {73243670-829F-4E0C-B332-EC673749FAD4}
 		{5BFAEE74-425B-49C9-BC09-BD0B9081E696} = {5BFAEE74-425B-49C9-BC09-BD0B9081E696}
 		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890} = {DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}
 		{54AE077D-560D-4FCC-97BA-D357CCF9A482} = {54AE077D-560D-4FCC-97BA-D357CCF9A482}
 		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83} = {45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B} = {D61D8289-38BD-4CC1-B943-A53C2DCD800B}
 		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9} = {FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}
 		{638AD489-3390-414F-8931-ABBB7CEED92D} = {638AD489-3390-414F-8931-ABBB7CEED92D}
 		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2} = {DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A} = {2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}
 		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8} = {79DDA691-0EEA-4658-8372-E6B1C2E77FE8}
 		{F5B97493-5840-4D09-88D7-44CB0C4E0677} = {F5B97493-5840-4D09-88D7-44CB0C4E0677}
 		{F6B76094-CB73-463F-8FAA-794214EC3621} = {F6B76094-CB73-463F-8FAA-794214EC3621}
@@ -117,23 +106,15 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CopyUmAppsToVm", "Usermode\
 		{357100B6-0650-44F2-9BB6-F3337249D714} = {357100B6-0650-44F2-9BB6-F3337249D714}
 		{758FCEB9-B595-4827-8B74-44B96E668B5E} = {758FCEB9-B595-4827-8B74-44B96E668B5E}
 		{837D6ABA-2C74-4163-9D85-4E78D52883E4} = {837D6ABA-2C74-4163-9D85-4E78D52883E4}
-		{0B6872BE-9637-45B8-8404-287173BF8B35} = {0B6872BE-9637-45B8-8404-287173BF8B35}
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0} = {F91940C3-0684-4512-B3C1-D68ECEA7D4E0}
 		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F} = {59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}
-		{2C3203CA-606A-4748-9859-06D6545DD166} = {2C3203CA-606A-4748-9859-06D6545DD166}
 		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A} = {39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42} = {F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}
 		{4F0011CD-9DDB-43C2-8555-5928F3BE8196} = {4F0011CD-9DDB-43C2-8555-5928F3BE8196}
 		{88595ECD-557E-4B04-A510-76D670899876} = {88595ECD-557E-4B04-A510-76D670899876}
 		{E16F11CF-443B-4A4E-ADC4-7B224867BA99} = {E16F11CF-443B-4A4E-ADC4-7B224867BA99}
 		{1983BDD5-FB4A-4400-9D69-CD8156541622} = {1983BDD5-FB4A-4400-9D69-CD8156541622}
 		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97} = {46B6D3D5-1320-42E8-97EB-E91CF0C47B97}
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7} = {FC4360D9-B78C-4CD3-82EE-67877E091EC7}
 		{34D1EFDE-5F45-462F-A610-F925822F10BE} = {34D1EFDE-5F45-462F-A610-F925822F10BE}
 		{818797E2-6CDC-41D4-8BCF-03A670BA33F9} = {818797E2-6CDC-41D4-8BCF-03A670BA33F9}
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A} = {30A04CE4-0907-4357-A8CB-BAF5D7FB463A}
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D} = {C26BFEEE-6078-400E-AD95-CC25B351BA4D}
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7} = {7A3F18F0-B375-4A08-B944-AC7148793AE7}
 		{1DD3D1FA-62BB-47AD-B04C-853F278B8722} = {1DD3D1FA-62BB-47AD-B04C-853F278B8722}
 		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61} = {858F4EFC-1C02-402A-ADEE-4E40DEE20B61}
 		{A995D9FC-DBB6-4178-A067-21FBA8364CD3} = {A995D9FC-DBB6-4178-A067-21FBA8364CD3}
@@ -462,782 +443,307 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadWaitTerminated", "Use
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLib", "CommonLib\CommonLib.vcxproj", "{CA44C37A-1730-447F-8975-3DF40D559310}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapFS", "SwapFS\SwapFS.vcxproj", "{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}"
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "syscalls", "syscalls", "{BFB23853-6940-4444-89C7-5364AD6AD41C}"
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Userprog", "Userprog", "{6E6A08BF-A678-4239-8310-48844D3AFB56}"
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Virtual Memory", "Virtual Memory", "{A08E6F21-0543-4984-8E84-A80E6C11A582}"
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "process-quota", "process-quota", "{699EC88B-CEE0-40E4-9F98-1409E0FCE305}"
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "swap", "swap", "{AC31B304-896F-4AA6-BDDC-548E89A4E90E}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocNormal", "Usermode\VirtualAllocNormal\VirtualAllocNormal.vcxproj", "{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocAccessFail", "Usermode\VirtualAllocAccessFail\VirtualAllocAccessFail.vcxproj", "{E1BC4F68-4192-4408-B94D-B161C6133C73}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocHugeLazy", "Usermode\VirtualAllocHugeLazy\VirtualAllocHugeLazy.vcxproj", "{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocHugeEager", "Usermode\VirtualAllocHugeEager\VirtualAllocHugeEager.vcxproj", "{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocZeros", "Usermode\VirtualAllocZeros\VirtualAllocZeros.vcxproj", "{C26BFEEE-6078-400E-AD95-CC25B351BA4D}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocWriteExec", "Usermode\VirtualAllocWriteExec\VirtualAllocWriteExec.vcxproj", "{D6919C57-7503-4F41-914E-4F0A5642D795}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualFreeInvalid", "Usermode\VirtualFreeInvalid\VirtualFreeInvalid.vcxproj", "{833F5049-D661-4297-842C-D9C9AC8469C0}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualFreeMore", "Usermode\VirtualFreeMore\VirtualFreeMore.vcxproj", "{E6B41356-895B-419D-93A4-8746C086F7E8}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualSharedNormal", "Usermode\VirtualSharedNormal\VirtualSharedNormal.vcxproj", "{0B6872BE-9637-45B8-8404-287173BF8B35}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessQuotaJustRight", "Usermode\ProcessQuotaJustRight\ProcessQuotaJustRight.vcxproj", "{73243670-829F-4E0C-B332-EC673749FAD4}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessQuotaMore", "Usermode\ProcessQuotaMore\ProcessQuotaMore.vcxproj", "{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessQuotaGood", "Usermode\ProcessQuotaGood\ProcessQuotaGood.vcxproj", "{2C3203CA-606A-4748-9859-06D6545DD166}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapZeros", "Usermode\SwapZeros\SwapZeros.vcxproj", "{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapZerosWritten", "Usermode\SwapZerosWritten\SwapZerosWritten.vcxproj", "{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapLinear", "Usermode\SwapLinear\SwapLinear.vcxproj", "{D61D8289-38BD-4CC1-B943-A53C2DCD800B}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapMultipleShared", "Usermode\SwapMultipleShared\SwapMultipleShared.vcxproj", "{FC4360D9-B78C-4CD3-82EE-67877E091EC7}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLibUnitTests", "CommonLibUnitTests\CommonLibUnitTests.vcxproj", "{098EB03E-8151-46DB-9052-5136D9BC14EA}"
-	ProjectSection(ProjectDependencies) = postProject
-		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StackGrowthRecursiveFunction", "Usermode\StackGrowthRecursiveFunction\StackGrowthRecursiveFunction.vcxproj", "{7A3F18F0-B375-4A08-B944-AC7148793AE7}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "stack-growth", "stack-growth", "{159880E4-3D75-48CB-B113-A2D217CE423C}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StackGrowthVariables", "Usermode\StackGrowthVariables\StackGrowthVariables.vcxproj", "{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
-	EndProjectSection
-EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		CommonLibTests|x64 = CommonLibTests|x64
 		Threads|x64 = Threads|x64
 		Userprog|x64 = Userprog|x64
-		VirtualMemory|x64 = VirtualMemory|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.ActiveCfg = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.Build.0 = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.ActiveCfg = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.Build.0 = Debug|x64
-		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.VirtualMemory|x64.Build.0 = Debug|x64
-		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.ActiveCfg = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.Build.0 = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.ActiveCfg = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.Build.0 = Debug|x64
-		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.VirtualMemory|x64.Build.0 = Debug|x64
-		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.ActiveCfg = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.Build.0 = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.ActiveCfg = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.Build.0 = Debug|x64
-		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.VirtualMemory|x64.Build.0 = Debug|x64
-		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.ActiveCfg = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.Build.0 = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.ActiveCfg = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.Build.0 = Debug|x64
-		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.VirtualMemory|x64.Build.0 = Debug|x64
-		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.ActiveCfg = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.Build.0 = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.ActiveCfg = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.Build.0 = Debug|x64
-		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.VirtualMemory|x64.Build.0 = Debug|x64
-		{9412F640-A271-4661-B437-5932E9B95C26}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.ActiveCfg = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.Build.0 = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.ActiveCfg = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.Build.0 = Debug|x64
-		{9412F640-A271-4661-B437-5932E9B95C26}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{9412F640-A271-4661-B437-5932E9B95C26}.VirtualMemory|x64.Build.0 = Debug|x64
-		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.ActiveCfg = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.Build.0 = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.ActiveCfg = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.Build.0 = Debug|x64
-		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.VirtualMemory|x64.Build.0 = Debug|x64
-		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.ActiveCfg = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.Build.0 = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.ActiveCfg = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.Build.0 = Debug|x64
-		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.VirtualMemory|x64.Build.0 = Debug|x64
-		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.ActiveCfg = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.Build.0 = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.ActiveCfg = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.Build.0 = Debug|x64
-		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.VirtualMemory|x64.Build.0 = Debug|x64
-		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.ActiveCfg = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.Build.0 = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.ActiveCfg = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.Build.0 = Debug|x64
-		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.VirtualMemory|x64.Build.0 = Debug|x64
-		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Threads|x64.ActiveCfg = Debug|x64
 		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Threads|x64.Build.0 = Debug|x64
 		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Userprog|x64.ActiveCfg = Debug|x64
 		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Userprog|x64.Build.0 = Debug|x64
-		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.VirtualMemory|x64.Build.0 = Debug|x64
-		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.Threads|x64.ActiveCfg = Debug|x64
 		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.Userprog|x64.ActiveCfg = Debug|x64
 		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.Userprog|x64.Build.0 = Debug|x64
-		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.VirtualMemory|x64.Build.0 = Debug|x64
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Threads|x64.ActiveCfg = Debug|x64
 		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Threads|x64.Build.0 = Debug|x64
 		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Userprog|x64.ActiveCfg = Debug|x64
 		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Userprog|x64.Build.0 = Debug|x64
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.VirtualMemory|x64.Build.0 = Debug|x64
-		{291C9D17-6BA7-404F-8664-C60F38E061C7}.CommonLibTests|x64.ActiveCfg = Userprog|x64
 		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Threads|x64.ActiveCfg = Threads|x64
 		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Userprog|x64.ActiveCfg = Userprog|x64
-		{291C9D17-6BA7-404F-8664-C60F38E061C7}.VirtualMemory|x64.ActiveCfg = VirtualMemory|x64
-		{6CAFB378-993C-4078-B545-9D8636F383DC}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{6CAFB378-993C-4078-B545-9D8636F383DC}.Threads|x64.ActiveCfg = Debug|x64
 		{6CAFB378-993C-4078-B545-9D8636F383DC}.Userprog|x64.ActiveCfg = Debug|x64
-		{6CAFB378-993C-4078-B545-9D8636F383DC}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Threads|x64.ActiveCfg = Debug|x64
 		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Threads|x64.Build.0 = Debug|x64
 		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Userprog|x64.ActiveCfg = Debug|x64
 		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Userprog|x64.Build.0 = Debug|x64
-		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.VirtualMemory|x64.Build.0 = Debug|x64
-		{638AD489-3390-414F-8931-ABBB7CEED92D}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{638AD489-3390-414F-8931-ABBB7CEED92D}.Threads|x64.ActiveCfg = Debug|x64
 		{638AD489-3390-414F-8931-ABBB7CEED92D}.Threads|x64.Build.0 = Debug|x64
 		{638AD489-3390-414F-8931-ABBB7CEED92D}.Userprog|x64.ActiveCfg = Debug|x64
 		{638AD489-3390-414F-8931-ABBB7CEED92D}.Userprog|x64.Build.0 = Debug|x64
-		{638AD489-3390-414F-8931-ABBB7CEED92D}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{638AD489-3390-414F-8931-ABBB7CEED92D}.VirtualMemory|x64.Build.0 = Debug|x64
-		{F092D608-D31B-4E30-9650-11058BD45093}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{F092D608-D31B-4E30-9650-11058BD45093}.Threads|x64.ActiveCfg = Debug|x64
 		{F092D608-D31B-4E30-9650-11058BD45093}.Threads|x64.Build.0 = Debug|x64
 		{F092D608-D31B-4E30-9650-11058BD45093}.Userprog|x64.ActiveCfg = Debug|x64
 		{F092D608-D31B-4E30-9650-11058BD45093}.Userprog|x64.Build.0 = Debug|x64
-		{F092D608-D31B-4E30-9650-11058BD45093}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{F092D608-D31B-4E30-9650-11058BD45093}.VirtualMemory|x64.Build.0 = Debug|x64
-		{D127B5B4-F60E-4436-B663-45404E95BB97}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{D127B5B4-F60E-4436-B663-45404E95BB97}.Threads|x64.ActiveCfg = Debug|x64
 		{D127B5B4-F60E-4436-B663-45404E95BB97}.Threads|x64.Build.0 = Debug|x64
 		{D127B5B4-F60E-4436-B663-45404E95BB97}.Userprog|x64.ActiveCfg = Debug|x64
 		{D127B5B4-F60E-4436-B663-45404E95BB97}.Userprog|x64.Build.0 = Debug|x64
-		{D127B5B4-F60E-4436-B663-45404E95BB97}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{D127B5B4-F60E-4436-B663-45404E95BB97}.VirtualMemory|x64.Build.0 = Debug|x64
-		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Threads|x64.ActiveCfg = Debug|x64
 		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Threads|x64.Build.0 = Debug|x64
 		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Userprog|x64.ActiveCfg = Debug|x64
 		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Userprog|x64.Build.0 = Debug|x64
-		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.VirtualMemory|x64.Build.0 = Debug|x64
-		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Threads|x64.ActiveCfg = Debug|x64
 		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Threads|x64.Build.0 = Debug|x64
 		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Userprog|x64.ActiveCfg = Debug|x64
 		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Userprog|x64.Build.0 = Debug|x64
-		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.VirtualMemory|x64.Build.0 = Debug|x64
-		{F6B76094-CB73-463F-8FAA-794214EC3621}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{F6B76094-CB73-463F-8FAA-794214EC3621}.Threads|x64.ActiveCfg = Debug|x64
 		{F6B76094-CB73-463F-8FAA-794214EC3621}.Threads|x64.Build.0 = Debug|x64
 		{F6B76094-CB73-463F-8FAA-794214EC3621}.Userprog|x64.ActiveCfg = Debug|x64
 		{F6B76094-CB73-463F-8FAA-794214EC3621}.Userprog|x64.Build.0 = Debug|x64
-		{F6B76094-CB73-463F-8FAA-794214EC3621}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{F6B76094-CB73-463F-8FAA-794214EC3621}.VirtualMemory|x64.Build.0 = Debug|x64
-		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Threads|x64.ActiveCfg = Debug|x64
 		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Threads|x64.Build.0 = Debug|x64
 		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Userprog|x64.ActiveCfg = Debug|x64
 		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Userprog|x64.Build.0 = Debug|x64
-		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.VirtualMemory|x64.Build.0 = Debug|x64
-		{88595ECD-557E-4B04-A510-76D670899876}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{88595ECD-557E-4B04-A510-76D670899876}.Threads|x64.ActiveCfg = Debug|x64
 		{88595ECD-557E-4B04-A510-76D670899876}.Threads|x64.Build.0 = Debug|x64
 		{88595ECD-557E-4B04-A510-76D670899876}.Userprog|x64.ActiveCfg = Debug|x64
 		{88595ECD-557E-4B04-A510-76D670899876}.Userprog|x64.Build.0 = Debug|x64
-		{88595ECD-557E-4B04-A510-76D670899876}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{88595ECD-557E-4B04-A510-76D670899876}.VirtualMemory|x64.Build.0 = Debug|x64
-		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Threads|x64.ActiveCfg = Debug|x64
 		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Threads|x64.Build.0 = Debug|x64
 		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Userprog|x64.ActiveCfg = Debug|x64
 		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Userprog|x64.Build.0 = Debug|x64
-		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.VirtualMemory|x64.Build.0 = Debug|x64
-		{D28E7F99-B199-4953-BB56-4F6574763A52}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{D28E7F99-B199-4953-BB56-4F6574763A52}.Threads|x64.ActiveCfg = Debug|x64
 		{D28E7F99-B199-4953-BB56-4F6574763A52}.Threads|x64.Build.0 = Debug|x64
 		{D28E7F99-B199-4953-BB56-4F6574763A52}.Userprog|x64.ActiveCfg = Debug|x64
 		{D28E7F99-B199-4953-BB56-4F6574763A52}.Userprog|x64.Build.0 = Debug|x64
-		{D28E7F99-B199-4953-BB56-4F6574763A52}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{D28E7F99-B199-4953-BB56-4F6574763A52}.VirtualMemory|x64.Build.0 = Debug|x64
-		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Threads|x64.ActiveCfg = Debug|x64
 		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Threads|x64.Build.0 = Debug|x64
 		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Userprog|x64.ActiveCfg = Debug|x64
 		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Userprog|x64.Build.0 = Debug|x64
-		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.VirtualMemory|x64.Build.0 = Debug|x64
-		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Threads|x64.ActiveCfg = Debug|x64
 		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Threads|x64.Build.0 = Debug|x64
 		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Userprog|x64.ActiveCfg = Debug|x64
 		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Userprog|x64.Build.0 = Debug|x64
-		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.VirtualMemory|x64.Build.0 = Debug|x64
-		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Threads|x64.ActiveCfg = Debug|x64
 		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Threads|x64.Build.0 = Debug|x64
 		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Userprog|x64.ActiveCfg = Debug|x64
 		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Userprog|x64.Build.0 = Debug|x64
-		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.VirtualMemory|x64.Build.0 = Debug|x64
-		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Threads|x64.ActiveCfg = Debug|x64
 		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Threads|x64.Build.0 = Debug|x64
 		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Userprog|x64.ActiveCfg = Debug|x64
 		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Userprog|x64.Build.0 = Debug|x64
-		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.VirtualMemory|x64.Build.0 = Debug|x64
-		{D6247145-847F-4337-877E-E5F2ADAF3D37}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Threads|x64.ActiveCfg = Debug|x64
 		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Threads|x64.Build.0 = Debug|x64
 		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Userprog|x64.ActiveCfg = Debug|x64
 		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Userprog|x64.Build.0 = Debug|x64
-		{D6247145-847F-4337-877E-E5F2ADAF3D37}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{D6247145-847F-4337-877E-E5F2ADAF3D37}.VirtualMemory|x64.Build.0 = Debug|x64
-		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Threads|x64.ActiveCfg = Debug|x64
 		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Threads|x64.Build.0 = Debug|x64
 		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Userprog|x64.ActiveCfg = Debug|x64
 		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Userprog|x64.Build.0 = Debug|x64
-		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.VirtualMemory|x64.Build.0 = Debug|x64
-		{758FCEB9-B595-4827-8B74-44B96E668B5E}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Threads|x64.ActiveCfg = Debug|x64
 		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Threads|x64.Build.0 = Debug|x64
 		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Userprog|x64.ActiveCfg = Debug|x64
 		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Userprog|x64.Build.0 = Debug|x64
-		{758FCEB9-B595-4827-8B74-44B96E668B5E}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{758FCEB9-B595-4827-8B74-44B96E668B5E}.VirtualMemory|x64.Build.0 = Debug|x64
-		{7A6D1E11-2D94-4154-8147-153427DA2E98}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Threads|x64.ActiveCfg = Debug|x64
 		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Threads|x64.Build.0 = Debug|x64
 		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Userprog|x64.ActiveCfg = Debug|x64
 		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Userprog|x64.Build.0 = Debug|x64
-		{7A6D1E11-2D94-4154-8147-153427DA2E98}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{7A6D1E11-2D94-4154-8147-153427DA2E98}.VirtualMemory|x64.Build.0 = Debug|x64
-		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Threads|x64.ActiveCfg = Debug|x64
 		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Threads|x64.Build.0 = Debug|x64
 		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Userprog|x64.ActiveCfg = Debug|x64
 		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Userprog|x64.Build.0 = Debug|x64
-		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.VirtualMemory|x64.Build.0 = Debug|x64
-		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Threads|x64.ActiveCfg = Debug|x64
 		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Threads|x64.Build.0 = Debug|x64
 		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Userprog|x64.ActiveCfg = Debug|x64
 		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Userprog|x64.Build.0 = Debug|x64
-		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.VirtualMemory|x64.Build.0 = Debug|x64
-		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Threads|x64.ActiveCfg = Debug|x64
 		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Threads|x64.Build.0 = Debug|x64
 		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Userprog|x64.ActiveCfg = Debug|x64
 		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Userprog|x64.Build.0 = Debug|x64
-		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.VirtualMemory|x64.Build.0 = Debug|x64
-		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Threads|x64.ActiveCfg = Debug|x64
 		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Threads|x64.Build.0 = Debug|x64
 		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Userprog|x64.ActiveCfg = Debug|x64
 		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Userprog|x64.Build.0 = Debug|x64
-		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.VirtualMemory|x64.Build.0 = Debug|x64
-		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Threads|x64.ActiveCfg = Debug|x64
 		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Threads|x64.Build.0 = Debug|x64
 		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Userprog|x64.ActiveCfg = Debug|x64
 		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Userprog|x64.Build.0 = Debug|x64
-		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.VirtualMemory|x64.Build.0 = Debug|x64
-		{4088C233-7226-4098-9711-23D48000C2B8}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{4088C233-7226-4098-9711-23D48000C2B8}.Threads|x64.ActiveCfg = Debug|x64
 		{4088C233-7226-4098-9711-23D48000C2B8}.Threads|x64.Build.0 = Debug|x64
 		{4088C233-7226-4098-9711-23D48000C2B8}.Userprog|x64.ActiveCfg = Debug|x64
 		{4088C233-7226-4098-9711-23D48000C2B8}.Userprog|x64.Build.0 = Debug|x64
-		{4088C233-7226-4098-9711-23D48000C2B8}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{4088C233-7226-4098-9711-23D48000C2B8}.VirtualMemory|x64.Build.0 = Debug|x64
-		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Threads|x64.ActiveCfg = Debug|x64
 		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Threads|x64.Build.0 = Debug|x64
 		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Userprog|x64.ActiveCfg = Debug|x64
 		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Userprog|x64.Build.0 = Debug|x64
-		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.VirtualMemory|x64.Build.0 = Debug|x64
-		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Threads|x64.ActiveCfg = Debug|x64
 		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Threads|x64.Build.0 = Debug|x64
 		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Userprog|x64.ActiveCfg = Debug|x64
 		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Userprog|x64.Build.0 = Debug|x64
-		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.VirtualMemory|x64.Build.0 = Debug|x64
-		{60070351-33A9-4935-9BA4-8EC021CB47B7}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Threads|x64.ActiveCfg = Debug|x64
 		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Threads|x64.Build.0 = Debug|x64
 		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Userprog|x64.ActiveCfg = Debug|x64
 		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Userprog|x64.Build.0 = Debug|x64
-		{60070351-33A9-4935-9BA4-8EC021CB47B7}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{60070351-33A9-4935-9BA4-8EC021CB47B7}.VirtualMemory|x64.Build.0 = Debug|x64
-		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Threads|x64.ActiveCfg = Debug|x64
 		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Threads|x64.Build.0 = Debug|x64
 		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Userprog|x64.ActiveCfg = Debug|x64
 		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Userprog|x64.Build.0 = Debug|x64
-		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.VirtualMemory|x64.Build.0 = Debug|x64
-		{34D1EFDE-5F45-462F-A610-F925822F10BE}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Threads|x64.ActiveCfg = Debug|x64
 		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Threads|x64.Build.0 = Debug|x64
 		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Userprog|x64.ActiveCfg = Debug|x64
 		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Userprog|x64.Build.0 = Debug|x64
-		{34D1EFDE-5F45-462F-A610-F925822F10BE}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{34D1EFDE-5F45-462F-A610-F925822F10BE}.VirtualMemory|x64.Build.0 = Debug|x64
-		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Threads|x64.ActiveCfg = Debug|x64
 		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Threads|x64.Build.0 = Debug|x64
 		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Userprog|x64.ActiveCfg = Debug|x64
 		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Userprog|x64.Build.0 = Debug|x64
-		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.VirtualMemory|x64.Build.0 = Debug|x64
-		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Threads|x64.ActiveCfg = Debug|x64
 		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Threads|x64.Build.0 = Debug|x64
 		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Userprog|x64.ActiveCfg = Debug|x64
 		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Userprog|x64.Build.0 = Debug|x64
-		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.VirtualMemory|x64.Build.0 = Debug|x64
-		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Threads|x64.ActiveCfg = Debug|x64
 		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Threads|x64.Build.0 = Debug|x64
 		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Userprog|x64.ActiveCfg = Debug|x64
 		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Userprog|x64.Build.0 = Debug|x64
-		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.VirtualMemory|x64.Build.0 = Debug|x64
-		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Threads|x64.ActiveCfg = Debug|x64
 		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Threads|x64.Build.0 = Debug|x64
 		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Userprog|x64.ActiveCfg = Debug|x64
 		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Userprog|x64.Build.0 = Debug|x64
-		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.VirtualMemory|x64.Build.0 = Debug|x64
-		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Threads|x64.ActiveCfg = Debug|x64
 		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Threads|x64.Build.0 = Debug|x64
 		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Userprog|x64.ActiveCfg = Debug|x64
 		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Userprog|x64.Build.0 = Debug|x64
-		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.VirtualMemory|x64.Build.0 = Debug|x64
-		{CEF377B2-DE01-4858-B831-4B698952B5C8}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Threads|x64.ActiveCfg = Debug|x64
 		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Threads|x64.Build.0 = Debug|x64
 		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Userprog|x64.ActiveCfg = Debug|x64
 		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Userprog|x64.Build.0 = Debug|x64
-		{CEF377B2-DE01-4858-B831-4B698952B5C8}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{CEF377B2-DE01-4858-B831-4B698952B5C8}.VirtualMemory|x64.Build.0 = Debug|x64
-		{0D8D80A1-E274-401D-BDED-928A315700D7}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{0D8D80A1-E274-401D-BDED-928A315700D7}.Threads|x64.ActiveCfg = Debug|x64
 		{0D8D80A1-E274-401D-BDED-928A315700D7}.Threads|x64.Build.0 = Debug|x64
 		{0D8D80A1-E274-401D-BDED-928A315700D7}.Userprog|x64.ActiveCfg = Debug|x64
 		{0D8D80A1-E274-401D-BDED-928A315700D7}.Userprog|x64.Build.0 = Debug|x64
-		{0D8D80A1-E274-401D-BDED-928A315700D7}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{0D8D80A1-E274-401D-BDED-928A315700D7}.VirtualMemory|x64.Build.0 = Debug|x64
-		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Threads|x64.ActiveCfg = Debug|x64
 		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Threads|x64.Build.0 = Debug|x64
 		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Userprog|x64.ActiveCfg = Debug|x64
 		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Userprog|x64.Build.0 = Debug|x64
-		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.VirtualMemory|x64.Build.0 = Debug|x64
-		{357100B6-0650-44F2-9BB6-F3337249D714}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{357100B6-0650-44F2-9BB6-F3337249D714}.Threads|x64.ActiveCfg = Debug|x64
 		{357100B6-0650-44F2-9BB6-F3337249D714}.Threads|x64.Build.0 = Debug|x64
 		{357100B6-0650-44F2-9BB6-F3337249D714}.Userprog|x64.ActiveCfg = Debug|x64
 		{357100B6-0650-44F2-9BB6-F3337249D714}.Userprog|x64.Build.0 = Debug|x64
-		{357100B6-0650-44F2-9BB6-F3337249D714}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{357100B6-0650-44F2-9BB6-F3337249D714}.VirtualMemory|x64.Build.0 = Debug|x64
-		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Threads|x64.ActiveCfg = Debug|x64
 		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Threads|x64.Build.0 = Debug|x64
 		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Userprog|x64.ActiveCfg = Debug|x64
 		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Userprog|x64.Build.0 = Debug|x64
-		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.VirtualMemory|x64.Build.0 = Debug|x64
-		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Threads|x64.ActiveCfg = Debug|x64
 		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Threads|x64.Build.0 = Debug|x64
 		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Userprog|x64.ActiveCfg = Debug|x64
 		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Userprog|x64.Build.0 = Debug|x64
-		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.VirtualMemory|x64.Build.0 = Debug|x64
-		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Threads|x64.ActiveCfg = Debug|x64
 		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Threads|x64.Build.0 = Debug|x64
 		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Userprog|x64.ActiveCfg = Debug|x64
 		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Userprog|x64.Build.0 = Debug|x64
-		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.VirtualMemory|x64.Build.0 = Debug|x64
-		{CA491A14-A976-4C84-8530-C72974026FCE}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{CA491A14-A976-4C84-8530-C72974026FCE}.Threads|x64.ActiveCfg = Debug|x64
 		{CA491A14-A976-4C84-8530-C72974026FCE}.Threads|x64.Build.0 = Debug|x64
 		{CA491A14-A976-4C84-8530-C72974026FCE}.Userprog|x64.ActiveCfg = Debug|x64
 		{CA491A14-A976-4C84-8530-C72974026FCE}.Userprog|x64.Build.0 = Debug|x64
-		{CA491A14-A976-4C84-8530-C72974026FCE}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{CA491A14-A976-4C84-8530-C72974026FCE}.VirtualMemory|x64.Build.0 = Debug|x64
-		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Threads|x64.ActiveCfg = Debug|x64
 		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Threads|x64.Build.0 = Debug|x64
 		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Userprog|x64.ActiveCfg = Debug|x64
 		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Userprog|x64.Build.0 = Debug|x64
-		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.VirtualMemory|x64.Build.0 = Debug|x64
-		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Threads|x64.ActiveCfg = Debug|x64
 		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Threads|x64.Build.0 = Debug|x64
 		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Userprog|x64.ActiveCfg = Debug|x64
 		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Userprog|x64.Build.0 = Debug|x64
-		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.VirtualMemory|x64.Build.0 = Debug|x64
-		{D157B165-F35B-4D6A-B23D-90596B0328FD}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Threads|x64.ActiveCfg = Debug|x64
 		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Threads|x64.Build.0 = Debug|x64
 		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Userprog|x64.ActiveCfg = Debug|x64
 		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Userprog|x64.Build.0 = Debug|x64
-		{D157B165-F35B-4D6A-B23D-90596B0328FD}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{D157B165-F35B-4D6A-B23D-90596B0328FD}.VirtualMemory|x64.Build.0 = Debug|x64
-		{E757415D-952B-41EB-91D2-678ED2A21241}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{E757415D-952B-41EB-91D2-678ED2A21241}.Threads|x64.ActiveCfg = Debug|x64
 		{E757415D-952B-41EB-91D2-678ED2A21241}.Threads|x64.Build.0 = Debug|x64
 		{E757415D-952B-41EB-91D2-678ED2A21241}.Userprog|x64.ActiveCfg = Debug|x64
 		{E757415D-952B-41EB-91D2-678ED2A21241}.Userprog|x64.Build.0 = Debug|x64
-		{E757415D-952B-41EB-91D2-678ED2A21241}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{E757415D-952B-41EB-91D2-678ED2A21241}.VirtualMemory|x64.Build.0 = Debug|x64
-		{8853A519-4E05-429D-A2A1-911BACE363C6}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{8853A519-4E05-429D-A2A1-911BACE363C6}.Threads|x64.ActiveCfg = Debug|x64
 		{8853A519-4E05-429D-A2A1-911BACE363C6}.Threads|x64.Build.0 = Debug|x64
 		{8853A519-4E05-429D-A2A1-911BACE363C6}.Userprog|x64.ActiveCfg = Debug|x64
 		{8853A519-4E05-429D-A2A1-911BACE363C6}.Userprog|x64.Build.0 = Debug|x64
-		{8853A519-4E05-429D-A2A1-911BACE363C6}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{8853A519-4E05-429D-A2A1-911BACE363C6}.VirtualMemory|x64.Build.0 = Debug|x64
-		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Threads|x64.ActiveCfg = Debug|x64
 		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Threads|x64.Build.0 = Debug|x64
 		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Userprog|x64.ActiveCfg = Debug|x64
 		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Userprog|x64.Build.0 = Debug|x64
-		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.VirtualMemory|x64.Build.0 = Debug|x64
-		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Threads|x64.ActiveCfg = Debug|x64
 		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Threads|x64.Build.0 = Debug|x64
 		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Userprog|x64.ActiveCfg = Debug|x64
 		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Userprog|x64.Build.0 = Debug|x64
-		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.VirtualMemory|x64.Build.0 = Debug|x64
-		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Threads|x64.ActiveCfg = Debug|x64
 		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Threads|x64.Build.0 = Debug|x64
 		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Userprog|x64.ActiveCfg = Debug|x64
 		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Userprog|x64.Build.0 = Debug|x64
-		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.VirtualMemory|x64.Build.0 = Debug|x64
-		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Threads|x64.ActiveCfg = Debug|x64
 		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Threads|x64.Build.0 = Debug|x64
 		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Userprog|x64.ActiveCfg = Debug|x64
 		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Userprog|x64.Build.0 = Debug|x64
-		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.VirtualMemory|x64.Build.0 = Debug|x64
-		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Threads|x64.ActiveCfg = Debug|x64
 		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Threads|x64.Build.0 = Debug|x64
 		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Userprog|x64.ActiveCfg = Debug|x64
 		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Userprog|x64.Build.0 = Debug|x64
-		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.VirtualMemory|x64.Build.0 = Debug|x64
-		{1983BDD5-FB4A-4400-9D69-CD8156541622}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Threads|x64.ActiveCfg = Debug|x64
 		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Threads|x64.Build.0 = Debug|x64
 		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Userprog|x64.ActiveCfg = Debug|x64
 		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Userprog|x64.Build.0 = Debug|x64
-		{1983BDD5-FB4A-4400-9D69-CD8156541622}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{1983BDD5-FB4A-4400-9D69-CD8156541622}.VirtualMemory|x64.Build.0 = Debug|x64
-		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Threads|x64.ActiveCfg = Debug|x64
 		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Threads|x64.Build.0 = Debug|x64
 		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Userprog|x64.ActiveCfg = Debug|x64
 		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Userprog|x64.Build.0 = Debug|x64
-		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.VirtualMemory|x64.Build.0 = Debug|x64
-		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Threads|x64.ActiveCfg = Debug|x64
 		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Threads|x64.Build.0 = Debug|x64
 		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Userprog|x64.ActiveCfg = Debug|x64
 		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Userprog|x64.Build.0 = Debug|x64
-		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.VirtualMemory|x64.Build.0 = Debug|x64
-		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Threads|x64.ActiveCfg = Debug|x64
 		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Threads|x64.Build.0 = Debug|x64
 		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Userprog|x64.ActiveCfg = Debug|x64
 		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Userprog|x64.Build.0 = Debug|x64
-		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.VirtualMemory|x64.Build.0 = Debug|x64
-		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Threads|x64.ActiveCfg = Debug|x64
 		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Threads|x64.Build.0 = Debug|x64
 		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Userprog|x64.ActiveCfg = Debug|x64
 		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Userprog|x64.Build.0 = Debug|x64
-		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.VirtualMemory|x64.Build.0 = Debug|x64
-		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Threads|x64.ActiveCfg = Debug|x64
 		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Threads|x64.Build.0 = Debug|x64
 		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Userprog|x64.ActiveCfg = Debug|x64
 		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Userprog|x64.Build.0 = Debug|x64
-		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.VirtualMemory|x64.Build.0 = Debug|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.ActiveCfg = DebugNonNative|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.Build.0 = DebugNonNative|x64
 		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.ActiveCfg = Debug|x64
 		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.Build.0 = Debug|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.ActiveCfg = DebugNoLocks|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.Build.0 = DebugNoLocks|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.VirtualMemory|x64.ActiveCfg = DebugNoLocks|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.VirtualMemory|x64.Build.0 = DebugNoLocks|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.ActiveCfg = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.Build.0 = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.ActiveCfg = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.Build.0 = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.VirtualMemory|x64.Build.0 = Debug|x64
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Threads|x64.ActiveCfg = Debug|x64
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Threads|x64.Build.0 = Debug|x64
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Userprog|x64.ActiveCfg = Debug|x64
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Userprog|x64.Build.0 = Debug|x64
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.VirtualMemory|x64.Build.0 = Debug|x64
-		{E1BC4F68-4192-4408-B94D-B161C6133C73}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Threads|x64.ActiveCfg = Debug|x64
-		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Threads|x64.Build.0 = Debug|x64
-		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Userprog|x64.ActiveCfg = Debug|x64
-		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Userprog|x64.Build.0 = Debug|x64
-		{E1BC4F68-4192-4408-B94D-B161C6133C73}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{E1BC4F68-4192-4408-B94D-B161C6133C73}.VirtualMemory|x64.Build.0 = Debug|x64
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Threads|x64.ActiveCfg = Debug|x64
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Threads|x64.Build.0 = Debug|x64
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Userprog|x64.ActiveCfg = Debug|x64
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Userprog|x64.Build.0 = Debug|x64
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.VirtualMemory|x64.Build.0 = Debug|x64
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Threads|x64.ActiveCfg = Debug|x64
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Threads|x64.Build.0 = Debug|x64
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Userprog|x64.ActiveCfg = Debug|x64
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Userprog|x64.Build.0 = Debug|x64
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.VirtualMemory|x64.Build.0 = Debug|x64
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Threads|x64.ActiveCfg = Debug|x64
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Threads|x64.Build.0 = Debug|x64
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Userprog|x64.ActiveCfg = Debug|x64
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Userprog|x64.Build.0 = Debug|x64
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.VirtualMemory|x64.Build.0 = Debug|x64
-		{D6919C57-7503-4F41-914E-4F0A5642D795}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{D6919C57-7503-4F41-914E-4F0A5642D795}.Threads|x64.ActiveCfg = Debug|x64
-		{D6919C57-7503-4F41-914E-4F0A5642D795}.Threads|x64.Build.0 = Debug|x64
-		{D6919C57-7503-4F41-914E-4F0A5642D795}.Userprog|x64.ActiveCfg = Debug|x64
-		{D6919C57-7503-4F41-914E-4F0A5642D795}.Userprog|x64.Build.0 = Debug|x64
-		{D6919C57-7503-4F41-914E-4F0A5642D795}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{D6919C57-7503-4F41-914E-4F0A5642D795}.VirtualMemory|x64.Build.0 = Debug|x64
-		{833F5049-D661-4297-842C-D9C9AC8469C0}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{833F5049-D661-4297-842C-D9C9AC8469C0}.Threads|x64.ActiveCfg = Debug|x64
-		{833F5049-D661-4297-842C-D9C9AC8469C0}.Threads|x64.Build.0 = Debug|x64
-		{833F5049-D661-4297-842C-D9C9AC8469C0}.Userprog|x64.ActiveCfg = Debug|x64
-		{833F5049-D661-4297-842C-D9C9AC8469C0}.Userprog|x64.Build.0 = Debug|x64
-		{833F5049-D661-4297-842C-D9C9AC8469C0}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{833F5049-D661-4297-842C-D9C9AC8469C0}.VirtualMemory|x64.Build.0 = Debug|x64
-		{E6B41356-895B-419D-93A4-8746C086F7E8}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{E6B41356-895B-419D-93A4-8746C086F7E8}.Threads|x64.ActiveCfg = Debug|x64
-		{E6B41356-895B-419D-93A4-8746C086F7E8}.Threads|x64.Build.0 = Debug|x64
-		{E6B41356-895B-419D-93A4-8746C086F7E8}.Userprog|x64.ActiveCfg = Debug|x64
-		{E6B41356-895B-419D-93A4-8746C086F7E8}.Userprog|x64.Build.0 = Debug|x64
-		{E6B41356-895B-419D-93A4-8746C086F7E8}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{E6B41356-895B-419D-93A4-8746C086F7E8}.VirtualMemory|x64.Build.0 = Debug|x64
-		{0B6872BE-9637-45B8-8404-287173BF8B35}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{0B6872BE-9637-45B8-8404-287173BF8B35}.Threads|x64.ActiveCfg = Debug|x64
-		{0B6872BE-9637-45B8-8404-287173BF8B35}.Threads|x64.Build.0 = Debug|x64
-		{0B6872BE-9637-45B8-8404-287173BF8B35}.Userprog|x64.ActiveCfg = Debug|x64
-		{0B6872BE-9637-45B8-8404-287173BF8B35}.Userprog|x64.Build.0 = Debug|x64
-		{0B6872BE-9637-45B8-8404-287173BF8B35}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{0B6872BE-9637-45B8-8404-287173BF8B35}.VirtualMemory|x64.Build.0 = Debug|x64
-		{73243670-829F-4E0C-B332-EC673749FAD4}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{73243670-829F-4E0C-B332-EC673749FAD4}.Threads|x64.ActiveCfg = Debug|x64
-		{73243670-829F-4E0C-B332-EC673749FAD4}.Threads|x64.Build.0 = Debug|x64
-		{73243670-829F-4E0C-B332-EC673749FAD4}.Userprog|x64.ActiveCfg = Debug|x64
-		{73243670-829F-4E0C-B332-EC673749FAD4}.Userprog|x64.Build.0 = Debug|x64
-		{73243670-829F-4E0C-B332-EC673749FAD4}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{73243670-829F-4E0C-B332-EC673749FAD4}.VirtualMemory|x64.Build.0 = Debug|x64
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Threads|x64.ActiveCfg = Debug|x64
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Threads|x64.Build.0 = Debug|x64
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Userprog|x64.ActiveCfg = Debug|x64
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Userprog|x64.Build.0 = Debug|x64
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.VirtualMemory|x64.Build.0 = Debug|x64
-		{2C3203CA-606A-4748-9859-06D6545DD166}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{2C3203CA-606A-4748-9859-06D6545DD166}.Threads|x64.ActiveCfg = Debug|x64
-		{2C3203CA-606A-4748-9859-06D6545DD166}.Threads|x64.Build.0 = Debug|x64
-		{2C3203CA-606A-4748-9859-06D6545DD166}.Userprog|x64.ActiveCfg = Debug|x64
-		{2C3203CA-606A-4748-9859-06D6545DD166}.Userprog|x64.Build.0 = Debug|x64
-		{2C3203CA-606A-4748-9859-06D6545DD166}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{2C3203CA-606A-4748-9859-06D6545DD166}.VirtualMemory|x64.Build.0 = Debug|x64
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Threads|x64.ActiveCfg = Debug|x64
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Threads|x64.Build.0 = Debug|x64
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Userprog|x64.ActiveCfg = Debug|x64
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Userprog|x64.Build.0 = Debug|x64
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.VirtualMemory|x64.Build.0 = Debug|x64
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Threads|x64.ActiveCfg = Debug|x64
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Threads|x64.Build.0 = Debug|x64
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Userprog|x64.ActiveCfg = Debug|x64
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Userprog|x64.Build.0 = Debug|x64
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.VirtualMemory|x64.Build.0 = Debug|x64
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Threads|x64.ActiveCfg = Debug|x64
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Threads|x64.Build.0 = Debug|x64
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Userprog|x64.ActiveCfg = Debug|x64
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Userprog|x64.Build.0 = Debug|x64
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.VirtualMemory|x64.Build.0 = Debug|x64
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Threads|x64.ActiveCfg = Debug|x64
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Threads|x64.Build.0 = Debug|x64
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Userprog|x64.ActiveCfg = Debug|x64
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Userprog|x64.Build.0 = Debug|x64
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.VirtualMemory|x64.Build.0 = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.Build.0 = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Threads|x64.ActiveCfg = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Userprog|x64.ActiveCfg = Release|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.VirtualMemory|x64.ActiveCfg = Release|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.CommonLibTests|x64.Build.0 = Debug|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Threads|x64.ActiveCfg = Debug|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Threads|x64.Build.0 = Debug|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Userprog|x64.ActiveCfg = Debug|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Userprog|x64.Build.0 = Debug|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.VirtualMemory|x64.Build.0 = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.CommonLibTests|x64.Build.0 = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Threads|x64.ActiveCfg = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Threads|x64.Build.0 = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Userprog|x64.ActiveCfg = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Userprog|x64.Build.0 = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.VirtualMemory|x64.ActiveCfg = Debug|x64
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.VirtualMemory|x64.Build.0 = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.ActiveCfg = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.Build.0 = Debug|x64
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -1300,10 +806,10 @@ Global
 		{357100B6-0650-44F2-9BB6-F3337249D714} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
 		{5040B126-0E99-434A-9F35-E1B5CDCE0729} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
 		{1DD3D1FA-62BB-47AD-B04C-853F278B8722} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
-		{7CC293C5-7E90-40D8-82EF-9A1C1FD7DF7B} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
-		{C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
-		{7715E14D-A26C-41FB-B9DE-B4484AE9439E} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
-		{3D7C3BFC-FECB-4812-951C-0B1A9A8D2242} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
+		{7CC293C5-7E90-40D8-82EF-9A1C1FD7DF7B} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
+		{C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
+		{7715E14D-A26C-41FB-B9DE-B4484AE9439E} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
+		{3D7C3BFC-FECB-4812-951C-0B1A9A8D2242} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
 		{752C9059-8C84-4FFD-938A-055E76E6BD2D} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
 		{CA491A14-A976-4C84-8530-C72974026FCE} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
 		{F5B97493-5840-4D09-88D7-44CB0C4E0677} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
@@ -1311,7 +817,7 @@ Global
 		{D157B165-F35B-4D6A-B23D-90596B0328FD} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
 		{E757415D-952B-41EB-91D2-678ED2A21241} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
 		{8853A519-4E05-429D-A2A1-911BACE363C6} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
-		{BBA99A17-8590-4DA9-B63F-675DADCF2504} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
+		{BBA99A17-8590-4DA9-B63F-675DADCF2504} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
 		{89F0CC41-F7A4-46B8-B680-776EA30B3626} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
 		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
 		{3E621DA0-AD72-46DC-813A-78541ACBE00A} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
@@ -1323,33 +829,5 @@ Global
 		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
 		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
 		{343E7816-3E2E-4A46-9500-730E5CC7CCB5} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}
-		{BFB23853-6940-4444-89C7-5364AD6AD41C} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
-		{6E6A08BF-A678-4239-8310-48844D3AFB56} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
-		{A08E6F21-0543-4984-8E84-A80E6C11A582} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
-		{699EC88B-CEE0-40E4-9F98-1409E0FCE305} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
-		{AC31B304-896F-4AA6-BDDC-548E89A4E90E} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
-		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{E1BC4F68-4192-4408-B94D-B161C6133C73} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{C26BFEEE-6078-400E-AD95-CC25B351BA4D} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{D6919C57-7503-4F41-914E-4F0A5642D795} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{833F5049-D661-4297-842C-D9C9AC8469C0} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{E6B41356-895B-419D-93A4-8746C086F7E8} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{0B6872BE-9637-45B8-8404-287173BF8B35} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
-		{73243670-829F-4E0C-B332-EC673749FAD4} = {699EC88B-CEE0-40E4-9F98-1409E0FCE305}
-		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A} = {699EC88B-CEE0-40E4-9F98-1409E0FCE305}
-		{2C3203CA-606A-4748-9859-06D6545DD166} = {699EC88B-CEE0-40E4-9F98-1409E0FCE305}
-		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
-		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
-		{D61D8289-38BD-4CC1-B943-A53C2DCD800B} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
-		{FC4360D9-B78C-4CD3-82EE-67877E091EC7} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
-		{7A3F18F0-B375-4A08-B944-AC7148793AE7} = {159880E4-3D75-48CB-B113-A2D217CE423C}
-		{159880E4-3D75-48CB-B113-A2D217CE423C} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
-		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9} = {159880E4-3D75-48CB-B113-A2D217CE423C}
-	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-		SolutionGuid = {3AE286A9-35D7-4547-86BE-AB7EAF8A3602}
 	EndGlobalSection
 EndGlobal
diff --git a/src/HAL9000/HAL9000.vcxproj b/src/HAL9000/HAL9000.vcxproj
index 0dd1641..8a8010d 100644
--- a/src/HAL9000/HAL9000.vcxproj
+++ b/src/HAL9000/HAL9000.vcxproj
@@ -5,10 +5,6 @@
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{79A21DCA-19AF-4F8E-9B83-62D7CF504104}</ProjectGuid>
@@ -23,12 +19,6 @@
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
     <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.props" />
@@ -38,9 +28,6 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <LinkIncremental>false</LinkIncremental>
@@ -52,16 +39,6 @@
     <RunCodeAnalysis>true</RunCodeAnalysis>
     <EmbedManifest>false</EmbedManifest>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <LinkIncremental>false</LinkIncremental>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetName>HAL9000</TargetName>
-    <TargetExt>.bin</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-    <EmbedManifest>false</EmbedManifest>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <PrecompiledHeader>
@@ -84,12 +61,12 @@
       <RuntimeTypeInfo>true</RuntimeTypeInfo>
       <OpenMPSupport>false</OpenMPSupport>
       <EnablePREfast>true</EnablePREfast>
-      <AdditionalIncludeDirectories>headers;..\shared\common;..\shared\kernel;..\..\acpi\inc;..\commonlib\inc;..\HAL\inc;..\SwapFS\inc;..\FAT32\inc;..\PE_Parser\inc;..\Eth_82574L\inc;..\NetworkStack\inc;..\Disk\inc;..\Volume\inc;..\Ata\inc</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>headers;..\shared\common;..\shared\kernel;..\..\acpi\inc;..\commonlib\inc;..\HAL\inc;..\FAT32\inc;..\PE_Parser\inc;..\Eth_82574L\inc;..\NetworkStack\inc;..\Disk\inc;..\Volume\inc;..\Ata\inc</AdditionalIncludeDirectories>
       <DisableSpecificWarnings>4313;4474;4476;4477;</DisableSpecificWarnings>
       <ShowIncludes>false</ShowIncludes>
       <MinimalRebuild>false</MinimalRebuild>
       <FunctionLevelLinking>false</FunctionLevelLinking>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <OmitFramePointers>true</OmitFramePointers>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
     </ClCompile>
@@ -97,68 +74,7 @@
       <SubSystem>Native</SubSystem>
       <GenerateDebugInformation>Debug</GenerateDebugInformation>
       <OutputFile>$(OutDir)\HAL9000.bin</OutputFile>
-      <AdditionalDependencies>HAL.lib;CommonLib.lib;FAT32.lib;SwapFS.lib;PE_Parser.lib;Eth_82574L.lib;NetworkStack.lib;NetworkPort.lib;Disk.lib;Volume.lib;Ata.lib;Acpica.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)\HAL9000.map</MapFileName>
-      <MapExports>true</MapExports>
-      <EntryPointSymbol>__EntryMultiboot</EntryPointSymbol>
-      <BaseAddress>0xFFFF800001000000</BaseAddress>
-      <FixedBaseAddress>true</FixedBaseAddress>
-      <AdditionalOptions>/ALIGN:0x200 /IGNORE:4108 /MERGE:.mboot=.text %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\HAL;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\FAT32;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\SwapFS;$(SolutionDir)..\acpi\bin\$(PlatformName)\$(ConfigurationName);$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\commonlib;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\PE_Parser;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Eth_82574L;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkStack;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkPort;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Disk;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Volume;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Ata</AdditionalLibraryDirectories>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
-    </Link>
-    <YASM>
-      <Defines>DEBUG</Defines>
-      <AdditionalOptions>-f x64 -X vc -w %(AdditionalOptions)</AdditionalOptions>
-      <Debug>true</Debug>
-    </YASM>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\post_hv.cmd $(ProjectName) "$(SolutionDir)" $(PlatformName) $(ConfigurationName) $(ProjectName)  $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>MaxSpeed</Optimization>
-      <PreprocessorDefinitions>X64;AMD64;NDEBUG;WIN64</PreprocessorDefinitions>
-      <SDLCheck>true</SDLCheck>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <FloatingPointExceptions>false</FloatingPointExceptions>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
-      <AdditionalIncludeDirectories>headers;..\shared\common;..\shared\kernel;..\..\acpi\inc;..\commonlib\inc;..\HAL\inc;..\SwapFS\inc;..\FAT32\inc;..\PE_Parser\inc;..\Eth_82574L\inc;..\NetworkStack\inc;..\Disk\inc;..\Volume\inc;..\Ata\inc</AdditionalIncludeDirectories>
-      <DisableSpecificWarnings>4313;4474;4476;4477;</DisableSpecificWarnings>
-      <ShowIncludes>false</ShowIncludes>
-      <MinimalRebuild>false</MinimalRebuild>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <StringPooling>true</StringPooling>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
-      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
-    </ClCompile>
-    <Link>
-      <SubSystem>Native</SubSystem>
-      <GenerateDebugInformation>Debug</GenerateDebugInformation>
-      <OutputFile>$(OutDir)\HAL9000.bin</OutputFile>
-      <AdditionalDependencies>HAL.lib;CommonLib.lib;FAT32.lib;SwapFS.lib;PE_Parser.lib;Eth_82574L.lib;NetworkStack.lib;NetworkPort.lib;Disk.lib;Volume.lib;Ata.lib;Acpica.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>HAL.lib;CommonLib.lib;FAT32.lib;PE_Parser.lib;Eth_82574L.lib;NetworkStack.lib;NetworkPort.lib;Disk.lib;Volume.lib;Ata.lib;Acpica.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
       <GenerateMapFile>true</GenerateMapFile>
       <MapFileName>$(OutDir)\HAL9000.map</MapFileName>
@@ -167,7 +83,7 @@
       <BaseAddress>0xFFFF800001000000</BaseAddress>
       <FixedBaseAddress>true</FixedBaseAddress>
       <AdditionalOptions>/ALIGN:0x200 /IGNORE:4108 /MERGE:.mboot=.text %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\HAL;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\FAT32;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\SwapFS;$(SolutionDir)..\acpi\bin\$(PlatformName)\Debug;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\commonlib;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\PE_Parser;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Eth_82574L;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkStack;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkPort;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Disk;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Volume;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Ata</AdditionalLibraryDirectories>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\HAL;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\FAT32;$(SolutionDir)..\acpi\bin\$(PlatformName)\$(ConfigurationName);$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\commonlib;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\PE_Parser;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Eth_82574L;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkStack;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkPort;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Disk;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Volume;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Ata</AdditionalLibraryDirectories>
       <RandomizedBaseAddress>false</RandomizedBaseAddress>
       <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
     </Link>
@@ -222,6 +138,7 @@
     <ClCompile Include="src\ex_timer.c" />
     <ClCompile Include="src\gdtmu.c" />
     <ClCompile Include="src\hal_assert.c" />
+    <ClCompile Include="src\heap.c" />
     <ClCompile Include="src\idt_handlers.c" />
     <ClCompile Include="src\ioapic_system.c" />
     <ClCompile Include="src\io_devices.c" />
@@ -256,6 +173,7 @@
     <ClCompile Include="src\test_common.c" />
     <ClCompile Include="src\test_dma.c" />
     <ClCompile Include="src\test_file_io.c" />
+    <ClCompile Include="src\test_heap.c" />
     <ClCompile Include="src\test_net_stack.c" />
     <ClCompile Include="src\test_pmm.c" />
     <ClCompile Include="src\test_thread.c" />
@@ -276,6 +194,7 @@
     <ClInclude Include="..\shared\kernel\ex.h" />
     <ClInclude Include="..\shared\kernel\ex_event.h" />
     <ClInclude Include="..\shared\kernel\filesystem.h" />
+    <ClInclude Include="..\shared\kernel\heap.h" />
     <ClInclude Include="..\shared\kernel\heap_tags.h" />
     <ClInclude Include="..\shared\kernel\io.h" />
     <ClInclude Include="..\shared\kernel\io_structures.h" />
@@ -354,6 +273,7 @@
     <ClInclude Include="headers\test_common.h" />
     <ClInclude Include="headers\test_dma.h" />
     <ClInclude Include="headers\test_file_io.h" />
+    <ClInclude Include="headers\test_heap.h" />
     <ClInclude Include="headers\test_net_stack.h" />
     <ClInclude Include="headers\test_pmm.h" />
     <ClInclude Include="headers\test_priority_donation.h" />
@@ -393,7 +313,6 @@
     <YASM Include="src\_isr.yasm">
       <FileType>Document</FileType>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
     </YASM>
     <None Include="src\lib.yasm" />
     <YASM Include="src\_low_mem.yasm">
diff --git a/src/HAL9000/HAL9000.vcxproj.filters b/src/HAL9000/HAL9000.vcxproj.filters
index f31d483..9f3d64f 100644
--- a/src/HAL9000/HAL9000.vcxproj.filters
+++ b/src/HAL9000/HAL9000.vcxproj.filters
@@ -168,6 +168,9 @@
     <ClCompile Include="src\dmp_cmos.c">
       <Filter>Source Files\debug\dump</Filter>
     </ClCompile>
+    <ClCompile Include="src\heap.c">
+      <Filter>Source Files\crt</Filter>
+    </ClCompile>
     <ClCompile Include="src\dmp_multiboot.c">
       <Filter>Source Files\debug\dump</Filter>
     </ClCompile>
@@ -192,6 +195,9 @@
     <ClCompile Include="src\test_common.c">
       <Filter>Source Files\debug\test</Filter>
     </ClCompile>
+    <ClCompile Include="src\test_heap.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
     <ClCompile Include="src\cpumu.c">
       <Filter>Source Files\core\cpu</Filter>
     </ClCompile>
@@ -443,6 +449,9 @@
     <ClInclude Include="headers\test_common.h">
       <Filter>Header Files\debug\test</Filter>
     </ClInclude>
+    <ClInclude Include="headers\test_heap.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
     <ClInclude Include="headers\cpumu.h">
       <Filter>Header Files\core\cpu</Filter>
     </ClInclude>
@@ -671,6 +680,9 @@
     <ClInclude Include="..\shared\kernel\filesystem.h">
       <Filter>Header Files\devices\abstraction</Filter>
     </ClInclude>
+    <ClInclude Include="..\shared\kernel\heap.h">
+      <Filter>Header Files\crt</Filter>
+    </ClInclude>
     <ClInclude Include="..\shared\kernel\heap_tags.h">
       <Filter>Header Files\crt</Filter>
     </ClInclude>
diff --git a/src/HAL9000/headers/HAL9000.h b/src/HAL9000/headers/HAL9000.h
index efd6a15..976ffcc 100644
--- a/src/HAL9000/headers/HAL9000.h
+++ b/src/HAL9000/headers/HAL9000.h
@@ -1,8 +1,12 @@
 #pragma once
 
-#include "common_lib.h"
+#include "base.h"
+#include "sal_interface.h"
+#include "status.h"
 #include "hal.h"
 #include "msr.h"
+#include "common_lib.h"
+#include "assert.h"
 #include "log.h"
 #include "ex.h"
 
diff --git a/src/HAL9000/headers/acpi_interface.h b/src/HAL9000/headers/acpi_interface.h
index 2714188..4592322 100644
--- a/src/HAL9000/headers/acpi_interface.h
+++ b/src/HAL9000/headers/acpi_interface.h
@@ -9,6 +9,7 @@ AcpiInterfacePreinit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 AcpiInterfaceInit(
     void
@@ -19,35 +20,41 @@ AcpiShutdown(
     void
     );
 
+SAL_SUCCESS
 STATUS
 AcpiInterfaceLateInit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextCpu(
     IN      BOOLEAN                     RestartSearch,
     OUT_PTR ACPI_MADT_LOCAL_APIC**      AcpiEntry
     );
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextIoApic(
     IN      BOOLEAN                     RestartSearch,
     OUT_PTR ACPI_MADT_IO_APIC**         AcpiEntry
     );
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextInterruptOverride(
     IN      BOOLEAN                         RestartSearch,
     OUT_PTR ACPI_MADT_INTERRUPT_OVERRIDE**  AcpiEntry
     );
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextMcfgEntry(
     IN      BOOLEAN                     RestartSearch,
     OUT_PTR ACPI_MCFG_ALLOCATION**      AcpiEntry
     );
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextPrtEntry(
     IN      BOOLEAN                     RestartSearch,
diff --git a/src/HAL9000/headers/ap_tramp.h b/src/HAL9000/headers/ap_tramp.h
index 246bbac..0a6e7ca 100644
--- a/src/HAL9000/headers/ap_tramp.h
+++ b/src/HAL9000/headers/ap_tramp.h
@@ -2,6 +2,7 @@
 
 #include "list.h"
 
+SAL_SUCCESS
 STATUS
 ApTrampSetupLowerMemory(
     IN      PLIST_ENTRY     CpuList,
diff --git a/src/HAL9000/headers/cmd_fs_helper.h b/src/HAL9000/headers/cmd_fs_helper.h
index c608e81..1355f36 100644
--- a/src/HAL9000/headers/cmd_fs_helper.h
+++ b/src/HAL9000/headers/cmd_fs_helper.h
@@ -7,5 +7,3 @@ FUNC_GenericCommand CmdMakeDirectory;
 FUNC_GenericCommand CmdMakeFile;
 FUNC_GenericCommand CmdListDirectory;
 FUNC_GenericCommand CmdReadFile;
-FUNC_GenericCommand CmdWriteFile;
-FUNC_GenericCommand CmdSwap;
diff --git a/src/HAL9000/headers/cmd_thread_helper.h b/src/HAL9000/headers/cmd_thread_helper.h
index c2c9f13..8bc5e02 100644
--- a/src/HAL9000/headers/cmd_thread_helper.h
+++ b/src/HAL9000/headers/cmd_thread_helper.h
@@ -11,6 +11,4 @@ FUNC_GenericCommand CmdListCpuInterrupts;
 FUNC_GenericCommand CmdTestTimer;
 FUNC_GenericCommand CmdCpuid;
 FUNC_GenericCommand CmdRdmsr;
-FUNC_GenericCommand CmdWrmsr;
-FUNC_GenericCommand CmdCheckAd;
-FUNC_GenericCommand CmdSpawnThreads;
+FUNC_GenericCommand CmdWrmsr;
\ No newline at end of file
diff --git a/src/HAL9000/headers/core.h b/src/HAL9000/headers/core.h
index a1aadad..67da99a 100644
--- a/src/HAL9000/headers/core.h
+++ b/src/HAL9000/headers/core.h
@@ -5,6 +5,7 @@ CorePreinit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 CoreInit(
     void
diff --git a/src/HAL9000/headers/cpumu.h b/src/HAL9000/headers/cpumu.h
index e1f610c..148f3f4 100644
--- a/src/HAL9000/headers/cpumu.h
+++ b/src/HAL9000/headers/cpumu.h
@@ -7,7 +7,7 @@
 #include "synch.h"
 #include "cpu_structures.h"
 
-#define STACK_DEFAULT_SIZE          (8*PAGE_SIZE)
+#define STACK_DEFAULT_SIZE          (4*PAGE_SIZE)
 #define STACK_GUARD_SIZE            (2*PAGE_SIZE)
 
 typedef struct _THREADING_DATA
@@ -25,8 +25,6 @@ typedef struct _THREADING_DATA
 
 typedef struct _PCPU
 {
-    struct _PCPU                *Self;
-
     PVOID                       StackTop;
     DWORD                       StackSize;
 
@@ -60,13 +58,13 @@ typedef struct _PCPU
 
     QWORD                       InterruptsTriggered[NO_OF_TOTAL_INTERRUPTS];
 } PCPU, *PPCPU;
-STATIC_ASSERT_INFO(FIELD_OFFSET(PCPU,StackTop) == 0x8, "Used by _syscall.yasm:30 on syscalls to determine the user thread's kernel stack!");
+STATIC_ASSERT_INFO(FIELD_OFFSET(PCPU,StackTop) == 0x0, "Used by _syscall.yasm:20 on syscalls to determine the user thread's kernel stack!");
 
 // This function should only be called when interrupts are disabled, else the CPU on which
 // the thread is running may change between the moment GetCurrentPcpu() was called and the moment
 // in which the pointer returned is actually used. This is an instance of a time of check to
 // time of use race condition.
-#define GetCurrentPcpu()    ((PCPU*)__readgsqword(FIELD_OFFSET(PCPU,Self)))
+#define GetCurrentPcpu()    ((PCPU*)__readmsr(IA32_GS_BASE_MSR))
 #define SetCurrentPcpu(pc)  (__writemsr(IA32_GS_BASE_MSR,(pc)))
 
 void
@@ -113,14 +111,9 @@ CpuMuChangeStack(
     IN          PVOID       NewStack
     );
 
-BOOLEAN
-CpuMuIsPcidFeaturePresent(
-    void
-    );
-
-STATUS
-CpuMuActivateFpuFeatures(
-    void
+void
+CpuMuFreeStack(
+    IN          PVOID       Stack
     );
 
 __forceinline
diff --git a/src/HAL9000/headers/display.h b/src/HAL9000/headers/display.h
index 8b85bf9..7f7e843 100644
--- a/src/HAL9000/headers/display.h
+++ b/src/HAL9000/headers/display.h
@@ -91,12 +91,14 @@ DispSetCursor(
     IN      COLOR               Color
     );
 
+SAL_SUCCESS
 STATUS
 DispStoreBuffer(
     OUT_WRITES_BYTES(Size)  PVOID               Buffer,
     IN                      DWORD               Size
     );
 
+SAL_SUCCESS
 STATUS
 DispRestoreBuffer(
     IN_READS_BYTES(Size)    PVOID               Buffer,
diff --git a/src/HAL9000/headers/dmp_common.h b/src/HAL9000/headers/dmp_common.h
index 6e930e6..0b4efe1 100644
--- a/src/HAL9000/headers/dmp_common.h
+++ b/src/HAL9000/headers/dmp_common.h
@@ -8,9 +8,6 @@ DumpPreinit(
 REQUIRES_NOT_HELD_LOCK(m_dumpLock)
 RELEASES_EXCL_AND_REENTRANT_LOCK(m_dumpLock)
 INTR_STATE
-// Warning C28285 For function 'DumpTakeLock' 'return' syntax error
-// This is because SAL does not know who m_dumpLock is
-#pragma warning(suppress: 28285)
 DumpTakeLock(
     void
     );
@@ -18,9 +15,6 @@ DumpTakeLock(
 REQUIRES_EXCL_LOCK(m_dumpLock)
 RELEASES_EXCL_AND_REENTRANT_LOCK(m_dumpLock)
 void
-// Warning C28285 For function 'DumpTakeLock' 'return' syntax error
-// This is because SAL does not know who m_dumpLock is
-#pragma warning(suppress: 28285)
 DumpReleaseLock(
     IN INTR_STATE   OldIntrState
     );
\ No newline at end of file
diff --git a/src/HAL9000/headers/dmp_cpu.h b/src/HAL9000/headers/dmp_cpu.h
index 0539298..4799465 100644
--- a/src/HAL9000/headers/dmp_cpu.h
+++ b/src/HAL9000/headers/dmp_cpu.h
@@ -3,14 +3,9 @@
 #include "cpu.h"
 #include "isr.h"
 
-void
-DumpRegisterArea(
-    IN  REGISTER_AREA*                  RegisterArea
-    );
-
 void
 DumpProcessorState(
-    IN  COMPLETE_PROCESSOR_STATE*       ProcessorState
+    IN  PROCESSOR_STATE*    ProcessorState
     );
 
 void
diff --git a/src/HAL9000/headers/gdtmu.h b/src/HAL9000/headers/gdtmu.h
index 4191e8c..9c515f1 100644
--- a/src/HAL9000/headers/gdtmu.h
+++ b/src/HAL9000/headers/gdtmu.h
@@ -46,14 +46,6 @@ GdtMuRetrieveSelectorIndex(
     IN      SEL_TYPE        Type
     );
 
-void
-GdtMuReload(
-    IN          WORD            CodeSelector,
-    IN          WORD            DataSelector,
-    IN          BOOLEAN         PreserveGsBase,
-    IN          BOOLEAN         PreserveFsBase
-    );
-
 #define GdtMuGetCS64Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeCode)
 #define GdtMuGetDS64Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeData)
 #define GdtMuGetCS32Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode32, SelTypeCode)
diff --git a/src/HAL9000/headers/idt_handlers.h b/src/HAL9000/headers/idt_handlers.h
index 2f7f0c4..33a0f64 100644
--- a/src/HAL9000/headers/idt_handlers.h
+++ b/src/HAL9000/headers/idt_handlers.h
@@ -44,6 +44,7 @@ typedef enum _INTERRUPT
 #define     IVT_ENTRY_SIZE                  4
 #define     IVT_LIMIT                       0x3FF
 
+SAL_SUCCESS
 STATUS
 InitIdtHandlers(
     IN      WORD                CodeSelector,
diff --git a/src/HAL9000/headers/iomu.h b/src/HAL9000/headers/iomu.h
index d0cd4b4..bc43a85 100644
--- a/src/HAL9000/headers/iomu.h
+++ b/src/HAL9000/headers/iomu.h
@@ -35,11 +35,6 @@ IomuGetSystemPartitionPath(
     void
     );
 
-PFILE_OBJECT
-IomuGetSwapFile(
-    void
-    );
-
 void
 IomuAckInterrupt(
     IN      BYTE            InterruptIndex
@@ -60,6 +55,7 @@ IomuGetPciDeviceList(
     void
     );
 
+SAL_SUCCESS
 STATUS
 IomuGetDevicesByType(
     IN_RANGE_UPPER(DeviceTypeMax)
diff --git a/src/HAL9000/headers/isr.h b/src/HAL9000/headers/isr.h
index 111a9b9..6cf6f37 100644
--- a/src/HAL9000/headers/isr.h
+++ b/src/HAL9000/headers/isr.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#pragma pack(push)
-#pragma pack(1)
 typedef struct _INTERRUPT_STACK
 {
     QWORD                       Rip;
@@ -16,7 +14,6 @@ typedef struct _INTERRUPT_STACK_COMPLETE
     QWORD                       ErrorCode;
     INTERRUPT_STACK             Registers;
 } INTERRUPT_STACK_COMPLETE, *PINTERRUPT_STACK_COMPLETE;
-#pragma pack(pop)
 
 typedef
 BOOLEAN
@@ -26,6 +23,7 @@ BOOLEAN
 
 typedef FUNC_IsrRoutine*        PFUNC_IsrRoutine;
 
+SAL_SUCCESS
 STATUS
 IsrInstallEx(
     IN      BYTE                Vector,
diff --git a/src/HAL9000/headers/keyboard.h b/src/HAL9000/headers/keyboard.h
index 10b0897..07df29f 100644
--- a/src/HAL9000/headers/keyboard.h
+++ b/src/HAL9000/headers/keyboard.h
@@ -5,6 +5,7 @@
 // A Make Code is sent when a key is pressed or held down
 // A Break code is sent when a key is released
 
+SAL_SUCCESS
 STATUS
 KeyboardInitialize(
     IN      BYTE        InterruptIrq
diff --git a/src/HAL9000/headers/lapic_system.h b/src/HAL9000/headers/lapic_system.h
index 44fe18a..2edd8c8 100644
--- a/src/HAL9000/headers/lapic_system.h
+++ b/src/HAL9000/headers/lapic_system.h
@@ -2,11 +2,13 @@
 
 #include "lapic.h"
 
+SAL_SUCCESS
 STATUS
 LapicSystemInit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 LapicSystemInitializeCpu(
     IN      BYTE                            TimerInterruptVector
@@ -28,16 +30,8 @@ LapicSystemSendEOI(
     IN      BYTE                            Vector
     );
 
-//******************************************************************************
-// Function:     LapicSystemSetTimer
-// Description:  Enables the LAPIC timer on the current CPU to trigger every
-//               Microseconds ms. If the argument is 0 the timer is stopped.
-// Parameter:    IN DWORD Microseconds - Trigger period in microseconds.
-// Parameter:    OUT_PTR PTHREAD * Thread
-// NOTE:         This only programs the LAPIC timer on the current CPU.
-//******************************************************************************
 void
-LapicSystemSetTimer(
+LapicSystemEnableTimer(
     IN      DWORD                           Microseconds
     );
 
diff --git a/src/HAL9000/headers/mmu.h b/src/HAL9000/headers/mmu.h
index c4d12d0..400db53 100644
--- a/src/HAL9000/headers/mmu.h
+++ b/src/HAL9000/headers/mmu.h
@@ -114,11 +114,8 @@ MmuGetHighestPhysicalMemoryAddressPresent(
 // Parameter:    IN PHYSICAL_ADDRESS PhysicalAddress
 // Parameter:    IN DWORD Size
 // Parameter:    IN PAGE_RIGHTS PageRights
-// Parameter:    IN BOOLEAN Invalidate - If TRUE modifies paging structure even
-//               if it was already mapped.
+// Parameter:    IN BOOLEAN Invalidate
 // Parameter:    IN BOOLEAN Uncacheable
-// Parameter:    IN_OPT PPAGING_LOCK_DATA PagingData - Paging structures to use,
-//               if NULL maps only to kernel space.
 //******************************************************************************
 PTR_SUCCESS
 PVOID
@@ -128,7 +125,7 @@ MmuMapMemoryEx(
     IN      PAGE_RIGHTS             PageRights,
     IN      BOOLEAN                 Invalidate,
     IN      BOOLEAN                 Uncacheable,
-    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    IN_OPT  PPAGING_LOCK_DATA       PagingDatas
     );
 
 //******************************************************************************
@@ -346,17 +343,6 @@ MmuActivateProcessIds(
     void
     );
 
-//******************************************************************************
-// Function:     MmuActivateProcessIds
-// Description:  Switches to the address space of a different process.
-// Returns:      void
-// Parameter:    IN PPROCESS Process
-//******************************************************************************
-void
-MmuChangeProcessSpace(
-    IN          PPROCESS            Process
-    );
-
 //******************************************************************************
 // Function:     MmuAllocStack
 // Description:  Allocates a stack of StackSize bytes.
diff --git a/src/HAL9000/headers/os_info.h b/src/HAL9000/headers/os_info.h
index 9644ec9..c78a4ce 100644
--- a/src/HAL9000/headers/os_info.h
+++ b/src/HAL9000/headers/os_info.h
@@ -7,6 +7,7 @@ OsInfoPreinit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 OsInfoInit(
     void
diff --git a/src/HAL9000/headers/os_time.h b/src/HAL9000/headers/os_time.h
index 8f9f591..38451b7 100644
--- a/src/HAL9000/headers/os_time.h
+++ b/src/HAL9000/headers/os_time.h
@@ -7,6 +7,7 @@ OsTimeGetCurrentDateTime(
     void
     );
 
+SAL_SUCCESS
 STATUS
 OsTimeGetStringFormattedTime(
     IN_OPT                      PDATETIME       DateTime,
diff --git a/src/HAL9000/headers/process_internal.h b/src/HAL9000/headers/process_internal.h
index 7ebdcc6..fa9a57c 100644
--- a/src/HAL9000/headers/process_internal.h
+++ b/src/HAL9000/headers/process_internal.h
@@ -6,9 +6,6 @@
 #include "synch.h"
 #include "ex_event.h"
 
-#define PROCESS_MAX_PHYSICAL_FRAMES     16
-#define PROCESS_MAX_OPEN_FILES          16
-
 typedef struct _PROCESS
 {
     REF_COUNT                       RefCnt;
diff --git a/src/HAL9000/headers/serial_comm.h b/src/HAL9000/headers/serial_comm.h
index bc95efa..9e171d0 100644
--- a/src/HAL9000/headers/serial_comm.h
+++ b/src/HAL9000/headers/serial_comm.h
@@ -1,11 +1,13 @@
 #pragma once
 
+SAL_SUCCESS
 STATUS
 SerialCommunicationInitialize(
     IN_READS(NoOfPorts)     WORD*           Ports,
     IN                      DWORD           NoOfPorts
     );
 
+SAL_SUCCESS
 STATUS
 SerialCommunicationReinitialize(
     void
diff --git a/src/HAL9000/headers/smp.h b/src/HAL9000/headers/smp.h
index 8a47748..b439527 100644
--- a/src/HAL9000/headers/smp.h
+++ b/src/HAL9000/headers/smp.h
@@ -46,12 +46,14 @@ SmpPreinit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 _No_competing_thread_
 SmpInit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 _No_competing_thread_
 SmpSetupLowerMemory(
@@ -120,6 +122,7 @@ SmpSendGenericIpiEx(
             SMP_DESTINATION         Destination
     );
 
+SAL_SUCCESS
 STATUS
 SmpCpuInit(
     void
diff --git a/src/HAL9000/headers/system.h b/src/HAL9000/headers/system.h
index 741fc0a..829cff8 100644
--- a/src/HAL9000/headers/system.h
+++ b/src/HAL9000/headers/system.h
@@ -5,6 +5,7 @@ SystemPreinit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 SystemInit(
     IN  ASM_PARAMETERS*     Parameters
diff --git a/src/HAL9000/headers/test_heap.h b/src/HAL9000/headers/test_heap.h
new file mode 100644
index 0000000..50b65a3
--- /dev/null
+++ b/src/HAL9000/headers/test_heap.h
@@ -0,0 +1,7 @@
+#pragma once
+
+void
+TestHeapFunctions(
+    IN          DWORD           NoOfAllocations,
+    IN          DWORD           AllocationSize
+    );
\ No newline at end of file
diff --git a/src/HAL9000/headers/test_priority_scheduler.h b/src/HAL9000/headers/test_priority_scheduler.h
index 75394f1..fe8d8e8 100644
--- a/src/HAL9000/headers/test_priority_scheduler.h
+++ b/src/HAL9000/headers/test_priority_scheduler.h
@@ -3,13 +3,9 @@
 FUNC_ThreadStart            TestThreadPriorityMutex;
 FUNC_ThreadPrepareTest      TestPrepareMutex;
 FUNC_ThreadPostCreate       TestThreadPostCreateMutex;
-FUNC_ThreadPostFinish       TestThreadPostFinishMutex;
 
 FUNC_ThreadStart            TestThreadPriorityWakeup;
 FUNC_ThreadPrepareTest      TestThreadPrepareWakeupEvent;
 FUNC_ThreadPostCreate       TestThreadPostCreateWakeup;
-FUNC_ThreadPostFinish       TestThreadPostFinishWakeup;
 
 FUNC_ThreadStart            TestThreadPriorityExecution;
-FUNC_ThreadPrepareTest      TestThreadPreparePriorityExecution;
-FUNC_ThreadPostFinish       TestThreadPostPriorityExecution;
diff --git a/src/HAL9000/headers/test_process.h b/src/HAL9000/headers/test_process.h
index f870102..f161820 100644
--- a/src/HAL9000/headers/test_process.h
+++ b/src/HAL9000/headers/test_process.h
@@ -5,7 +5,6 @@ typedef struct _PROCESS_TEST
     char*                       TestName;
     char*                       ProcessName;
     char*                       ProcessCommandLine;
-    DWORD                       NumberOfProcesses;
 } PROCESS_TEST, *PPROCESS_TEST;
 
 extern const PROCESS_TEST PROCESS_TESTS[];
diff --git a/src/HAL9000/headers/test_timer.h b/src/HAL9000/headers/test_timer.h
index 39150a8..5f7abf8 100644
--- a/src/HAL9000/headers/test_timer.h
+++ b/src/HAL9000/headers/test_timer.h
@@ -25,5 +25,4 @@ FUNC_ThreadStart                        TestThreadTimerSleep;
 FUNC_ThreadStart                        TestThreadTimerMultiple;
 
 FUNC_ThreadPrepareTest                  TestThreadTimerPrepare;
-FUNC_ThreadPostFinish                   TestThreadTimerMultipleTimersPostFinish;
-FUNC_ThreadPostFinish					TestThreadTimerMultipleThreadsPostFinish;
+FUNC_ThreadPostFinish                   TestThreadTimerPostFinish;
diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
index be2588a..25d55c7 100644
--- a/src/HAL9000/headers/thread_internal.h
+++ b/src/HAL9000/headers/thread_internal.h
@@ -35,8 +35,6 @@ typedef struct _THREAD
 {
     REF_COUNT               RefCnt;
 
-    struct _THREAD          *Self;
-
     TID                     Id;
     char*                   Name;
 
@@ -252,13 +250,12 @@ ThreadExecuteForEachThreadEntry(
     IN_OPT  PVOID               Context
     );
 
-
-//******************************************************************************O
+//******************************************************************************
 // Function:     GetCurrentThread
 // Description:  Returns the running thread.
 // Returns:      void
 //******************************************************************************
-#define GetCurrentThread()      ((THREAD*)__HALreadfsqword(FIELD_OFFSET(THREAD, Self)))
+#define GetCurrentThread()      ((THREAD*)__readmsr(IA32_FS_BASE_MSR))
 
 //******************************************************************************
 // Function:     SetCurrentThread
diff --git a/src/HAL9000/headers/vmm.h b/src/HAL9000/headers/vmm.h
index f979a54..ac408e1 100644
--- a/src/HAL9000/headers/vmm.h
+++ b/src/HAL9000/headers/vmm.h
@@ -77,28 +77,19 @@ VmmUnmapMemoryEx(
     IN      BOOLEAN                 ReleaseMemory
     );
 
-#define VmmGetPhysicalAddress(Cr3,Va)   VmmGetPhysicalAddressEx((Cr3),(Va),NULL,NULL)
-
 //******************************************************************************
-// Function:     VmmGetPhysicalAddressEx
+// Function:     VmmGetPhysicalAddress
 // Description:  Retrieves the physical address corresponding to VirtualAddress
-//               given Cr3 and optionally retrieves the accessed and dirty
-//               bits for the address.
-// Returns:      PHYSICAL_ADDRESS - If NULL the virtual addressed is not mapped
+//               given Cr3.
+// Returns:      PHYSICAL_ADDRESS
 // Parameter:    IN PML4 Cr3
 // Parameter:    IN PVOID VirtualAddress
-// Parameter:    OUT_OPT BOOLEAN* Accessed
-// Parameter:    OUT_OPT BOOLEAN* Dirty
-// NOTE:         If the Accessed or Dirty parameter is non-NULL the
-//               corresponding bit will be cleared after the value is saved.
 //******************************************************************************
 PTR_SUCCESS
 PHYSICAL_ADDRESS
-VmmGetPhysicalAddressEx(
+VmmGetPhysicalAddress(
     IN      PML4                    Cr3,
-    IN      PVOID                   VirtualAddress,
-    OUT_OPT BOOLEAN*                Accessed,
-    OUT_OPT BOOLEAN*                Dirty
+    IN      PVOID                   VirtualAddress
     );
 
 //******************************************************************************
diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
index a7810ff..dec0f13 100644
--- a/src/HAL9000/src/Entry64.c
+++ b/src/HAL9000/src/Entry64.c
@@ -17,8 +17,6 @@
 #include "keyboard.h"
 #endif
 
-int _fltused = 1;
-
 void
 Entry64(
     IN  int                 argc,
@@ -28,21 +26,23 @@ Entry64(
     STATUS status;
     COMMON_LIB_INIT initSettings;
 
-    // We don't have commonlib support yet, as a result we have no way of asserting at this point
-    if (!IS_STACK_ALIGNED) __halt();
+    CHECK_STACK_ALIGNMENT;
 
     status = STATUS_SUCCESS;
     memzero(&initSettings, sizeof(COMMON_LIB_INIT));
 
     initSettings.Size = sizeof(COMMON_LIB_INIT);
     initSettings.AssertFunction = Hal9000Assert;
-
+    
     CpuMuPreinit();
 
     status = CpuMuSetMonitorFilterSize(sizeof(MONITOR_LOCK));
     initSettings.MonitorSupport = SUCCEEDED(status);
 
     status = CommonLibInit(&initSettings);
+
+   
+
     if (!SUCCEEDED(status))
     {
         // not good lads
@@ -51,12 +51,16 @@ Entry64(
 
     ASSERT_INFO(1 == argc, "We are always expecting a single parameter\n");
     ASSERT_INFO(NULL != argv, "We are expecting a non-NULL pointer\n");
+   //__halt();
 
     gVirtualToPhysicalOffset = argv->VirtualToPhysicalOffset;
+    
+    //__halt();     problema gasita in SystemPreinit();
     SystemPreinit();
 
     DumpParameters(argv);
-
+    
+    
     status = SystemInit(argv);
     ASSERT(SUCCEEDED(status));
 
diff --git a/src/HAL9000/src/_exports.yasm b/src/HAL9000/src/_exports.yasm
index 42ea13c..f7ced68 100644
--- a/src/HAL9000/src/_exports.yasm
+++ b/src/HAL9000/src/_exports.yasm
@@ -6,34 +6,23 @@ align 0x10, db 0
 [bits 64]
 ; void __cdecl* RestoreRegisters( PROCESSOR_STATE* ProcessorState )
 RestoreRegisters:
-    mov     rbx,    rcx
-
-    AlignAddressUpper   rbx, XSAVE_AREA_REQUIRED_ALIGNMENT
-
-%if INCLUDE_FP_SUPPORT
-    mov     edx,    0xFFFFFFFF
-    mov     eax,    edx
-
-    xrstor  QWORD   [rbx]
-%endif
-
-    mov     Rax,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rax]
-    mov     Rdx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdx]
-    mov     Rbx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbx]
-    mov     Rbp,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbp]
-    mov     Rsi,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rsi]
-    mov     Rdi,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdi]
-
-    mov     R8,     [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R8]
-    mov     R9,     [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R9]
-    mov     R10,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R10]
-    mov     R11,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R11]
-    mov     R12,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R12]
-    mov     R13,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R13]
-    mov     R14,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R14]
-    mov     R15,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R15]
+    mov     Rax,    [rcx+PROCESSOR_STATE.Rax]
+    mov     Rdx,    [rcx+PROCESSOR_STATE.Rdx]
+    mov     Rbx,    [rcx+PROCESSOR_STATE.Rbx]
+    mov     Rbp,    [rcx+PROCESSOR_STATE.Rbp]
+    mov     Rsi,    [rcx+PROCESSOR_STATE.Rsi]
+    mov     Rdi,    [rcx+PROCESSOR_STATE.Rdi]
+    
+    mov     R8,     [rcx+PROCESSOR_STATE.R8]
+    mov     R9,     [rcx+PROCESSOR_STATE.R9]
+    mov     R10,    [rcx+PROCESSOR_STATE.R10]
+    mov     R11,    [rcx+PROCESSOR_STATE.R11]
+    mov     R12,    [rcx+PROCESSOR_STATE.R12]   
+    mov     R13,    [rcx+PROCESSOR_STATE.R13]
+    mov     R14,    [rcx+PROCESSOR_STATE.R14]
+    mov     R15,    [rcx+PROCESSOR_STATE.R15]
 
     ; we leave rcx at the very end so we will still have a valid pointer
-    mov     Rcx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rcx]
-
+    mov     Rcx,    [rcx+PROCESSOR_STATE.Rcx]
+    
     ret
\ No newline at end of file
diff --git a/src/HAL9000/src/_isr.yasm b/src/HAL9000/src/_isr.yasm
index f0bd8f7..a513db5 100644
--- a/src/HAL9000/src/_isr.yasm
+++ b/src/HAL9000/src/_isr.yasm
@@ -1,7 +1,7 @@
 %include "lib.yasm"
 
 extern RestoreRegisters
-
+  
 %macro call_handler 2
 %if %2 == 0
     sub             rsp,        0x8
@@ -43,43 +43,43 @@ align 0x10, db 0
 [bits 64]
 DivideError:
     call_handler    0, 0
-
+    
 ; Interrupt 1 - Debug Exception (#DB)
 align 0x10, db 0
 [bits 64]
 DebugException:
     call_handler    1, 0
-
+    
 ; Interrupt 2 - NMI Interrupt
 align 0x10, db 0
 [bits 64]
 NMIInterrupt:
     call_handler    2, 0
-
+    
 ; Interrupt 3 - Breakpoint Exception (#BP)
 align 0x10, db 0
 [bits 64]
 BreakpointException:
     call_handler    3, 0
-
+    
 ; Interrupt 4 - Overflow Exception (#OF)
 align 0x10, db 0
 [bits 64]
 OverflowException:
     call_handler    4, 0
-
+    
 ; Interrupt 5 - BOUND Range Exceeded Exception (#BR)
 align 0x10, db 0
 [bits 64]
 BoundRangeExceededException:
     call_handler    5, 0
-
+    
 ; Interrupt 6 - Invalid Opcode Exception (#UD)
 align 0x10, db 0
 [bits 64]
 InvalidOpcode:
     call_handler    6, 0
-
+    
 ; Interrupt 7 - Device Not Available Exception (#NM)
 align 0x10, db 0
 [bits 64]
@@ -91,25 +91,25 @@ align 0x10, db 0
 [bits 64]
 DoubleFault:
     call_handler    8, 1
-
+    
 ; Interrupt 9 - Coprocessor Segment Overrun
 align 0x10, db 0
 [bits 64]
 CoprocessorSegmentOverrun:
     call_handler    9, 0
-
+    
 ; Interrupt 10 - Invalid TSS Exception (#TS)
 align 0x10, db 0
 [bits 64]
 InvalidTSS:
     call_handler    10, 1
-
+    
 ; Interrupt 11 - Segment Not Present (#NP)
 align 0x10, db 0
 [bits 64]
 SegmentNotPresent:
     call_handler    11, 1
-
+    
 ; Interrupt 12 - Stack Fault (#SS)
 align 0x10, db 0
 [bits 64]
@@ -127,31 +127,31 @@ align 0x10, db 0
 [bits 64]
 PageFault:
     call_handler    14, 1
-
+    
 ; Interrupt 16 - x87 FPU Floating-Point Error (#MF)
 align 0x10, db 0
 [bits 64]
 FloatingPointX87Error:
     call_handler    16, 0
-
+    
 ; Interrupt 17 - Alignment Check Exception (#AC)
 align 0x10, db 0
 [bits 64]
 AlignmentCheck:
     call_handler    17, 1
-
+    
 ; Interrupt 18 - Machine-Check Exception (#MC)
 align 0x10, db 0
 [bits 64]
 MachineCheck:
     call_handler    18, 0
-
+    
 ; Interrupt 19 - SIMD Floating-Point Exception (#XM)
 align 0x10, db 0
 [bits 64]
 FloatingPointSIMD:
     call_handler    19, 0
-
+    
 ; Interrupt 20 - Virtualization Exception (#VE)
 align 0x10, db 0
 [bits 64]
@@ -170,29 +170,29 @@ PreIsrHandler:
     ; we only read a DWORD because that's what we wrote
     ; because operand size is 32-bit on x64 upper half of
     ; register will be zeroed
-    mov             r8d, [rsp + COMPLETE_PROCESSOR_STATE_size + 8]
+    mov             r8d, [rsp + PROCESSOR_STATE_size + 8]
 
     ; 2nd argument - pointer to interrupt stack
     ; need to add an additional +0x10 because we use 2 bytes
     ; from the stack for the arguments received
-    lea             rdx, [rsp + COMPLETE_PROCESSOR_STATE_size + 0x10]
+    lea             rdx, [rsp + PROCESSOR_STATE_size + 0x10]
 
     ; 1st argument - interrupt index
-    mov             ecx, [rsp + COMPLETE_PROCESSOR_STATE_size]
+    mov             ecx, [rsp + PROCESSOR_STATE_size]
 
     call_func_64    IsrCommonHandler, rcx, rdx, r8, r9
-
+    
     mov             rcx, rsp
     call            RestoreRegisters
 
     ; restore stack
-    add             rsp, COMPLETE_PROCESSOR_STATE_size
+    add             rsp, PROCESSOR_STATE_size
 
     ; we also have the 2 arguments passed to us on the stack
     ; and the error code
     add             rsp, 0x18
-
-    iretq
+    
+    iretq  
 
 %assign     i       0x20
 %rep        224
diff --git a/src/HAL9000/src/_mboot32.yasm b/src/HAL9000/src/_mboot32.yasm
index 4048db6..7662d8f 100644
--- a/src/HAL9000/src/_mboot32.yasm
+++ b/src/HAL9000/src/_mboot32.yasm
@@ -1,7 +1,6 @@
 %include "lib.yasm"
 
 ;; IMPORTS
-extern HalActivateFpu
 extern Entry64
 
 extern PM32_to_PM64
@@ -52,7 +51,7 @@ __gdt_base:                                             ; GDT with 1+6+2 entries
 .code16             dq      GDT_DESC_CODE16
 .end
 
-; size and address of __gdt_base
+; size and address of __gdt_base 
 __gdtr:
 .gdt_size        dw  ( __gdt_base.end - __gdt_base - 1 )
 .gdt_address     dq  GDT_BASE_ADDRESS
@@ -110,7 +109,7 @@ dq          i | P_BIT | RW_BIT
 %endrep
 
 ;; KERNEL_BASE + 0x6000
-;;
+;; 
 [bits 32]
 __EntryMultiboot:
     ; make sure interrupts are disabled
@@ -125,13 +124,13 @@ __EntryMultiboot:
     ; check if we were loaded by multiboot
     cmp     eax, MULTIBOOT_LOADER_MAGIC
     jz      .mb_load
-
+   
     ; if we get here it means we were not loaded by the MB loader
-    ; we don't know any other way of loading
+    ; we don't know any other way of loading 
     mov     eax, 'EEEE'                     ; signal error
-    mov     [0x000B8000], eax
+    mov     [0x000B8000], eax 
     cli
-    hlt
+    hlt   
 
 .mb_load:
 
@@ -164,7 +163,7 @@ __EntryMultiboot:
     ; our trampoline
     mov     esi, MULTIBOOT_BASE + ( LowGdtBase - multiboot_header )
     mov     edi, LOW_GDT_BASE_ADDRESS
-    mov     ecx, LOW_MEMORY_LENGTH
+    mov     ecx, LOW_MEMORY_LENGTH 
     cld
     rep     movsb
 
@@ -186,19 +185,40 @@ __EntryMultiboot:
 
 ; after this function call we'll be in 64 bit mode
     call    PM32_to_PM64
+%ifdef DEBUG
+[bits 64]
+    sub     rsp,                                                TRANSITION_CONFIG_size
+    mov     rcx,                                                rsp
+
+    setup_transition_config_64 rcx, GDT_DESCRIPTOR_ADDRESS, INITIAL_TOP_OF_STACK, GDT_DESC(__gdt_base,code32), GDT_DESC(__gdt_base,data32), INITIAL_TOP_OF_STACK_1T
+
+    call    PM64_to_PM32
+[bits 32]
+    sub     esp,                                                TRANSITION_CONFIG_size
+    mov     ecx,                                                esp
+
+    setup_transition_config_32 ecx, GDT_DESCRIPTOR_ADDRESS, INITIAL_TOP_OF_STACK, GDT_DESC(__gdt_base,code64), GDT_DESC(__gdt_base,data64), INITIAL_TOP_OF_STACK_1T & 0xFFFFFFFF, INITIAL_TOP_OF_STACK_1T >> 32, PML4_TABLE_BASE
+    call    PM32_to_PM64
+%endif
+    
 [bits 64]
 ;
 ; now we are using final 1T virtual addresses, full x64, have an 8K stack in place, so are ready to jump to our C code
 ;
-call_final:
-    call_func_64    HalActivateFpu
-
+call_final: 
     call            PlaceInformationInParameters
 
     call_func_64    Entry64, QWORD 1, QWORD gAsmParameters
 
+    MOV     [0x000B80A0], DWORD '6040'       
+    MOV     [0x000B80A4], DWORD '-0B0'       
+    MOV     [0x000B80A8], DWORD 'I0T0'    
+
+    MOV     [0x000B8140], DWORD 'S0E0'       
+    MOV     [0x000B8144], DWORD 'C0U0'       
+    MOV     [0x000B8148], DWORD 'R0E0'
+
 .never:
-    cli
     hlt
     jmp     .never
 
@@ -209,11 +229,11 @@ PlaceInformationInParameters:
     mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.MultibootInformation
     mov     rbx,    MULTIBOOT_INFO_ADDRESS
     mov     [rax],  rbx
-
+    
     mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.KernelBaseAddress
     mov     rbx,    QWORD KERNEL_BASE_VIRTUAL
     mov     [rax],  rbx
-
+    
     mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.KernelSize
     mov     rbx,    QWORD KERNEL_LENGTH
     mov     [rax],  rbx
@@ -230,7 +250,7 @@ PlaceInformationInParameters:
     mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.MemoryMapAddress
     mov     rbx,    LOW_MEMORY_MAP_ENTRIES_ADDRESS
     mov     [rax],  rbx
-
+    
     ret
 
 .end:
\ No newline at end of file
diff --git a/src/HAL9000/src/_syscall.yasm b/src/HAL9000/src/_syscall.yasm
index 736912c..ec33098 100644
--- a/src/HAL9000/src/_syscall.yasm
+++ b/src/HAL9000/src/_syscall.yasm
@@ -27,9 +27,9 @@ SyscallEntry:
     mov     rcx, rsp
 
     ; => we have KM stack
-    mov     rsp, [rdx + 0x8]
+    mov     rsp, [rdx]
 
-    ; save current UM state (w/ RAX and RSP clobbered)
+    ; save current UM state (w/ RAX, RCX, RDX, RDI and RSP clobbered)
     save_proc_state
 
     mov             rcx, rsp
diff --git a/src/HAL9000/src/_thread.yasm b/src/HAL9000/src/_thread.yasm
index d85da68..130941d 100644
--- a/src/HAL9000/src/_thread.yasm
+++ b/src/HAL9000/src/_thread.yasm
@@ -22,7 +22,7 @@ ThreadSwitch:
     call    RestoreRegisters
 
     ; restore stack
-    add     rsp,        COMPLETE_PROCESSOR_STATE_size
+    add     rsp,        PROCESSOR_STATE_size
 
     ret
 
diff --git a/src/HAL9000/src/_trampoline.yasm b/src/HAL9000/src/_trampoline.yasm
index 7207e38..14de7cb 100644
--- a/src/HAL9000/src/_trampoline.yasm
+++ b/src/HAL9000/src/_trampoline.yasm
@@ -20,7 +20,7 @@ TrampolineStart:
 
     jmp     0:TRAMPOLINE_MEMORY_TRAMP_START + ( TrampolineStart.reloadCs - TrampolineStart )
 .reloadCs:
-    ; this is where the jump will take us
+    ; this is where the jump will take us   
     xor     ax, ax
     mov     ds, ax
     mov     es, ax
@@ -63,8 +63,7 @@ TrampolineStart:
     ; we are in 64-bits
     ; the stack will be set up by the C code
     ; so all that we'll do is a return
-    ; after we placed the first (and only) function parameter in rcx
-    mov     rcx,            [rsp + 0x10]
+    mov     rcx,            [rsp+8]
     ret
 
     hlt
@@ -75,12 +74,12 @@ TrampolineStart:
 ; LOW_RM16_PM32_ADDRESS
 ; void __cdecl RM16_to_PM32(TRANSITION_CONFIG* transitionConfig)
 RM16_to_PM32:
-    [bits 16]
+    [bits 16]       
     ;   use PUSHFD
     ;   because flags is only 16 bit while EFLAGS will be 32bit
     pushfd                      ;   save current flags
     cli
-
+    
     mov     ebx,    ecx
 
     mov     eax,    [ebx + TRANSITION_CONFIG.GdtrPhysicalAddress]
@@ -88,7 +87,7 @@ RM16_to_PM32:
     lgdt    [eax]                       ;   set the GDT
 
     mov     eax,    cr0
-    or      al,     (CR0_PE|CR0_NE)     ;   set PE and NE flag
+    or      al,     (CR0_PE|CR0_NE)     ;   set PE and NE flag 
     and     eax,    ~(CR0_CD|CR0_NW)    ;   and clear CD and NW
     mov     cr0,    eax
 
@@ -109,11 +108,11 @@ RM16_to_PM32:
     mov     gs,     ax
 
     popfd                       ;   restore flags
-
+    
     ; save RA
     movzx   edx,    WORD [esp]
     mov     esp,    [ebx + TRANSITION_CONFIG.StackPhysicalAddress]         ; we set new stack
-
+    
     push    edx
 
     ret
diff --git a/src/HAL9000/src/_transition.yasm b/src/HAL9000/src/_transition.yasm
index 3d8a405..1e0c72b 100644
--- a/src/HAL9000/src/_transition.yasm
+++ b/src/HAL9000/src/_transition.yasm
@@ -3,19 +3,6 @@
 global PM32_to_PM64
 global PM32_to_PM64End
 global PM64_to_PM32
-global ApAsmStub
-
-; This function is the one to which HalActivateFpu returns to,
-; it's responsibility is to get rid of the shadow space and of
-; setting the return functions first (and only) parameter in RCX
-align 0x10, db 0
-ApAsmStub:
-    [bits 64]
-    add     rsp, 0x20
-
-    mov     rcx, [rsp + 0x10]
-
-    ret
 
 ; this function takes the processor from 32 bit PM to 64 bit PM
 ; we must be in PM32 with Paging disabled when we call this function
@@ -23,48 +10,48 @@ ApAsmStub:
 ; void __cdecl PM32_to_PM64 (TRANSITION_CONFIG* transitionConfig)
 align 0x10, db 0
 PM32_to_PM64:
-    [bits 32]
+    [bits 32]   
     push        0
     pushfd
-
+    
     cli                     ; disable interrupts
 
     mov     ebx,    ecx
-
+    
     ; step 2
     ; enable PAE CR4.PAE = 1
     mov     eax,    cr4
     or      eax,    CR4_PAE
     mov     cr4,    eax
-
+    
     ; step 3
     ; load CR3 with phycal base address of PML4
     mov     eax,    [ebx + TRANSITION_CONFIG.Pml4PhysicalAddress]
     mov     cr3,    eax
-
+    
     ; step 4
     ; Set IA32_EFER.LME = 1
     ; also enable NX functionality
     mov     ecx, IA32_EFER
-    rdmsr
+    rdmsr                          
     or      eax, ( IA32_EFER_LME | IA32_EFER_NXE )
     wrmsr
-
+    
     mov     eax, [ebx + TRANSITION_CONFIG.GdtrPhysicalAddress]
 
     ; load the new GDT and go to real 64-bit mode
-    lgdt    [eax]
-
+    lgdt    [eax] 
+    
     ; step 5
     ; enable paging
     mov     eax, cr0
     or      eax, (CR0_PG | CR0_WP | CR0_NE) ; use WP, also clear CD and NW in case
     and     eax, ~(CR0_CD | CR0_NW )        ; those flags are set
-    mov     cr0, eax
-
+    mov     cr0, eax 
+    
     ; Vol 3B 8.3
-    ; When an instruction is executed that enables or disables paging (that is,
-    ; changes the PG flag in control register CR0), the instruction should be
+    ; When an instruction is executed that enables or disables paging (that is, 
+    ; changes the PG flag in control register CR0), the instruction should be 
     ; followed by a jump instruction
 
     ; The Pentium 4, Intel Xeon, and P6 family processors do not require
@@ -72,7 +59,7 @@ PM32_to_PM64:
     ; Intel Xeon, or P6 family processor to write to CR0 is completely serializing). However, to maintain backwards
     ; and forward compatibility with code written to run on other IA-32 processors, it is recommended that the jump
     ; operation be performed.
-
+        
     ; CONCLUSION: because we will be running on new processors, we DON't need a jump
 
 ;
@@ -103,7 +90,7 @@ PM32_to_PM64:
     mov     ax, [rbx + TRANSITION_CONFIG.DataSelector]
     mov     fs, ax
     mov     gs, ax
-
+    
     ; TOFIND: should SS be 0 in x64?
 [bits 32]
     mov     ss, ax
@@ -120,18 +107,18 @@ PM32_to_PM64:
 
     push    rcx
     popfq                           ; we restore the original flags
-
+    
     mov     rcx, rdx                            ; PA's 32Mb-64Mb are mapped to 1T+
     sub     rcx, KERNEL_BASE                    ; that's why we subtract the KERNEL_BASE
     mov     rdx, QWORD KERNEL_BASE_VIRTUAL      ; so that we get the VA pointing to the same
-    add     rdx, rcx                            ; PA
-
+    add     rdx, rcx                            ; PA   
+    
     add     rsp, TRANSITION_CONFIG_size
     push    rdx
-
+    
     ret
 PM32_to_PM64End:
-
+    
 ; void __cdecl PM64_to_PM32 (CPU_CONFIG_ENTRY* cpuConfigEntry)
 align 0x10, db 0
 PM64_to_PM32:
@@ -144,30 +131,30 @@ PM64_to_PM32:
     mov     esp,    [rbx + TRANSITION_CONFIG.StackPhysicalAddress]
     sub     esp,    TRANSITION_CONFIG_size
 
-    ; now we are using identity mappings
+    ; now we are using identity mappings   
     xor     eax, eax
     mov     ax, [rbx + TRANSITION_CONFIG.CodeSelector]
     push    rax                     ; this is a MUST, because retf will pop out 4 bytes for CS (OPE found out this ;-)
-                                    ; and 'push rax' actually means 'push eax', because we still run in 32 bit compat mode
-
-    call    $ + 5                   ; place return EIP onto the stack
-
+                                    ; and 'push rax' actually means 'push eax', because we still run in 32 bit compat mode                           
+                                    
+    call    $ + 5                   ; place return EIP onto the stack   
+    
     mov     rax,  ( KERNEL_BASE - KERNEL_BASE_VIRTUAL ) + 15                ; instrux length to continue right after 'retf'
     add     [rsp], eax
     retf                            ; actually a retfq ( also uses CS saved on stack besides RA )
-
+    
     ; now we are in compatibility mode
-
+        
     mov     rax,    cr0
     and     eax,    ~( CR0_CD | CR0_NW | CR0_PG )       ; disable Paging, CD and NW
     mov     cr0,    rax
-
+    
     ; Set IA32_EFER.LME = 0
     mov     ecx, IA32_EFER
-    rdmsr
-    and      eax, ~IA32_EFER_LME
+    rdmsr                          
+    and      eax, ~IA32_EFER_LME     
     wrmsr
-
+    
     ; We also need to disable PAE
     mov     rax,    cr4
     and     eax,    ~( CR4_PAE )
@@ -183,7 +170,7 @@ PM64_to_PM32:
     retf                            ; actually a retfq ( also uses CS saved on stack besides RA )
 [bits 32]
     .bits32:
-
+        
     ; set the data descriptors
     mov     ax, [ebx + TRANSITION_CONFIG.DataSelector]
     mov     ds, ax
@@ -191,15 +178,15 @@ PM64_to_PM32:
     mov     ss, ax
     mov     fs, ax
     mov     gs, ax
-
+    
     xor     eax,    eax             ; According to Vol3 9.9.2 placing a zero in CR3
     mov     cr3,    eax             ; forces a TLB flush
 
     add     esp,    TRANSITION_CONFIG_size
     push    ebp
-
+    
     ; we must subtract the difference (it will only substract the low DWORD)
-    mov     eax,    DWORD( KERNEL_BASE - KERNEL_BASE_VIRTUAL )
+    mov     eax,    DWORD( KERNEL_BASE - KERNEL_BASE_VIRTUAL )      
     add     [esp],  eax                                     ; VA to the appropriate PA
-
+    
     ret
\ No newline at end of file
diff --git a/src/HAL9000/src/acpi_interface.c b/src/HAL9000/src/acpi_interface.c
index c6f0606..cb4913d 100644
--- a/src/HAL9000/src/acpi_interface.c
+++ b/src/HAL9000/src/acpi_interface.c
@@ -107,6 +107,7 @@ AcpiInterfacePreinit(
     InitializeListHead(&m_acpiData.PrtList);
 }
 
+SAL_SUCCESS
 STATUS
 AcpiInterfaceInit(
     void
@@ -189,6 +190,7 @@ AcpiShutdown(
     NOT_REACHED;
 }
 
+SAL_SUCCESS
 STATUS
 AcpiInterfaceLateInit(
     void
@@ -233,13 +235,15 @@ AcpiInterfaceLateInit(
     status = _AcpiInterfaceParsePrts();
     if (!SUCCEEDED(status))
     {
-        LOG_WARNING("_AcpiInterfaceParsePrts failed with status 0x%x\n", status);
+        LOG_FUNC_ERROR("_AcpiInterfaceParsePrts", status);
+        return status;
     }
     LOGL("Successfully parsed PRTs\n");
 
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextCpu(
     IN      BOOLEAN                     RestartSearch,
@@ -273,6 +277,7 @@ AcpiRetrieveNextCpu(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextIoApic(
     IN      BOOLEAN                     RestartSearch,
@@ -306,6 +311,7 @@ AcpiRetrieveNextIoApic(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextInterruptOverride(
     IN      BOOLEAN                         RestartSearch,
@@ -339,6 +345,7 @@ AcpiRetrieveNextInterruptOverride(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextMcfgEntry(
     IN      BOOLEAN                     RestartSearch,
@@ -372,6 +379,7 @@ AcpiRetrieveNextMcfgEntry(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 AcpiRetrieveNextPrtEntry(
     IN      BOOLEAN                     RestartSearch,
@@ -584,7 +592,7 @@ _AcpiInterfaceParsePrts(
     acpiStatus = AcpiEvaluateObject(NULL, "\\_PIC", &argList, NULL);
     if (ACPI_FAILURE(acpiStatus))
     {
-        LOG_WARNING("AcpiEvaluateObject failed with status 0x%x - Couldn't locate ACPI \\\\_PIC method\n", acpiStatus);
+        LOG_FUNC_ERROR("AcpiEvaluateObject", acpiStatus);
         return STATUS_UNSUCCESSFUL;
     }
 
@@ -695,11 +703,8 @@ _AcpiInterfaceDeviceWalkCallback(
                     LOG_FUNC_ERROR("IoGetPciDevicesMatchingLocation", status);
                     acpiStatus = AE_BAD_DATA;
                 }
-                else
-                {
-                    acpiStatus = AE_OK;
-                }
 
+                acpiStatus = AE_OK;
                 __leave;
             }
         }
diff --git a/src/HAL9000/src/acpi_osl.c b/src/HAL9000/src/acpi_osl.c
index 153f0d8..bed21a5 100644
--- a/src/HAL9000/src/acpi_osl.c
+++ b/src/HAL9000/src/acpi_osl.c
@@ -173,7 +173,7 @@ void
 AcpiOsDeleteLock (
     ACPI_SPINLOCK           Handle)
 {
-    ASSERT(NULL != Handle);
+    ASSERT (NULL != Handle)
 
     LOG_FUNC_START;
 
@@ -196,9 +196,6 @@ AcpiOsAcquireLock (
 
     LockAcquire((PLOCK) Handle, &intrState);
 
-    // Warning C26165 Possibly failing to release lock
-    // Because we can't modify the ACPICA headers we have nothing to do but suppress the warning
-#pragma warning(suppress: 26165)
     return intrState;
 }
 #endif
@@ -211,14 +208,8 @@ AcpiOsReleaseLock (
 {
     ASSERT( NULL != Handle );
 
-    // Warning C26110 Caller failing to hold lock before calling function
-    // Because we can't modify the ACPICA headers we have nothing to do but suppress the warning
-#pragma warning(suppress: 26110)
     LockRelease(Handle, (INTR_STATE) Flags);
 
-    // Warning C26167 Possibly releasing unheld lock
-    // Because we can't modify the ACPICA headers we have nothing to do but suppress the warning
-#pragma warning(suppress: 26167)
     return;
 }
 #endif
@@ -472,7 +463,9 @@ AcpiOsUnmapMemory (
     LOG_TRACE_ACPI( "AcpiOsUnmapMemory about to unmap 0x%X bytes starting at VA 0x%X PA 0x%X\n",
         Size, LogicalAddress, MmuGetPhysicalAddress(LogicalAddress) );
 
-    MmuUnmapSystemMemory( LogicalAddress, ( DWORD ) Size );
+    // It would be dangerous to unmap the memory because it may be used by other
+    // components as well
+    //UnmapMemory( LogicalAddress, ( DWORD ) Size );
 
     LOG_FUNC_END;
 }
@@ -921,14 +914,14 @@ AcpiOsWritePciConfiguration (
     PCI_DEVICE_LOCATION pciDevice;
     STATUS status;
 
+    ASSERT(0 == PciId->Segment);
+    ASSERT(IsAddressAligned(Reg, Width / BITS_PER_BYTE));
+
     if ((NULL == PciId) || (Reg > MAX_WORD) || (Width > BITS_FOR_STRUCTURE(QWORD)))
     {
         return AE_BAD_PARAMETER;
     }
 
-    ASSERT(0 == PciId->Segment);
-    ASSERT(IsAddressAligned(Reg, Width / BITS_PER_BYTE));
-
     memzero(&pciDevice, sizeof(PCI_DEVICE_LOCATION));
     status = STATUS_SUCCESS;
 
@@ -1350,20 +1343,3 @@ AcpiOsSetFileOffset (
     return AE_OK;
 }
 #endif
-
-#undef memset
-#ifdef NDEBUG
-#pragma function(memset)
-#endif
-_At_buffer_(address, i, size, _Post_satisfies_(((PBYTE)address)[i] == value))
-void*
-memset(
-    OUT_WRITES_BYTES_ALL(size)  PVOID address,
-    IN                          BYTE value,
-    IN                          DWORD size
-)
-{
-    cl_memset(address, value, size);
-
-    return address;
-}
diff --git a/src/HAL9000/src/ap_tramp.c b/src/HAL9000/src/ap_tramp.c
index e39c28c..7ec9cc3 100644
--- a/src/HAL9000/src/ap_tramp.c
+++ b/src/HAL9000/src/ap_tramp.c
@@ -29,9 +29,6 @@ extern void LowGdtTable();
 extern void LowGdtTableEnd();
 
 #pragma pack(push,1)
-
-#pragma warning(push)
-
 // warning C4200: nonstandard extension used: zero-sized array in struct/union
 #pragma warning(disable:4200)
 
@@ -60,9 +57,10 @@ typedef struct _LOW_MEMORY_CONFIG
     SYSTEM_CONFIG       SystemConfig;
     AP_CONFIG_ENTRY     ApConfig[0];
 } LOW_MEMORY_CONFIG, *PLOW_MEMORY_CONFIG;
-#pragma warning(pop)
+#pragma warning(default:4200)
 #pragma pack(pop)
 
+SAL_SUCCESS
 STATUS
 ApTrampSetupLowerMemory(
     IN      PLIST_ENTRY     CpuList,
@@ -253,21 +251,10 @@ ApInitCpu(
 
     CHECK_STACK_ALIGNMENT;
 
-    status = STATUS_SUCCESS;
-
     LOGPL("Hello C!, CPU at: 0x%X\n", Cpu);
 
     // we need to reload GDT with new one
-    GdtMuReload(GdtMuGetCS64Supervisor(), GdtMuGetDS64Supervisor(), FALSE, FALSE);
-
-    __try
-    {
-        status = CpuMuActivateFpuFeatures();
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("CpuMuActivateFpuFeatures", status);
-            __leave;
-        }
+    GdtReload(GdtMuGetCS64Supervisor(), GdtMuGetDS64Supervisor());
 
     // reload IDT
     IdtReload();
@@ -276,7 +263,7 @@ ApInitCpu(
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("CpuMuInitCpu", status );
-            __leave;
+        NOT_REACHED;
     }
 
     MmuActivateProcessIds();
@@ -285,14 +272,10 @@ ApInitCpu(
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
-            __leave;
+        NOT_REACHED;
     }
 
     // exit main thread
     ThreadExit(STATUS_SUCCESS);
-    }
-    __finally
-    {
     NOT_REACHED;
-    }
 }
\ No newline at end of file
diff --git a/src/HAL9000/src/boot_module.c b/src/HAL9000/src/boot_module.c
index fa93190..e68dce5 100644
--- a/src/HAL9000/src/boot_module.c
+++ b/src/HAL9000/src/boot_module.c
@@ -105,7 +105,7 @@ BootModulesInit(
             status = _MapSingleModule(&pModuleInformation[i], &pMultibootModules[i]);
             if (!SUCCEEDED(status))
             {
-                LOG_WARNING("_MapSingleModule failed with status 0x%x\n", status);
+                LOG_FUNC_ERROR("_MapSingleModule", status);
 
                 // This component (boot_module.c) doesn't know which modules are essential and which are not
                 // so we do our best effort to map as many modules as possible even if some fail
@@ -247,7 +247,7 @@ _MapSingleModule(
 
         if (bootMod.Length == 0)
         {
-            LOG_WARNING("There's nothing we can do with a module with size 0!\n");
+            LOG_ERROR("There's nothing we can do with a module with size 0!\n");
             status = STATUS_NO_DATA_AVAILABLE;
             __leave;
         }
diff --git a/src/HAL9000/src/cmd_basic.c b/src/HAL9000/src/cmd_basic.c
index 312b097..19a47c2 100644
--- a/src/HAL9000/src/cmd_basic.c
+++ b/src/HAL9000/src/cmd_basic.c
@@ -25,8 +25,6 @@ CmdPrintVolumeInformation(
     IomuExecuteForEachVpb(DumpVpb, NULL, FALSE);
 }
 
-#pragma warning(push)
-
 // warning C4717: '_CmdInfiniteRecursion': recursive on all control paths, function will cause runtime stack overflow
 #pragma warning(disable:4717)
 void
@@ -38,7 +36,7 @@ CmdInfiniteRecursion(
 
     CmdInfiniteRecursion(NumberOfParameters);
 }
-#pragma warning(pop)
+#pragma warning(default:4717)
 
 void
 CmdRtcFail(
diff --git a/src/HAL9000/src/cmd_fs_helper.c b/src/HAL9000/src/cmd_fs_helper.c
index d9aa9f8..de090a8 100644
--- a/src/HAL9000/src/cmd_fs_helper.c
+++ b/src/HAL9000/src/cmd_fs_helper.c
@@ -7,8 +7,6 @@
 #include "os_time.h"
 
 #include "dmp_memory.h"
-#include "strutils.h"
-#include "iomu.h"
 
 #pragma warning(push)
 
@@ -369,246 +367,6 @@ void
     }
 }
 
-void
-(__cdecl CmdWriteFile)(
-    IN      QWORD       NumberOfParameters,
-    IN_Z    char*       File,
-    IN_Z    char*       CharToWrite,
-    IN_Z    char*       Extend,
-    IN_Z    char*       Async
-    )
-{
-    STATUS status;
-    PFILE_OBJECT pFileObject;
-    QWORD bytesWritten;
-    FILE_INFORMATION fileInformation;
-    PBYTE pData;
-    QWORD bytesRemaining;
-    DWORD allocationSize;
-    DWORD bytesToWrite;
-    QWORD fileOffset;
-    char  charToWrite;
-    BOOLEAN bExtend;
-    BOOLEAN bAsync;
-
-    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 4);
-
-    if (NULL == File)
-    {
-        return;
-    }
-
-    status = STATUS_SUCCESS;
-    pFileObject = NULL;
-    bytesWritten = 0;
-    memzero(&fileInformation, sizeof(FILE_INFORMATION));
-    pData = NULL;
-    bytesRemaining = 0;
-    allocationSize = 0;
-    bytesToWrite = 0;
-    fileOffset = 0;
-    charToWrite = (NumberOfParameters >= 2) ? CharToWrite[0] : 'x';
-    bExtend = (NumberOfParameters >= 3) ? (stricmp(Extend, "ext") == 0) : FALSE;
-    bAsync = (NumberOfParameters >= 4) ? (stricmp(Async, "async") == 0) : FALSE;
-
-    printf("Will open file %s\n", File);
-
-    status = IoCreateFile(&pFileObject,
-        File,
-        FALSE,
-        FALSE,
-        bAsync
-    );
-    if (!SUCCEEDED(status))
-    {
-        perror("IoCreateFile failed with status: 0x%x\n", status);
-        return;
-    }
-
-    printf("IoCreateFile succeeded\n");
-
-    __try
-    {
-        status = IoQueryInformationFile(pFileObject,
-            &fileInformation
-        );
-        if (!SUCCEEDED(status))
-        {
-            perror("IoQueryInformationFile failed with status: 0x%x\n", status);
-            __leave;
-        }
-
-        printf("IoQueryInformationFile succeeded\n");
-
-        bytesRemaining = fileInformation.FileSize;
-        bytesRemaining += bExtend ? 9 * 0x200 : 0;
-        allocationSize = (DWORD)min(fileInformation.FileSize, CMD_READFILE_BYTES_TO_READ_AT_A_TIME);
-        allocationSize = (DWORD)min(fileInformation.FileSize, 1 * 0x200);
-
-        pData = ExAllocatePoolWithTag(0, allocationSize, HEAP_TEMP_TAG, 0);
-        if (NULL == pData)
-        {
-            perror("HeapAllocatePoolWithTag failed for file size: %D KB\n", allocationSize / KB_SIZE);
-            __leave;
-        }
-
-        printf("HeapAllocatePoolWithTag succeeded\n");
-
-        memset(pData, charToWrite, allocationSize);
-        DWORD i = 0;
-        while (0 != bytesRemaining)
-        {
-            sprintf((char*)pData, "%02dsector", i++);
-            bytesToWrite = (DWORD)min(bytesRemaining, allocationSize);
-
-            status = IoWriteFile(pFileObject,
-                bytesToWrite,
-                &fileOffset,
-                pData,
-                &bytesWritten
-            );
-            if (!SUCCEEDED(status))
-            {
-                perror("IoWriteFile failed with status: 0x%x\n", status);
-                __leave;
-            }
-            printf("bytesWritten = %X\n", bytesWritten);
-            ASSERT(bytesToWrite == bytesWritten);
-
-            //DumpMemory(pData, fileOffset, (DWORD)bytesWritten, TRUE, TRUE);
-
-            bytesRemaining = bytesRemaining - bytesWritten;
-            fileOffset = fileOffset + bytesWritten;
-        }
-    }
-    __finally
-    {
-        if (NULL != pFileObject)
-        {
-            status = IoCloseFile(pFileObject);
-            if (!SUCCEEDED(status))
-            {
-                perror("IoCloseFIle failed with status: 0x%x\n", status);
-            }
-            else
-            {
-                printf("IoCloseFile succeeded\n");
-            }
-
-            pFileObject = NULL;
-        }
-
-        if (NULL != pData)
-        {
-            ExFreePoolWithTag(pData, HEAP_TEMP_TAG);
-            pData = NULL;
-        }
-    }
-}
-
-void
-(__cdecl CmdSwap)(
-    IN      QWORD       NumberOfParameters,
-    IN_Z    char*       Operation,
-    IN_Z    char*       OffsetString
-    )
-{
-    BOOLEAN bPerformWrite;
-    QWORD offset;
-    PFILE_OBJECT pSwapFile;
-    STATUS status;
-    QWORD bytesTransmitted;
-    PBYTE pData;
-    QWORD swapFileSize;
-
-    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 2);
-
-    bPerformWrite = (strcmp(Operation, "W") == 0);
-    offset = 0;
-    pSwapFile = NULL;
-    status = STATUS_SUCCESS;
-    bytesTransmitted = 0;
-    pData = NULL;
-
-    if (NumberOfParameters == 2)
-    {
-        atoi64(&offset, OffsetString, BASE_HEXA);
-    }
-
-    pSwapFile = IomuGetSwapFile();
-    if (pSwapFile == NULL)
-    {
-        LOG_ERROR("System has no swap file!\n");
-        return;
-    }
-
-    status = IoGetFileSize(pSwapFile, &swapFileSize);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("IoGetFileSize", status);
-        return;
-    }
-
-    LOG("System has a swap file of size %U KB [%U MB]\n",
-        swapFileSize / KB_SIZE, swapFileSize / MB_SIZE);
-
-    __try
-    {
-        pData = ExAllocatePoolWithTag(0, PAGE_SIZE, HEAP_TEMP_TAG, 0);
-        if (pData == NULL)
-        {
-            LOG_FUNC_ERROR_ALLOC("ExAllocatedPoolWithTag", PAGE_SIZE);
-            status = STATUS_INSUFFICIENT_MEMORY;
-            __leave;
-        }
-
-        if (bPerformWrite)
-        {
-            PQWORD pOffsets = (PQWORD) pData;
-            for (DWORD i = 0; i < PAGE_SIZE / sizeof(QWORD); ++i)
-            {
-                pOffsets[i] = offset + i * sizeof(QWORD);
-            }
-
-            status = IoWriteFile(pSwapFile,
-                                 PAGE_SIZE,
-                                 &offset,
-                                 pData,
-                                 &bytesTransmitted);
-        }
-        else
-        {
-            status = IoReadFile(pSwapFile,
-                                PAGE_SIZE,
-                                &offset,
-                                pData,
-                                &bytesTransmitted);
-        }
-        if (!SUCCEEDED(status))
-        {
-            LOG_ERROR("[%s] Operation failed with status 0x%x at offset 0x%X\n",
-                      bPerformWrite ? "WRITE" : "READ",
-                      status,
-                      offset);
-            __leave;
-        }
-        ASSERT(bytesTransmitted == PAGE_SIZE);
-
-        if (!bPerformWrite)
-        {
-            DumpMemory(pData, 0, PAGE_SIZE, FALSE, TRUE);
-        }
-    }
-    __finally
-    {
-        if (pData != NULL)
-        {
-            ExFreePoolWithTag(pData, HEAP_TEMP_TAG);
-            pData = NULL;
-        }
-    }
-}
-
 static
 void
 _DisplayDirectoryInformation(
diff --git a/src/HAL9000/src/cmd_interpreter.c b/src/HAL9000/src/cmd_interpreter.c
index d0b254f..9d6e9c7 100644
--- a/src/HAL9000/src/cmd_interpreter.c
+++ b/src/HAL9000/src/cmd_interpreter.c
@@ -52,15 +52,12 @@ static const COMMAND_DEFINITION COMMANDS[] =
     { "cls", "Clears screen", CmdClearScreen, 0, 0},
 
     { "vol", "Displays volumes", CmdPrintVolumeInformation, 0, 0},
-    { "less", "$FILENAME [async]\n\tdisplay $FILENAME contents\n\tasync - use DMA read instead of polling", CmdReadFile, 1, 2 },
-    { "fwrite", "$FILENAME [char] [ext] [async]\n\twrite predefined buffer into $FILENAME\n\text - if 'ext' then extend file size\n\tasync - use DMA read instead of polling", CmdWriteFile, 1, 4},
+    { "less", "$FILENAME [async]\n\tdisplay $FILENAME contents\n\tasync - use DMA read instead of polling", CmdReadFile, 1, 2},
     { "stat", "$FILENAME\n\tdisplays $FILENAME information", CmdStatFile, 1, 1},
     { "mkdir", "$DIRECTORY\n\tcreates a new directory", CmdMakeDirectory, 1, 1},
     { "touch", "$FILENAME\n\tcreates a new file", CmdMakeFile, 1, 1},
     { "ls", "$DIRECTORY [-R]\n\tlists directory contents\n\tif -R specified goes recursively", CmdListDirectory, 1, 2},
 
-    { "swap", "R|W [0x$OFFSET]\n\t$OFFSET - offset inside swap where to perform operation", CmdSwap, 1, 2},
-
     { "cpu", "Displays CPU related information", CmdListCpus, 0, 0},
     { "int", "List interrupts received", CmdListCpuInterrupts, 0, 0},
     { "yield", "Yields processor", CmdYield, 0, 0},
@@ -84,12 +81,10 @@ static const COMMAND_DEFINITION COMMANDS[] =
 
     { "rdmsr", "0x$INDEX\n\t$INDEX is the MSR to read", CmdRdmsr, 1, 1},
     { "wrmsr", "0x$INDEX 0x$VALUE\n\t$INDEX is the MSR to write\n\t$VALUE is the value to place in the MSR", CmdWrmsr, 2, 2},
-    { "chkad", "Check if paging accessed/dirty bits mechanism is working", CmdCheckAd, 0, 0},
-    { "spawn", "$CPU_BOUND $IO_BOUND\n\tNumber of CPU bound threads to spawn\n\tNumber of IO bound threads to spawn", CmdSpawnThreads, 2, 2},
     { "cpuid", "[0x$INDEX] [0x$SUBINDEX]\n\tIf index is not specified lists all available CPUID values"
                 "\n\tIf subindex is specified displays subleaf information", CmdCpuid, 0, 2},
     { "ipi", "$MODE [$DEST] {$WAIT]\n\tSee SMP_IPI_SEND_MODE for destination mode\n\t$DEST - processor IDs"
-              "\n\tIf last parameter is specified will wait until all CPUs acknowledge IPI", CmdSendIpi, 1, 3},
+              "\n\tIf last parameter is specified will wait untill all CPUs acknowledge IPI", CmdSendIpi, 1, 3},
 
     { "networks", "Displays network information", CmdListNetworks, 0, 0},
     { "netrecv", "[YES|NO] - receive network packets\n\tIf yes will resend the packets received, if no it will not", CmdNetRecv, 0, 1},
@@ -207,6 +202,8 @@ CmdRun(
     exit = _CmdExecuteModuleCommands();
     while (!exit)
     {
+        CmdInfiniteRecursion(0);
+
         gets_s(buffer, CHARS_PER_LINE, &bytesRead);
 
         exit = _CmdExecLine(buffer, bytesRead);
@@ -309,7 +306,7 @@ _CmdExecuteModuleCommands(
     status = BootModuleGet("Tests", &pBaseAddress, &modLen);
     if (!SUCCEEDED(status))
     {
-        LOG_WARNING("BootModuleGet failed with status 0x%x for Tests module\n", status);
+        LOG_FUNC_ERROR("BootModuleGet", status);
         return FALSE;
     }
 
diff --git a/src/HAL9000/src/cmd_proc_helper.c b/src/HAL9000/src/cmd_proc_helper.c
index c630d8f..107f9ba 100644
--- a/src/HAL9000/src/cmd_proc_helper.c
+++ b/src/HAL9000/src/cmd_proc_helper.c
@@ -172,7 +172,7 @@ void
 
     if (!bFoundTest)
     {
-        LOG_WARNING("Test [%s] does not exist. Try one of the following tests:\n", TestName);
+        pwarn("Test [%s] does not exist. Try one of the following tests:\n", TestName);
         _CmdHelperPrintProcessFunctions();
     }
     else
diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
index f794c95..94de70f 100644
--- a/src/HAL9000/src/cmd_thread_helper.c
+++ b/src/HAL9000/src/cmd_thread_helper.c
@@ -14,9 +14,6 @@
 #include "strutils.h"
 #include "smp.h"
 #include "ex_timer.h"
-#include "vmm.h"
-#include "pit.h"
-
 
 #pragma warning(push)
 
@@ -28,22 +25,6 @@
 
 static FUNC_IpcProcessEvent _CmdIpiCmd;
 
-#define CPU_BOUND_CPU_USAGE         (100 * MS_IN_US)
-#define IO_BOUND_CPU_USAGE          (0 * MS_IN_US)
-#define IO_BOUND_EVENT_TIMES        25
-
-typedef struct _BOUND_THREAD_CTX
-{
-    DWORD                   CpuUsage;
-
-    // Valid only for IO bound threads
-    DWORD                   EventWaitTimes;
-    EX_EVENT                Event;
-} BOUND_THREAD_CTX, *PBOUND_THREAD_CTX;
-
-static FUNC_ThreadStart     _ThreadCpuBound;
-static FUNC_ThreadStart     _ThreadIoBound;
-
 static
 void
 _CmdHelperPrintThreadFunctions(
@@ -129,15 +110,14 @@ void
 
     ASSERT(NumberOfParameters == 0);
 
-    LOG("%7s", "TID|");
-    LOG("%20s", "Name|");
-    LOG("%5s", "Prio|");
-    LOG("%8s", "State|");
-    LOG("%10s", "Cmp ticks|");
-    LOG("%10s", "Prt ticks|");
-    LOG("%10s", "Ttl ticks|");
-    LOG("%10s", "Process|");
-    LOG("\n");
+    printColor(MAGENTA_COLOR, "%7s", "TID|");
+    printColor(MAGENTA_COLOR, "%20s", "Name|");
+    printColor(MAGENTA_COLOR, "%5s", "Prio|");
+    printColor(MAGENTA_COLOR, "%8s", "State|");
+    printColor(MAGENTA_COLOR, "%10s", "Cmp ticks|");
+    printColor(MAGENTA_COLOR, "%10s", "Prt ticks|");
+    printColor(MAGENTA_COLOR, "%10s", "Ttl ticks|");
+    printColor(MAGENTA_COLOR, "%10s", "Process|");
 
     status = ThreadExecuteForEachThreadEntry(_CmdThreadPrint, NULL );
     ASSERT( SUCCEEDED(status));
@@ -463,200 +443,6 @@ void
     __writemsr(index, value );
 }
 
-void
-(__cdecl CmdCheckAd)(
-    IN      QWORD       NumberOfParameters
-    )
-{
-    DWORD dirtyCount;
-    DWORD accessedCount;
-    volatile BYTE* pData;
-    PML4 cr3;
-
-    ASSERT(NumberOfParameters == 0);
-
-    dirtyCount = 0;
-    accessedCount = 0;
-    pData = NULL;
-    cr3.Raw = (QWORD) __readcr3();
-
-    pData = ExAllocatePoolWithTag(PoolAllocateZeroMemory, PAGE_SIZE, HEAP_TEMP_TAG, PAGE_SIZE);
-    if (pData == NULL)
-    {
-        return;
-    }
-
-    __try
-    {
-        for (DWORD i = 0; i < PAGE_SIZE; ++i)
-        {
-            BOOLEAN bAccessed = FALSE;
-            BOOLEAN bDirty = FALSE;
-
-            PHYSICAL_ADDRESS pAddr = VmmGetPhysicalAddressEx(cr3,
-                                                             (PVOID) pData,
-                                                             &bAccessed,
-                                                             &bDirty);
-            ASSERT(pAddr != NULL);
-
-            accessedCount += (bAccessed == TRUE);
-            dirtyCount += (bDirty == TRUE);
-
-        }
-    }
-    __finally
-    {
-        ASSERT(pData != NULL);
-            ExFreePoolWithTag((PVOID)pData, HEAP_TEMP_TAG);
-            pData = NULL;
-        }
-
-    LOG("A/D: %u/%u\n", accessedCount, dirtyCount);
-}
-
-void
-(__cdecl CmdSpawnThreads)(
-    IN      QWORD       NumberOfParameters,
-    IN_Z    char*       CpuBoundString,
-    IN_Z    char*       IoBoundString
-    )
-{
-    DWORD cpuBound;
-    DWORD ioBound;
-    PTHREAD* pThreads;
-    PBOUND_THREAD_CTX pCtx;
-    STATUS status;
-
-    ASSERT(NumberOfParameters == 2);
-
-    atoi32(&cpuBound, CpuBoundString, BASE_TEN);
-    atoi32(&ioBound, IoBoundString, BASE_TEN);
-
-    pThreads = NULL;
-    pCtx = NULL;
-
-    LOG("Will spawn %u CPU bound threads and %u IO bound threads\n",
-        cpuBound, ioBound);
-
-    if (cpuBound == 0 || ioBound == 0)
-    {
-        return;
-    }
-
-    __try
-    {
-        pThreads = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
-                                         sizeof(PTHREAD) * (cpuBound + ioBound),
-                                         HEAP_TEST_TAG,
-                                         0);
-        if (pThreads == NULL)
-        {
-            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PTHREAD) * (cpuBound + ioBound));
-            __leave;
-        }
-
-        pCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
-                                     sizeof(BOUND_THREAD_CTX) * (cpuBound + ioBound),
-                                     HEAP_TEST_TAG,
-                                     0);
-        if (pCtx == NULL)
-        {
-            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(BOUND_THREAD_CTX) * (cpuBound + ioBound));
-            __leave;
-        }
-
-        // Create the CPU bound threads to execute the _ThreadCpuBound function
-        // Each thread will keep the processor busy for CPU_BOUND_CPU_USAGE us (currently 100 ms)
-        for (DWORD i = 0; i < cpuBound; ++i)
-        {
-            char thName[MAX_PATH];
-
-            snprintf(thName, MAX_PATH, "CPU-bound-%u", i);
-
-            pCtx[i].CpuUsage = CPU_BOUND_CPU_USAGE;
-
-            status = ThreadCreate(thName,
-                                  ThreadPriorityDefault,
-                                  _ThreadCpuBound,
-                                  &pCtx[i],
-                                  &pThreads[i]);
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("ThreadCreate", status);
-                __leave;
-            }
-        }
-
-        // Create the IO bound threads to execute the _ThreadIoBound function
-        // These threads will block waiting for an executive event IO_BOUND_EVENT_TIMES times (currently 25 seconds)
-        // After they will be woken up they will also keep the CPU busy for IO_BOUND_CPU_USAGE us (currently 0 ms)
-        for (DWORD i = 0; i < ioBound; ++i)
-        {
-            char thName[MAX_PATH];
-
-            snprintf(thName, MAX_PATH, "IO-bound-%u", i);
-
-            pCtx[i+cpuBound].EventWaitTimes = IO_BOUND_EVENT_TIMES;
-            pCtx[i+cpuBound].CpuUsage = IO_BOUND_CPU_USAGE;
-            ExEventInit(&pCtx[i+cpuBound].Event, ExEventTypeSynchronization, FALSE);
-
-            status = ThreadCreate(thName,
-                                  ThreadPriorityDefault,
-                                  _ThreadIoBound,
-                                  &pCtx[i+cpuBound],
-                                  &pThreads[i+cpuBound]);
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("ThreadCreate", status);
-                __leave;
-            }
-        }
-
-        // The main thread will signal all the IO bound events every 50 ms thus waking the IO bound threads
-        for (DWORD i = 0; i < IO_BOUND_EVENT_TIMES; ++i)
-        {
-            PitSleep(50 * MS_IN_US);
-            for (DWORD j = 0; j < ioBound; ++j)
-            {
-                ExEventSignal(&pCtx[j+cpuBound].Event);
-            }
-        }
-
-        // Wait for all the threads to finish their execution
-        for (DWORD i = 0; i < cpuBound + ioBound; ++i)
-        {
-            ThreadWaitForTermination(pThreads[i],
-                                     &status);
-        }
-
-        // List the threads statistics
-        CmdListThreads(0);
-
-        // Actually close the thread handles so the thread structures can be destroyed
-        for (DWORD i = 0; i < cpuBound + ioBound; ++i)
-        {
-            ThreadCloseHandle(pThreads[i]);
-        }
-    }
-    __finally
-    {
-        if (pCtx != NULL)
-        {
-            ExFreePoolWithTag(pCtx, HEAP_TEST_TAG);
-            pCtx = NULL;
-        }
-
-        if (pThreads != NULL)
-        {
-            ExFreePoolWithTag(pThreads, HEAP_TEST_TAG);
-            pThreads = NULL;
-        }
-    }
-
-
-
-}
-
 static
 void
 _CmdHelperPrintThreadFunctions(
@@ -672,6 +458,7 @@ _CmdHelperPrintThreadFunctions(
 }
 
 static
+SAL_SUCCESS
 STATUS
 (__cdecl _CmdThreadPrint) (
     IN      PLIST_ENTRY     ListEntry,
@@ -685,15 +472,14 @@ STATUS
 
     pThread = CONTAINING_RECORD(ListEntry, THREAD, AllList );
 
-    LOG("%6x%c", pThread->Id, '|');
-    LOG("%19s%c", pThread->Name, '|');
-    LOG("%4U%c", pThread->Priority, '|');
-    LOG("%7s%c", _CmdThreadStateToName(pThread->State), '|');
-    LOG("%9U%c", pThread->TickCountCompleted, '|');
-    LOG("%9U%c", pThread->TickCountEarly, '|');
-    LOG("%9U%c", pThread->TickCountCompleted + pThread->TickCountEarly, '|');
-    LOG("%9x%c", pThread->Process->Id, '|');
-    LOG("\n");
+    printf("%6x%c", pThread->Id, '|');
+    printf("%19s%c", pThread->Name, '|');
+    printf("%4U%c", pThread->Priority, '|');
+    printf("%7s%c", _CmdThreadStateToName(pThread->State), '|');
+    printf("%9U%c", pThread->TickCountCompleted, '|');
+    printf("%9U%c", pThread->TickCountEarly, '|');
+    printf("%9U%c", pThread->TickCountCompleted + pThread->TickCountEarly, '|');
+    printf("%9x%c", pThread->Process->Id, '|');
 
     return STATUS_SUCCESS;
 }
@@ -730,48 +516,4 @@ STATUS
     return STATUS_SUCCESS;
 }
 
-static
-__forceinline
-void
-_ThreadBusyWait(
-    IN      QWORD       Microseconds
-    )
-{
-    QWORD start = IomuGetSystemTimeUs();
-
-    while (IomuGetSystemTimeUs() < start + Microseconds);
-}
-
-STATUS
-(__cdecl _ThreadCpuBound)(
-    IN_OPT      PVOID       Context
-    )
-{
-    PBOUND_THREAD_CTX pCtx = (PBOUND_THREAD_CTX) Context;
-
-    ASSERT(Context != NULL);
-
-    _ThreadBusyWait(pCtx->CpuUsage);
-
-    return STATUS_SUCCESS;
-}
-
-STATUS
-(__cdecl _ThreadIoBound)(
-    IN_OPT      PVOID       Context
-    )
-{
-    PBOUND_THREAD_CTX pCtx = (PBOUND_THREAD_CTX) Context;
-
-    ASSERT(Context != NULL);
-
-    for (DWORD i = 0; i < pCtx->EventWaitTimes; ++i)
-    {
-        ExEventWaitForSignal(&pCtx->Event);
-        _ThreadBusyWait(pCtx->CpuUsage);
-    }
-
-    return STATUS_SUCCESS;
-}
-
 #pragma warning(pop)
diff --git a/src/HAL9000/src/core.c b/src/HAL9000/src/core.c
index bcdc1a9..9961b7e 100644
--- a/src/HAL9000/src/core.c
+++ b/src/HAL9000/src/core.c
@@ -40,6 +40,7 @@ CorePreinit(
     memzero(&m_coreData, sizeof(CORE_DATA));
 }
 
+SAL_SUCCESS
 STATUS
 CoreInit(
     void
diff --git a/src/HAL9000/src/cpumu.c b/src/HAL9000/src/cpumu.c
index 82fe2ec..8b15f8d 100644
--- a/src/HAL9000/src/cpumu.c
+++ b/src/HAL9000/src/cpumu.c
@@ -1,6 +1,7 @@
 #include "HAL9000.h"
 #include "thread_internal.h"
 #include "cpumu.h"
+#include "memory.h"
 #include "mmu.h"
 #include "gdtmu.h"
 #include "smp.h"
@@ -15,8 +16,6 @@
 
 #define IA32_EXPECTED_PAT_VALUES    0x0007'0406'0007'0406ULL
 
-#define HAL9000_USED_XCR0_FEATURES           (XCR0_SAVED_STATE_x87_MMX | XCR0_SAVED_STATE_SSE)
-
 typedef struct _CPUMU_DATA
 {
     CPUID_BASIC_INFORMATION                         BasicInformation;
@@ -25,7 +24,6 @@ typedef struct _CPUMU_DATA
     CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    StructuredExtendedFeatures;
     CPUID_EXTENDED_CPUID_INFORMATION                ExtendedCpuidInformation;
     CPUID_EXTENDED_FEATURE_INFORMATION              ExtendedFeatureInformation;
-    CPUID_EXTENDED_STATE_ENUMERATION_MAIN_LEAF      ExtendedStateMainLeaf;
 } CPUMU_DATA, *PCPMU_DATA;
 
 static CPUMU_DATA m_cpuMuData;
@@ -64,13 +62,14 @@ _CpuActivateAvailableFeatures(
     LOG("EFER is 0x%X\n", __readmsr(IA32_EFER));
 }
 
-__forceinline
-static
 void
-_CpuMuCollectBasicInformation(
+CpuMuPreinit(
     void
     )
 {
+    memzero(&m_cpuMuData, sizeof(CPUMU_DATA));
+
+    // Basic information
     __cpuid((int*) &m_cpuMuData.BasicInformation, CpuidIdxBasicInformation);
 
     if (m_cpuMuData.BasicInformation.MaxValueForBasicInfo >= CpuidIdxFeatureInformation)
@@ -88,71 +87,18 @@ _CpuMuCollectBasicInformation(
         __cpuid((int*)&m_cpuMuData.StructuredExtendedFeatures, CpuidIdxStructuredExtendedFeaturesLeaf);
     }
 
-    if (m_cpuMuData.BasicInformation.MaxValueForBasicInfo >= CpuidIdxExtendedStateEnumerationMainLeaf)
-    {
-        __cpuidex((int*)&m_cpuMuData.ExtendedStateMainLeaf, CpuidIdxExtendedStateEnumerationMainLeaf, 0x0);
-    }
-}
-
-__forceinline
-static
-void
-_CpuMuCollectExtendedInformation(
-    void
-    )
-{
+    // Extended information
     __cpuid((int*) &m_cpuMuData.ExtendedCpuidInformation, CpuidIdxExtendedMaxFunction);
 
     if (m_cpuMuData.ExtendedCpuidInformation.MaxValueForExtendedInfo >= CpuidIdxExtendedFeatureInformation)
     {
         __cpuid((int*) &m_cpuMuData.ExtendedFeatureInformation, CpuidIdxExtendedFeatureInformation);
     }
-}
-
-// this has nothing to do with the thread system, it is a `hack` used to
-// have the same consistency through GetCurrentThread() calls since
-// `CpuMuPreInit` was called until the first thread is setup on the CPU in
-// `ThreadSystemInitMainForCurrentCPU`
-// This DUMMY_THREAD will be the thread of both the DUMMY_CPU and the real CPU until
-// the threading system is set up
-
-// PS: next year we might want to create a real `THREAD_HEADER` structure in `thread_internal.h` to have a cleaner solution
-// However, as not to confuse people by updating the `THREAD` structure after the semester has started this is the current solution
-typedef struct _DUMMY_THREAD
-{
-    REF_COUNT               RefCnt;
-
-    struct _THREAD* Self;
-} DUMMY_THREAD;
-static_assert(sizeof(DUMMY_THREAD) == FIELD_OFFSET(THREAD, Id) && FIELD_OFFSET(DUMMY_THREAD, Self) == FIELD_OFFSET(THREAD, Self),
-    "Safety measure, if someone modified the THREAD structure we may need to modify this DUMMY_THREAD as well");
-
-// mark .Self as NULL such that GetCurrentThread will return always NULL until we setup the first real thread later in the boot
-// set up both for dummy CPU and for the real CPU structure until threading system is initialized
-static DUMMY_THREAD __dummySelfThread = { .Self = NULL };
-
-void
-CpuMuPreinit(
-    void
-    )
-{
-    static PCPU* __dummySelfCpu = NULL;
-
-    memzero(&m_cpuMuData, sizeof(CPUMU_DATA));
-
-    // Basic information
-    _CpuMuCollectBasicInformation();
-
-    // Extended information
-    _CpuMuCollectExtendedInformation();
-
-    // We cannot have the current CPU NULL because we always dereference the first field
-    //  => use static dummy PCPU which has the first field NULL
-    SetCurrentPcpu(&__dummySelfCpu);
 
+    SetCurrentPcpu(NULL);
     // we're not using the SetCurrentThread macro because it will
     // try to dereference the PCPU pointer
-    __writemsr(IA32_FS_BASE_MSR, &__dummySelfThread);
+    __writemsr(IA32_FS_BASE_MSR,NULL);
 }
 
 void
@@ -160,6 +106,8 @@ CpuMuValidateConfiguration(
     void
     )
 {
+    ASSERT_INFO( CpuIsIntel(), "Who the hell wants to run on an AMD??");
+
     ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.APIC, "We cannot wake up APs without APIC!");
 
     ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.MSR, "We cannot do anything without MSRs!");
@@ -174,16 +122,7 @@ CpuMuValidateConfiguration(
 
     ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.SSE2, "We need LFENCE/MFENCE support");
 
-#if INCLUDE_FP_SUPPORT
-    ASSERT_INFO( m_cpuMuData.FeatureInformation.ecx.XSAVE, "We need XSAVE/XRSTOR support");
-
-    ASSERT_INFO(IsBooleanFlagOn(
-        DWORDS_TO_QWORD(m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportHigh, m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportLow),
-        HAL9000_USED_XCR0_FEATURES),
-        "We need to support 0x%X, however we only have support for 0x%X\n",
-        HAL9000_USED_XCR0_FEATURES,
-        DWORDS_TO_QWORD(m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportHigh, m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportLow));
-#endif
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.ecx.PCID, "Things are too slow without PCID support");
 
     ASSERT_INFO( m_cpuMuData.ExtendedFeatureInformation.edx.Syscall, "We need SYSCALL/SYSRET support");
 }
@@ -280,7 +219,6 @@ CpuMuAllocCpu(
         return STATUS_MEMORY_CANNOT_BE_MAPPED;
     }
 
-    pPcpu->Self = pPcpu;
     pPcpu->ApicId = ApicId;
     pPcpu->LogicalApicId = ( 1U << ApicId );
 
@@ -343,7 +281,7 @@ CpuMuInitCpu(
 
     // write CPU structure to GS
     SetCurrentPcpu(PhysicalCpu);
-    SetCurrentThread((PTHREAD)&__dummySelfThread);
+    SetCurrentThread(NULL);
 
     // we assume we haven't used more than 1 PAGE of our stack
     if (ChangeStack)
@@ -401,22 +339,6 @@ CpuMuChangeStack(
     GSNotifyStackChange(oldStackBase, NewStack, PAGE_SIZE);
 }
 
-BOOLEAN
-CpuMuIsPcidFeaturePresent(
-    void
-    )
-{
-    return (m_cpuMuData.FeatureInformation.ecx.PCID == 1);
-}
-
-STATUS
-CpuMuActivateFpuFeatures(
-    void
-    )
-{
-    return HalSetActiveFpuFeatures(HAL9000_USED_XCR0_FEATURES);
-}
-
 static
 void
 _CpuValidateCurrentCpu(
diff --git a/src/HAL9000/src/defines.yasm b/src/HAL9000/src/defines.yasm
index 2176bce..9e9f2e6 100644
--- a/src/HAL9000/src/defines.yasm
+++ b/src/HAL9000/src/defines.yasm
@@ -175,6 +175,4 @@
 %define     BIOS_SERIAL_PORT_ADDRESS    0x400
 %define     BIOS_NO_OF_SERIAL_PORTS     4
 
-%define     INCLUDE_FP_SUPPORT          0
-
 %endif ; _DEFINES_ASM_
\ No newline at end of file
diff --git a/src/HAL9000/src/display.c b/src/HAL9000/src/display.c
index 1aaa915..d31b52a 100644
--- a/src/HAL9000/src/display.c
+++ b/src/HAL9000/src/display.c
@@ -1,5 +1,6 @@
 #include "HAL9000.h"
 #include "display.h"
+#include "memory.h"
 
 #pragma pack(push,1)
 typedef struct _SCREEN_CHARACTER
@@ -258,6 +259,7 @@ DispSetCursor(
                        Color);
 }
 
+SAL_SUCCESS
 STATUS
 DispStoreBuffer(
     OUT_WRITES_BYTES(Size)  PVOID               Buffer,
@@ -274,6 +276,7 @@ DispStoreBuffer(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 DispRestoreBuffer(
     IN_READS_BYTES(Size)    PVOID               Buffer,
diff --git a/src/HAL9000/src/dmp_common.c b/src/HAL9000/src/dmp_common.c
index 5146261..83ddea0 100644
--- a/src/HAL9000/src/dmp_common.c
+++ b/src/HAL9000/src/dmp_common.c
@@ -15,9 +15,6 @@ DumpPreinit(
 REQUIRES_NOT_HELD_LOCK(m_dumpLock)
 RELEASES_EXCL_AND_REENTRANT_LOCK(m_dumpLock)
 INTR_STATE
-// Warning C26165 Possibly failing to release lock 'm_dumpLock' in function 'DumpTakeLock'
-// This is because SAL does not understand who m_dumpLock is
-#pragma warning(suppress: 26165)
 DumpTakeLock(
     void
     )
diff --git a/src/HAL9000/src/dmp_cpu.c b/src/HAL9000/src/dmp_cpu.c
index 2854e9f..128027d 100644
--- a/src/HAL9000/src/dmp_cpu.c
+++ b/src/HAL9000/src/dmp_cpu.c
@@ -7,7 +7,7 @@
 
 // +1 because of NULL terminator
 static const char REGISTER_NAMES[RegisterR15 + 1][MAX_REGISTER_NAME_LENGTH + 1] = { "RAX", "RCX", "RDX", "RBX", "RSP", "RBP", "RSI", "RDI",
-                                                                                    "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15"
+                                                                                    "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15" 
                                                                                     };
 
 static const char CPUID_LEAF_NAMES[][MAX_LEAF_NAME_LENGTH] = { "Basic Information", "Feature Information", "Cache Information", "Reserved", "Deterministic Cache",
@@ -43,29 +43,14 @@ RetrieveRegisterName(
     return REGISTER_NAMES[Index];
 }
 
-void
-DumpRegisterArea(
-    IN  REGISTER_AREA*                  RegisterArea
-    )
-{
-    ASSERT(RegisterArea != NULL);
-
-    for (DWORD i = 0; i <= RegisterR15; ++i)
-    {
-        QWORD regValue = RegisterArea->RegisterValues[i];
-
-        LOG("%s: 0x%X\n", RetrieveRegisterName(i), regValue);
-    }
-
-    LOG("RIP: 0x%X\n", RegisterArea->Rip);
-    LOG("Rflags: 0x%X\n", RegisterArea->Rflags);
-}
-
 void
 DumpProcessorState(
-    IN  COMPLETE_PROCESSOR_STATE*    ProcessorState
+    IN  PROCESSOR_STATE*    ProcessorState
     )
 {
+    STATUS status;
+    QWORD regValue;
+    DWORD i;
     INTR_STATE intrState;
 
     ASSERT( NULL != ProcessorState);
@@ -73,8 +58,20 @@ DumpProcessorState(
     intrState = DumpTakeLock();
     LOG("\nProcessor State:\n");
 
-    DumpRegisterArea(&ProcessorState->RegisterArea);
 
+
+    for (i = 0; i <= RegisterR15; ++i)
+    {
+        status = STATUS_SUCCESS;
+        regValue = ProcessorState->RegisterValues[i];
+        ASSERT(SUCCEEDED(status));
+
+
+        LOG("%s: 0x%X\n", RetrieveRegisterName(i), regValue);
+    }
+
+    LOG("RIP: 0x%X\n", ProcessorState->Rip);
+    LOG("Rflags: 0x%X\n", ProcessorState->Rflags);
     DumpReleaseLock(intrState);
 }
 
diff --git a/src/HAL9000/src/dmp_pci.c b/src/HAL9000/src/dmp_pci.c
index dc642ac..cd8e8ba 100644
--- a/src/HAL9000/src/dmp_pci.c
+++ b/src/HAL9000/src/dmp_pci.c
@@ -61,7 +61,7 @@ DumpPciDevice(
         return;
     }
 
-    LOG("PCI device at (%d.%d.%d)\n",
+    LOG("PCI device at (%d.%d.%d)\n", 
         Device->DeviceLocation.Bus,
         Device->DeviceLocation.Device,
         Device->DeviceLocation.Function
@@ -83,8 +83,8 @@ _DumpPciHeader(
 
     ASSERT( NULL != Header );
 
-    LOG("Vendor ID: 0x%04x\n", Header->VendorID);
-    LOG("Device ID: 0x%04x\n", Header->DeviceID);
+    LOG("Vendor ID: 0x%x\n", Header->VendorID);
+    LOG("Device ID: 0x%x\n", Header->DeviceID);
     LOG("Class Code: 0x%x\n", Header->ClassCode);
     LOG("Subclass: 0x%x\n", Header->Subclass);
     LOG("Header type: 0x%x\n", Header->HeaderType );
@@ -92,8 +92,8 @@ _DumpPciHeader(
 
     bBridge = Header->HeaderType.Layout == PCI_HEADER_LAYOUT_PCI_TO_PCI;
 
-    for (DWORD i = 0;
-         i < (bBridge ? PCI_BRIDGE_NO_OF_BARS : PCI_DEVICE_NO_OF_BARS);
+    for (DWORD i = 0; 
+         i < (bBridge ? PCI_BRIDGE_NO_OF_BARS : PCI_DEVICE_NO_OF_BARS); 
          ++i)
     {
         LOG("Bar[%d] = 0x%x\n", i, Header->Device.Bar[i]);
diff --git a/src/HAL9000/src/ex_event.c b/src/HAL9000/src/ex_event.c
index c185e77..0461121 100644
--- a/src/HAL9000/src/ex_event.c
+++ b/src/HAL9000/src/ex_event.c
@@ -44,13 +44,13 @@ ExEventSignal(
 
     LockAcquire(&Event->EventLock, &oldState);
     _InterlockedExchange8(&Event->Signaled, TRUE);
-    
+
     for(pEntry = RemoveHeadList(&Event->WaitingList);
         pEntry != &Event->WaitingList;
         pEntry = RemoveHeadList(&Event->WaitingList)
             )
     {
-        PTHREAD pThreadToSignal = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
+        PTHREAD pThreadToSignal = (PTHREAD)0xFFFF'7000'0000'3000ULL;// CONTAINING_RECORD(pEntry, THREAD, ReadyList);
         ThreadUnblock(pThreadToSignal);
 
         if (ExEventTypeSynchronization == Event->EventType)
diff --git a/src/HAL9000/src/gdtmu.c b/src/HAL9000/src/gdtmu.c
index 600cba3..4ad045f 100644
--- a/src/HAL9000/src/gdtmu.c
+++ b/src/HAL9000/src/gdtmu.c
@@ -50,11 +50,8 @@ GdtMuInit(
         }
     }
 
-    GdtMuReload(
-        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeCode),
-        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeData),
-        TRUE,
-        TRUE);
+    GdtReload(GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeCode), 
+              GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeData));
 
     m_selectorIndex = selIdx + sizeof(SEGMENT_DESCRIPTOR);
 
@@ -111,26 +108,4 @@ GdtMuRetrieveSelectorIndex(
                 Mode * SelTypeReserved +
                 Type
                 ) * sizeof(SEGMENT_DESCRIPTOR));
-}
-
-void
-GdtMuReload(
-    IN          WORD            CodeSelector,
-    IN          WORD            DataSelector,
-    IN          BOOLEAN         PreserveGsBase,
-    IN          BOOLEAN         PreserveFsBase
-    )
-{
-    // The initialization is done just because the compiler is retarded :)
-    // It thinks we might write the oldGs/FsBase values without reading them
-    QWORD oldGsBase = 0;
-    QWORD oldFsBase = 0;
-
-    if (PreserveGsBase) oldGsBase = __readmsr(IA32_GS_BASE_MSR);
-    if (PreserveFsBase) oldFsBase = __readmsr(IA32_FS_BASE_MSR);
-
-    GdtReload(CodeSelector, DataSelector);
-
-    if (PreserveGsBase) __writemsr(IA32_GS_BASE_MSR, oldGsBase);
-    if (PreserveFsBase) __writemsr(IA32_FS_BASE_MSR, oldFsBase);
-}
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/heap.c b/src/HAL9000/src/heap.c
new file mode 100644
index 0000000..31c2304
--- /dev/null
+++ b/src/HAL9000/src/heap.c
@@ -0,0 +1,543 @@
+#include "HAL9000.h"
+#include "heap.h"
+#include "vmm.h"
+#include "dmp_memory.h"
+#include "cpu.h"
+
+// 64KB is the minimum heap size required to initialize the system
+#define HEAP_MINIMUM_SIZE               (64*KB_SIZE)
+
+// random HEAP_MAGIC number
+#define HEAP_MAGIC                      0xACE2302E
+
+#define HEAP_FREE_PATTERN               0xAF
+#define HEAP_TAIL_SIZE                  sizeof(DWORD)
+
+typedef struct _HEAP_TAIL
+{
+    DWORD               Magic;
+} HEAP_TAIL, *PHEAP_TAIL;
+STATIC_ASSERT(sizeof(HEAP_TAIL) == HEAP_TAIL_SIZE);
+
+/*
+----------------------------------------------------------------
+-           Magic
+-           Tag
+-           Size
+-           Offset
+-           ListEntry
+-           Data
+
+
+
+
+
+
+-           Magic
+----------------------------------------------------------------
+*/
+typedef
+_Struct_size_bytes_(sizeof(HEAP_ENTRY) + Size + sizeof(HEAP_TAIL))
+struct _HEAP_ENTRY
+{
+    DWORD               Magic;          // 0x0
+    DWORD               Tag;            // 0x4
+    DWORD               Size;           // 0x8  (sizeof actual data allocated(without header) and without MAGIC at the end of the data allocated)
+    DWORD               Offset;         // 0xC  (offset to the data(may depend on the alignment)
+    LIST_ENTRY          ListEntry;      // 0x10
+} HEAP_ENTRY, *PHEAP_ENTRY;             // sizeof(HEAP_ENTRY) = 0x20
+
+//******************************************************************************
+// Function:    InitHeapEntry
+// Description: Initializes the memory area for the new allocation and updates
+//              the global HEAP_HEADER structure.
+// Returns:     QWORD
+// Parameter:   OUT PHEAP_ENTRY * HeapEntry
+// Parameter:   IN DWORD Tag
+// Parameter:   IN DWORD Size
+// Parameter:   IN DWORD Alignment
+// Parameter:   IN BOOLEAN AddToLinkedList
+// Parameter:   IN QWORD SizeAvailable
+//******************************************************************************
+static
+QWORD
+_InitHeapEntry(
+    INOUT    PHEAP_HEADER    HeapHeader,
+    INOUT    PHEAP_ENTRY*    HeapEntry,
+    IN       DWORD           Tag,
+    IN       DWORD           Size,
+    IN       DWORD           Alignment,
+    IN       BOOLEAN         AddToLinkedList,
+    IN       QWORD           SizeAvailable
+    );
+
+static
+BOOL_SUCCESS
+BOOLEAN
+_ValidateHeapEntry(
+    IN      PHEAP_ENTRY     HeapEntry,
+    IN      DWORD           Tag
+    );
+
+SAL_SUCCESS
+STATUS
+HeapInitializeSystem(
+    IN                                  QWORD                   MemoryAvailable,
+    OUT_PTR                             PHEAP_HEADER*           HeapHeader
+    )
+{
+    PVOID baseAddress;
+    QWORD heapSize;
+    PHEAP_HEADER pHeapHeader;
+
+    if (NULL == HeapHeader)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    //baseAddress = BaseAddress;
+    heapSize = MemoryAvailable;
+
+    if( heapSize < HEAP_MINIMUM_SIZE )
+    {
+        return STATUS_HEAP_TOO_SMALL;
+    }
+
+    pHeapHeader = NULL;
+
+    baseAddress = VmmAllocRegion(NULL,
+                                 heapSize,
+                                 VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                 PAGE_RIGHTS_READWRITE
+                                 );
+    if( NULL == baseAddress )
+    {
+        LOG_ERROR("VmmAlloc failed to reserve & commit a heap of size %U!\n", heapSize);
+        return STATUS_MEMORY_CANNOT_BE_RESERVED;
+    }
+
+    pHeapHeader = baseAddress;
+
+    pHeapHeader->Magic = HEAP_MAGIC;
+    pHeapHeader->BaseAddress = ( QWORD ) baseAddress;
+    pHeapHeader->HeapSizeMaximum = heapSize;
+    pHeapHeader->HeapSizeRemaining = pHeapHeader->HeapSizeMaximum - sizeof( HEAP_HEADER );
+    pHeapHeader->HeapNumberOfAllocations = 0;
+    pHeapHeader->EntryToRestartSearch = &pHeapHeader->HeapAllocations;
+
+    pHeapHeader->FreeAddress = pHeapHeader->BaseAddress + sizeof( HEAP_HEADER );
+    InitializeListHead( &pHeapHeader->HeapAllocations );
+
+    *HeapHeader = pHeapHeader;
+
+    return STATUS_SUCCESS;
+}
+
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+HeapAllocatePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    )
+{
+    STATUS status;
+    INT64 remainingSizeUntilEnd;
+    INT64 remainingSizeBeforeCurrent;
+    QWORD sizeRequired;
+    QWORD startAddress;
+    DWORD alignment;
+    INT64 sizeBetweenEntries;
+    PVOID mappedAddress;
+    HEAP_ENTRY* pNewHeapEntry;
+    BOOLEAN found;
+    QWORD tempAddress;
+
+    LIST_ENTRY* pCurEntry;
+    HEAP_ENTRY* pCurHeapEntry;
+
+    LIST_ENTRY* pPreviousEntry;
+    HEAP_ENTRY* pPreviousHeapEntry;
+
+    ASSERT( NULL != HeapHeader );
+
+    found = FALSE;
+    status = STATUS_SUCCESS;
+    startAddress = 0;
+    pNewHeapEntry = NULL;
+    mappedAddress = NULL;
+
+    tempAddress = 0;
+    sizeBetweenEntries = 0;
+    pCurEntry = NULL;
+    pCurHeapEntry = NULL;
+    pPreviousEntry = NULL;
+    pPreviousHeapEntry = NULL;
+    remainingSizeUntilEnd = 0;
+    remainingSizeBeforeCurrent = 0;
+
+    __try
+    {
+        if (0 == AllocationSize)
+        {
+            status = STATUS_INVALID_PARAMETER2;
+            __leave;
+        }
+
+        if (0 == Tag)
+        {
+            // we need a tag
+            status = STATUS_INVALID_PARAMETER3;
+            __leave;
+        }
+
+        if (0 == AllocationAlignment)
+        {
+            alignment = HEAP_DEFAULT_ALIGNMENT;
+        }
+        else
+        {
+            alignment = AllocationAlignment;
+        }
+
+        sizeRequired = AllocationSize + sizeof(HEAP_ENTRY) + sizeof(HEAP_TAIL);
+
+        if (sizeRequired > HeapHeader->HeapSizeRemaining)
+        {
+            // we clear we have no chance of allocating more space
+            LOG_ERROR("sizeRequired: 0x%X\n", sizeRequired);
+            LOG_ERROR("HeapHeader->HeapSizeRemaining: 0x%X\n", HeapHeader->HeapSizeRemaining);
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            __leave;
+        }
+
+        // this is how much size for data we have available until the end of the heap
+        remainingSizeUntilEnd = HeapHeader->BaseAddress + HeapHeader->HeapSizeMaximum - HeapHeader->FreeAddress - sizeof(HEAP_ENTRY);
+        if ((INT64)sizeRequired <= remainingSizeUntilEnd)
+        {
+            // it's ok we'll place it here, this is the easier case
+            pNewHeapEntry = (HEAP_ENTRY*)HeapHeader->FreeAddress;
+
+            tempAddress = _InitHeapEntry(HeapHeader, &pNewHeapEntry, Tag, AllocationSize, alignment, TRUE, remainingSizeUntilEnd);
+            if (0 == tempAddress)
+            {
+                // it's possible we still have space
+                LOG_WARNING("_InitHeapEntry failed for size required: 0x%X\n", sizeRequired);
+            }
+            else
+            {
+                HeapHeader->FreeAddress = tempAddress;
+                found = TRUE;
+            }
+        }
+
+        if (!found)
+        {
+            // so we don't have space at the end
+            // let's check if there's a chance for us to have space before our current location
+
+            // this is the rest of the space we have
+            remainingSizeBeforeCurrent = HeapHeader->HeapSizeRemaining - remainingSizeUntilEnd - sizeof(HEAP_ENTRY);
+            if ((INT64)sizeRequired > remainingSizeBeforeCurrent)
+            {
+                // we have nowhere to allocate memory
+                LOG_ERROR("sizeRequired: 0x%X\n", sizeRequired);
+                LOG_ERROR("remainingSizeBeforeCurrent: 0x%X\n", remainingSizeBeforeCurrent);
+                status = STATUS_HEAP_NO_MORE_MEMORY;
+                __leave;
+            }
+            else
+            {
+                // we need to go to through the Linked List and find a free spot between 2 entries
+
+
+                // there is no way the list can be empty and we still don't have nay memory remaining
+                ASSERT(!IsListEmpty(&(HeapHeader->HeapAllocations)));
+
+                pPreviousEntry = HeapHeader->EntryToRestartSearch->Flink;
+                pPreviousHeapEntry = CONTAINING_RECORD(pPreviousEntry, HEAP_ENTRY, ListEntry);
+                pCurEntry = pPreviousEntry->Flink;
+
+                while (HeapHeader->EntryToRestartSearch != pCurEntry)
+                {
+                    if ((pCurEntry == &HeapHeader->HeapAllocations) ||
+                        (pPreviousEntry == &HeapHeader->HeapAllocations))
+                    {
+                        goto next_loop;
+                    }
+
+                    ASSERT(NULL != pPreviousHeapEntry);
+
+                    pCurHeapEntry = CONTAINING_RECORD(pCurEntry, HEAP_ENTRY, ListEntry);
+                    startAddress = ((QWORD)pPreviousHeapEntry + sizeof(HEAP_ENTRY) + pPreviousHeapEntry->Size + sizeof(HEAP_TAIL));
+                    sizeBetweenEntries = (INT64)((QWORD)pCurHeapEntry - startAddress);
+
+                    if (sizeBetweenEntries >= (INT64)sizeRequired)
+                    {
+                        // we can squeeze this entry between these 2
+                        pNewHeapEntry = (HEAP_ENTRY*)startAddress;
+
+                        // here we need to add it manually to the linked list
+                        // => FALSE AddToLinkedList parameter, we only need the memory pointer
+                        // and to update the heap structures
+                        tempAddress = _InitHeapEntry(HeapHeader, &pNewHeapEntry, Tag, AllocationSize, alignment, FALSE, sizeBetweenEntries);
+                        if (0 == tempAddress)
+                        {
+                            // _InitHeapEntry also calculates alignment requirements
+                            // => it's possible in this space that we still couldn't fit the data
+                            // but maybe we'll be able to on the next iteration
+                            LOG_WARNING("_InitHeapEntry failed for size required: 0x%X\n", sizeRequired);
+                            goto next_loop;
+                        }
+
+                        ASSERT(_ValidateHeapEntry(pPreviousHeapEntry, pPreviousHeapEntry->Tag));
+
+                        // now we insert it in the appropriate position
+                        InsertHeadList(pPreviousEntry, &(pNewHeapEntry->ListEntry));
+
+                        HeapHeader->EntryToRestartSearch = &pNewHeapEntry->ListEntry;
+                        found = TRUE;
+                    }
+
+                    if (found)
+                    {
+                        break;
+                    }
+
+                next_loop:
+                    // we update the pointers
+                    pPreviousEntry = pCurEntry;
+                    pPreviousHeapEntry = pCurHeapEntry;
+                    pCurEntry = pCurEntry->Flink;
+                }
+
+                if (!found)
+                {
+                    status = STATUS_HEAP_NO_MORE_MEMORY;
+                    __leave;
+                }
+            }
+        }
+
+        mappedAddress = ((BYTE*)pNewHeapEntry) + pNewHeapEntry->Offset;
+    }
+    __finally
+    {
+        if (IsFlagOn(Flags, PoolAllocatePanicIfFail))
+        {
+            // we must succeed
+            ASSERT_INFO(SUCCEEDED(status), "Operation failed with status: 0x%x\n", status);
+            ASSERT(NULL != mappedAddress);
+        }
+
+        if (SUCCEEDED(status))
+        {
+            if (IsFlagOn(Flags, PoolAllocateZeroMemory))
+            {
+                memzero(mappedAddress, AllocationSize);
+            }
+        }
+        else
+        {
+            LogSetState(TRUE);
+            LOG_FUNC_ERROR("HeapAllocatePoolWithTag", status);
+            LOGPL("Heap total size: 0x%X\n", HeapHeader->HeapSizeMaximum);
+            LOGPL("Remaining heap size: 0x%X\n", HeapHeader->HeapSizeRemaining);
+            LOGPL("Number of allocations: 0x%X\n", HeapHeader->HeapNumberOfAllocations);
+            LOGPL("Remaining size until end: 0x%X\n", remainingSizeUntilEnd);
+            LOGPL("Remaining size before current: 0x%X\n", remainingSizeBeforeCurrent);
+        }
+    }
+
+    return mappedAddress;
+}
+
+void
+HeapFreePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    )
+{
+    HEAP_ENTRY* pHeapEntry;
+    LIST_ENTRY* pListEntry;
+    HEAP_ENTRY* pPreviousHeapEntry;
+    QWORD endAddress;
+    QWORD previousAddress;
+    QWORD heapEntrySize;
+
+    ASSERT( NULL != HeapHeader );
+    ASSERT( NULL != MemoryAddress );
+    ASSERT( 0 != Tag );
+
+    pPreviousHeapEntry = NULL;
+    pListEntry = NULL;
+    endAddress = 0;
+    previousAddress = 0;
+
+    pHeapEntry = ( HEAP_ENTRY* ) ( ( BYTE*) MemoryAddress - sizeof( HEAP_ENTRY ) );
+
+    endAddress = ( QWORD ) MemoryAddress + pHeapEntry->Size + sizeof( HEAP_TAIL );
+
+    // sanity checks
+    ASSERT(_ValidateHeapEntry(pHeapEntry,Tag));
+
+    pListEntry = pHeapEntry->ListEntry.Blink;
+
+    if( &( HeapHeader->HeapAllocations ) == pListEntry )
+    {
+        pListEntry = NULL;
+    }
+
+    if( NULL != pListEntry )
+    {
+        pPreviousHeapEntry = CONTAINING_RECORD( pListEntry, HEAP_ENTRY, ListEntry );
+        previousAddress = ( QWORD) pPreviousHeapEntry + sizeof( HEAP_ENTRY ) + pPreviousHeapEntry->Size + sizeof( HEAP_TAIL );
+    }
+    else
+    {
+        // the list of allocations is empty
+        previousAddress = HeapHeader->BaseAddress + sizeof( HEAP_HEADER );
+    }
+
+    // remove the element from the list of allocations
+    RemoveEntryList( &( pHeapEntry->ListEntry ) );
+    heapEntrySize = pHeapEntry->Size + sizeof(HEAP_ENTRY) + sizeof(HEAP_TAIL);
+
+    // memzero is done only for easier debugging
+    ASSERT( heapEntrySize <= MAX_DWORD );
+    memset( pHeapEntry, HEAP_FREE_PATTERN, (DWORD) heapEntrySize );
+
+    // we should really increment remaining heap size
+    HeapHeader->HeapSizeRemaining = HeapHeader->HeapSizeRemaining + heapEntrySize;
+    HeapHeader->HeapNumberOfAllocations = HeapHeader->HeapNumberOfAllocations - 1;
+
+    if( endAddress == HeapHeader->FreeAddress )
+    {
+        // we were the last ones here => we hand the staff to the previous entry
+        HeapHeader->FreeAddress = previousAddress;
+    }
+}
+
+static
+QWORD
+_InitHeapEntry(
+    INOUT   PHEAP_HEADER    HeapHeader,
+    INOUT   PHEAP_ENTRY*    HeapEntry,
+    IN      DWORD           Tag,
+    IN      DWORD           Size,
+    IN      DWORD           Alignment,
+    IN      BOOLEAN         AddToLinkedList,
+    IN      QWORD           SizeAvailable
+    )
+{
+    QWORD unalignedDataAddress;
+    QWORD dataAddress;
+    PHEAP_TAIL pHeapTail;
+    HEAP_ENTRY* pHeapEntry;
+    DWORD heapEntrySize;
+
+    unalignedDataAddress = 0;
+    dataAddress = 0;
+    pHeapTail = NULL;
+    pHeapEntry = *HeapEntry;
+
+
+    unalignedDataAddress = ( QWORD ) ( ( (BYTE*) pHeapEntry ) + sizeof( HEAP_ENTRY ) );
+
+    // the address needs to be aligned
+    dataAddress = AlignAddressUpper( unalignedDataAddress, Alignment );
+
+    heapEntrySize = Size + sizeof(HEAP_ENTRY) + sizeof(HEAP_TAIL);
+
+    if( SizeAvailable < ( dataAddress - unalignedDataAddress + heapEntrySize ) )
+    {
+        // we don't have enough space to allocate this entry
+        return 0;
+    }
+
+    // we need to remap the HeapEntry to be just before the new address
+    pHeapEntry = ( HEAP_ENTRY* ) ( dataAddress - sizeof( HEAP_ENTRY ) );
+    *HeapEntry = pHeapEntry;
+
+    pHeapEntry->Magic = HEAP_MAGIC;
+    pHeapEntry->Size = Size;
+    pHeapEntry->Tag = Tag;
+
+    // we insert the new element to the list
+    if( AddToLinkedList )
+    {
+        InsertTailList( &( HeapHeader->HeapAllocations ), &(pHeapEntry->ListEntry) );
+    }
+
+
+    pHeapEntry->Offset = ( DWORD ) ( dataAddress - ( QWORD ) pHeapEntry );
+
+    // we also have a magic field to append at the end
+    pHeapTail = ( PHEAP_TAIL )( dataAddress + pHeapEntry->Size );
+
+    // set the magic field
+    pHeapTail->Magic = HEAP_MAGIC;
+
+    HeapHeader->HeapSizeRemaining = HeapHeader->HeapSizeRemaining - heapEntrySize;
+    HeapHeader->HeapNumberOfAllocations = HeapHeader->HeapNumberOfAllocations + 1;
+
+    // has the possibly of becoming the first free entry list
+    return (QWORD) pHeapTail + sizeof(HEAP_TAIL);
+}
+
+static
+BOOL_SUCCESS
+BOOLEAN
+_ValidateHeapEntry(
+    IN      PHEAP_ENTRY     HeapEntry,
+    IN      DWORD           Tag
+    )
+{
+    PHEAP_TAIL pHeapTail;
+    BOOLEAN bResult;
+    DWORD totalSize;
+
+    ASSERT( NULL != HeapEntry );
+    ASSERT( 0 != Tag );
+
+    bResult = TRUE;
+
+    if (HEAP_MAGIC != HeapEntry->Magic)
+    {
+        LOG_ERROR("[HEAD] Found [0x%x] instead of magic [0x%x]\n", HeapEntry->Magic, HEAP_MAGIC );
+        bResult = FALSE;
+    }
+
+    totalSize = sizeof(HEAP_ENTRY) + HeapEntry->Size + sizeof(HEAP_TAIL);
+    pHeapTail = (PHEAP_TAIL)((PBYTE)HeapEntry + totalSize - sizeof(HEAP_TAIL));
+
+    if (HEAP_MAGIC != pHeapTail->Magic)
+    {
+        LOG_ERROR("[HEAD] Found [0x%x] instead of magic [0x%x]\n", pHeapTail->Magic, HEAP_MAGIC);
+        bResult = FALSE;
+    }
+
+    if (0 == HeapEntry->Tag)
+    {
+        LOG_ERROR("Found tag zero\n");
+        bResult = FALSE;
+    }
+
+    if (Tag != HeapEntry->Tag)
+    {
+        LOG_ERROR("Tag should be [0x%x], but is [0x%x]\n", Tag, HeapEntry->Tag);
+        bResult = FALSE;
+    }
+
+    if (!bResult)
+    {
+        DumpMemory((PVOID)PtrDiff(HeapEntry, 0x100), (QWORD) PtrDiff(HeapEntry, 0x100), totalSize + 0x100, TRUE, TRUE );
+    }
+
+    return bResult;
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/idt_handlers.c b/src/HAL9000/src/idt_handlers.c
index e75e72e..842ad52 100644
--- a/src/HAL9000/src/idt_handlers.c
+++ b/src/HAL9000/src/idt_handlers.c
@@ -128,6 +128,7 @@ IMPORT_GENERIC_ISR(252); IMPORT_GENERIC_ISR(253); IMPORT_GENERIC_ISR(254); IMPOR
 #define IST_CHOOSE(Cur,Max)     ((Cur)<=(Max) ? (Cur) : 0)
 
 static
+SAL_SUCCESS
 STATUS
 _InitInternalHandlers(
     IN      WORD                CodeSelector,
@@ -135,11 +136,13 @@ _InitInternalHandlers(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _InitExternalInterruptHandlers(
     IN      WORD                CodeSelector
     );
 
+SAL_SUCCESS 
 STATUS
 InitIdtHandlers(
     IN      WORD                CodeSelector,
@@ -176,6 +179,7 @@ InitIdtHandlers(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _InitInternalHandlers(
     IN      WORD                CodeSelector,
@@ -186,7 +190,6 @@ _InitInternalHandlers(
 
     status = STATUS_SUCCESS;
 
-#pragma warning(push)
     // warning C4152: nonstandard extension, function/data pointer conversion in expression
 #pragma warning(disable:4152)
     // 00 - #DE - Divide Error
@@ -269,12 +272,13 @@ _InitInternalHandlers(
     status = CREATE_INTERRUPT_GATE_DESC(VirtualizationException, ExceptionVirtualizationException, CodeSelector, 0);
     ASSERT(SUCCEEDED(status));
 
-#pragma warning(pop)
+#pragma warning(default:4152)
 
     return status;
 }
 
 static
+SAL_SUCCESS
 STATUS
 _InitExternalInterruptHandlers(
     IN      WORD                CodeSelector
@@ -283,8 +287,6 @@ _InitExternalInterruptHandlers(
     STATUS status;
 
     status = STATUS_SUCCESS;
-
-#pragma warning(push)
     // warning C4152: nonstandard extension, function/data pointer conversion in expression
 #pragma warning(disable:4152)
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(32); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(33); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(34); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(35);
@@ -301,62 +303,62 @@ _InitExternalInterruptHandlers(
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(68); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(69); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(70); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(71);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(72); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(73); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(74); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(75);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(76); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(77); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(78); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(79);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(80); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(81); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(82); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(83);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(84); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(85); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(86); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(87);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(88); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(89); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(90); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(91);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(92); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(93); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(94); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(95);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(96); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(97); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(98); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(99);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(100); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(101); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(102); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(103);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(104); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(105); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(106); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(107);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(108); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(109); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(110); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(111);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(112); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(113); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(114); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(115);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(116); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(117); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(118); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(119);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(120); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(121); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(122); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(123);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(124); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(125); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(126); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(127);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(128); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(129); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(130); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(131);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(132); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(133); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(134); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(135);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(136); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(137); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(138); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(139);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(140); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(141); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(142); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(143);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(144); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(145); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(146); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(147);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(148); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(149); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(150); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(151);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(152); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(153); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(154); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(155);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(156); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(157); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(158); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(159);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(160); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(161); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(162); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(163);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(164); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(165); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(166); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(167);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(168); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(169); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(170); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(171);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(172); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(173); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(174); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(175);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(176); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(177); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(178); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(179);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(180); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(181); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(182); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(183);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(184); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(185); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(186); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(187);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(188); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(189); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(190); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(191);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(192); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(193); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(194); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(195);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(196); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(197); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(198); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(199);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(200); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(201); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(202); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(203);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(204); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(205); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(206); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(207);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(208); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(209); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(210); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(211);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(212); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(213); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(214); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(215);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(216); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(217); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(218); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(219);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(220); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(221); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(222); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(223);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(224); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(225); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(226); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(227);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(228); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(229); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(230); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(231);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(232); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(233); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(234); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(235);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(236); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(237); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(238); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(239);
-
+    
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(240); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(241); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(242); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(243);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(244); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(245); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(246); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(247);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(248); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(249); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(250); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(251);
     CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(252); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(253); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(254); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(255);
-#pragma warning(pop)
+#pragma warning(default:4152)
 
     return status;
 }
\ No newline at end of file
diff --git a/src/HAL9000/src/io_devices.c b/src/HAL9000/src/io_devices.c
index 15d6123..8a789d2 100644
--- a/src/HAL9000/src/io_devices.c
+++ b/src/HAL9000/src/io_devices.c
@@ -23,6 +23,7 @@ _IoIsValidDeviceType(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _IoReadWriteDevice(
     IN          PDEVICE_OBJECT          DeviceObject,
@@ -88,8 +89,6 @@ IoCreateDevice(
 
         pDevice->StackSize = 1;
 
-        MutexInit(&pDevice->DeviceLock, FALSE);
-
         // insert device into list
         /// TODO: need to lock
         /// Actually this is debatable: the IoCreateDevice should normally be called only in the DriverEntry portion
@@ -163,6 +162,14 @@ IoDeleteDevice(
     Device = NULL;
 }
 
+void
+IoRegisterFileSystem(
+    IN      PDEVICE_OBJECT      FileSystemDevice
+    )
+{
+    ASSERT(NULL != FileSystemDevice);
+}
+
 PTR_SUCCESS
 PDRIVER_OBJECT
 IoCreateDriver(
@@ -354,6 +361,7 @@ IoCopyCurrentStackLocationToNext(
     memcpy(&Irp->StackLocations[currentStackLocation - 1], &Irp->StackLocations[currentStackLocation], sizeof(IO_STACK_LOCATION));
 }
 
+SAL_SUCCESS
 STATUS
 IoCallDriver(
     IN      PDEVICE_OBJECT  Device,
@@ -378,16 +386,16 @@ IoCallDriver(
 
     pStackLocation = IoGetCurrentIrpStackLocation(Irp);
 
-    if ((IRP_MJ_READ == pStackLocation->MajorFunction) || (IRP_MJ_WRITE == pStackLocation->MajorFunction))
+    if ((IRP_MJ_READ == pStackLocation->MajorFunction) || (IRP_MJ_WRITE == pStackLocation->MinorFunction))
     {
-        if (!IsAddressAligned(pStackLocation->Parameters.ReadWrite.Length, Device->DeviceAlignment))
+        if (!IsAddressAligned(pStackLocation->Parameters.ReadWrite.Length,Device->DeviceAlignment))
         {
             // read/write length not aligned to device requirement
             LOG_ERROR("ReadWrite length does not satisfy alignment requirement\nRequested: 0x%X, Required: 0x%x\n", pStackLocation->Parameters.ReadWrite.Length, Device->DeviceAlignment);
             return STATUS_DEVICE_ALIGNMENT_NO_SATISFIED;
         }
 
-        if (!IsAddressAligned(pStackLocation->Parameters.ReadWrite.Offset, Device->DeviceAlignment))
+        if (!IsAddressAligned(pStackLocation->Parameters.ReadWrite.Offset,Device->DeviceAlignment))
         {
             // read/write offset not aligned to device requirement
             LOG_ERROR("ReadWrite offset does not satisfy alignment requirement\nRequested: 0x%X, Required: 0x%x\n", pStackLocation->Parameters.ReadWrite.Offset, Device->DeviceAlignment);
@@ -405,9 +413,7 @@ IoCallDriver(
     }
     else
     {
-        MutexAcquire(&Device->DeviceLock);
         status = pDispatchFunction(Device, Irp);
-        MutexRelease(&Device->DeviceLock);
     }
     if (!SUCCEEDED(status))
     {
@@ -431,11 +437,12 @@ IoCompleteIrp(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _IoReadWriteDevice(
     IN          PDEVICE_OBJECT          DeviceObject,
-    _When_(!Write,OUT_WRITES_BYTES(*Length))
-    _When_(Write,IN_READS_BYTES(*Length))
+    _When_(Write,OUT_WRITES_BYTES(*Length))
+    _When_(!Write,IN_READS_BYTES(*Length))
                 PVOID                   Buffer,
     INOUT       QWORD*                  Length,
     IN          QWORD                   Offset,
@@ -519,6 +526,7 @@ _IoAllocateVpb(
     IomuNewVpbCreated(pVpb);
 }
 
+SAL_SUCCESS
 STATUS
 IoGetPciDevicesMatchingSpecification(
     IN          PCI_SPEC        Specification,
@@ -594,6 +602,7 @@ IoGetPciDevicesMatchingSpecification(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 IoGetPciDevicesMatchingLocation(
     IN          PCI_SPEC_LOCATION           Specification,
@@ -690,9 +699,6 @@ IoGetPciSecondaryBusForBridge(
     noOfDevices = 0;
     memzero(&pciLocation, sizeof(PCI_SPEC_LOCATION));
 
-    LOG_TRACE_IO("Will search for device at (%u.%u.%u)\n",
-        DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function);
-
     memcpy(&pciLocation.Location, (const PVOID) &DeviceLocation, sizeof(PCI_DEVICE_LOCATION));
     pciLocation.MatchBus = pciLocation.MatchDevice = pciLocation.MatchFunction = TRUE;
 
@@ -717,6 +723,7 @@ IoGetPciSecondaryBusForBridge(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 IoGetDevicesByType(
     IN                      DEVICE_TYPE         DeviceType,
@@ -750,17 +757,12 @@ IoFreeTemporaryData(
 
 PTR_SUCCESS
 PIRP
-// Warning C6101 Returning uninitialized memory '*OutputBuffer'. A successful path through
-// the function does not set the named _Out_ parameter.
-// I'm really not proud of this, but there is no other way to tell SAL what's going on
-// and Microsoft does the exact same hack... You learn from the best!
-#pragma warning(suppress: 6101)
 IoBuildDeviceIoControlRequest(
     IN          DWORD            IoControlCode,
     IN          PDEVICE_OBJECT   DeviceObject,
     IN_OPT      PVOID            InputBuffer,
     IN          DWORD            InputBufferLength,
-    OUT_OPT     PVOID            OutputBuffer,
+    IN_OPT      PVOID            OutputBuffer,
     IN          DWORD            OutputBufferLength
     )
 {
@@ -789,6 +791,7 @@ IoBuildDeviceIoControlRequest(
     return pIrp;
 }
 
+SAL_SUCCESS
 STATUS
 IoReadDeviceEx(
     IN                          PDEVICE_OBJECT          DeviceObject,
@@ -803,6 +806,7 @@ IoReadDeviceEx(
     return _IoReadWriteDevice(DeviceObject, Buffer, Length, Offset, FALSE, Asynchronous);
 }
 
+SAL_SUCCESS
 STATUS
 IoWriteDeviceEx(
     IN                          PDEVICE_OBJECT          DeviceObject,
@@ -817,6 +821,7 @@ IoWriteDeviceEx(
     return _IoReadWriteDevice(DeviceObject, Buffer, Length, Offset, TRUE, Asynchronous);
 }
 
+SAL_SUCCESS
 STATUS
 IoAllocateMdl(
     IN          PVOID           VirtualAddress,
@@ -907,6 +912,7 @@ IoMdlGetTranslationPair(
     return MdlGetTranslationPair(Mdl, Index);
 }
 
+SAL_SUCCESS
 STATUS
 IoRegisterInterruptEx(
     IN          PIO_INTERRUPT           Interrupt,
diff --git a/src/HAL9000/src/io_files.c b/src/HAL9000/src/io_files.c
index 571e6a5..7414f01 100644
--- a/src/HAL9000/src/io_files.c
+++ b/src/HAL9000/src/io_files.c
@@ -76,19 +76,7 @@ _IoIsFilePathValid(
     return TRUE;
 }
 
-static
-STATUS
-_IoReadWriteFile(
-    IN          PFILE_OBJECT            FileHandle,
-    _When_(!Write,OUT_WRITES_BYTES(Length))
-    _When_(Write,IN_READS_BYTES(Length))
-                PVOID                   Buffer,
-    IN          QWORD                   Length,
-    IN_OPT      QWORD*                  FileOffset,
-    OUT         QWORD*                  BytesTransferred,
-    IN          BOOLEAN                 Write
-    );
-
+SAL_SUCCESS
 STATUS
 IoCreateFile(
     OUT_PTR     PFILE_OBJECT*           Handle,
@@ -157,7 +145,7 @@ IoCreateFile(
 
     // create the FILE_OBJECT for the stack location
     _IoAllocateFileObject(pStackLocation, &FileName[FILE_NAME_MIN_LEN - 1], Asynchronous, Create, Directory);
-
+    
     __try
     {
 
@@ -174,7 +162,7 @@ IoCreateFile(
     {
         if (!SUCCEEDED(status))
         {
-            LOG_TRACE_IO("[ERROR]IoCallDriver failed with status 0x%x\n", status);
+            LOG_FUNC_ERROR("IoCallDriver", status);
 
             ASSERT(NULL != pStackLocation);
             ASSERT(NULL != pStackLocation->FileObject);
@@ -198,6 +186,7 @@ IoCreateFile(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 IoCloseFile(
     IN          PFILE_OBJECT            FileHandle
@@ -251,81 +240,50 @@ IoCloseFile(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 IoReadFile(
     IN          PFILE_OBJECT            FileHandle,
     IN          QWORD                   BytesToRead,
     IN_OPT      QWORD*                  FileOffset,
-    OUT_WRITES_BYTES(BytesToRead)
-                PVOID                   Buffer,
+    OUT         PVOID                   Buffer,
     OUT         QWORD*                  BytesRead
     )
-{
-    return _IoReadWriteFile(FileHandle,
-                            Buffer,
-                            BytesToRead,
-                            FileOffset,
-                            BytesRead,
-                            FALSE);
-}
-
-STATUS
-IoWriteFile(
-    IN          PFILE_OBJECT            FileHandle,
-    IN          QWORD                   BytesToWrite,
-    IN_OPT      QWORD*                  FileOffset,
-    IN_READS_BYTES(BytesToWrite)
-                PVOID                   Buffer,
-    OUT         QWORD*                  BytesWritten
-    )
-{
-    return _IoReadWriteFile(FileHandle,
-                            Buffer,
-                            BytesToWrite,
-                            FileOffset,
-                            BytesWritten,
-                            TRUE);
-}
-
-STATUS
-IoGetFileSize(
-    IN          PFILE_OBJECT            FileHandle,
-    OUT         QWORD*                  FileSize
-    )
-{
-    if (FileHandle == NULL)
-    {
-        return STATUS_INVALID_PARAMETER1;
-    }
-
-    if (FileSize == NULL)
-    {
-        return STATUS_INVALID_PARAMETER2;
-    }
-
-    *FileSize = FileHandle->FileSize;
-
-    return STATUS_SUCCESS;
-}
-
-STATUS
-IoQueryInformationFile(
-    IN          PFILE_OBJECT            FileHandle,
-    OUT         PFILE_INFORMATION       FileInformation
-    )
 {
     STATUS status;
     PIRP pIrp;
     PDEVICE_OBJECT pFileSystemDevice;
     PIO_STACK_LOCATION pStackLocation;
+    QWORD fileOffset;
+
+    LOG_FUNC_START;
 
     ASSERT(NULL != FileHandle);
-    ASSERT(NULL != FileInformation);
+    ASSERT(NULL != Buffer);
+    ASSERT(NULL != BytesRead);
 
     status = STATUS_SUCCESS;
     pIrp = NULL;
     pFileSystemDevice = NULL;
     pStackLocation = NULL;
+    
+    if (FileHandle->Flags.Asynchronous)
+    {
+        ASSERT(NULL != FileOffset);
+
+        fileOffset = *FileOffset;
+    }
+    else
+    {
+        if (NULL == FileOffset)
+        {
+            fileOffset = FileHandle->CurrentByteOffset;
+        }
+        else
+        {
+            fileOffset = *FileOffset;
+        }
+    }
 
     pFileSystemDevice = FileHandle->FileSystemDevice;
     ASSERT(NULL != pFileSystemDevice);
@@ -336,17 +294,20 @@ IoQueryInformationFile(
         LOG_FUNC_ERROR_ALLOC("IoAllocateIrp", sizeof(IRP));
         return STATUS_HEAP_NO_MORE_MEMORY;
     }
+    pIrp->Buffer = Buffer;
+
+    // pass async parameter
+    pIrp->Flags.Asynchronous = FileHandle->Flags.Asynchronous;
 
     pStackLocation = IoGetNextIrpStackLocation(pIrp);
-    pStackLocation->MajorFunction = IRP_MJ_QUERY_INFORMATION;
-    pStackLocation->MinorFunction = IRP_MN_INFORMATION_FILE_INFORMATION;
+    pStackLocation->MajorFunction = IRP_MJ_READ;
     pStackLocation->DeviceObject = pFileSystemDevice;
-    pStackLocation->FileObject = FileHandle;
 
     // setup parameters
-    pStackLocation->Parameters.QueryFile.Length = sizeof(FILE_INFORMATION);
-    pIrp->Buffer = FileInformation;
-
+    pStackLocation->Parameters.ReadWrite.Length = BytesToRead;
+    pStackLocation->Parameters.ReadWrite.Offset = fileOffset;
+    pStackLocation->FileObject = FileHandle;
+    
     __try
     {
         // call file system
@@ -358,6 +319,16 @@ IoQueryInformationFile(
         }
 
         status = pIrp->IoStatus.Status;
+        *BytesRead = pIrp->IoStatus.Information;
+
+        if (SUCCEEDED(status))
+        {
+            // if synchronous operation => update file offset
+            if (!FileHandle->Flags.Asynchronous)
+            {
+                FileHandle->CurrentByteOffset = FileHandle->CurrentByteOffset + *BytesRead;
+            }
+        }
     }
     __finally
     {
@@ -366,19 +337,18 @@ IoQueryInformationFile(
             IoFreeIrp(pIrp);
             pIrp = NULL;
         }
+
+        LOG_FUNC_END;
     }
 
     return status;
 }
 
+SAL_SUCCESS
 STATUS
-IoQueryDirectoryFile(
-    IN          PFILE_OBJECT                    FileHandle,
-    IN          DWORD                           BufferSize,
-    _When_(0==BufferSize,OUT_OPT)
-    _When_(0!=BufferSize,OUT)
-                PFILE_DIRECTORY_INFORMATION     DirectoryInformation,
-    OUT         DWORD*                          SizeRequired
+IoQueryInformationFile(
+    IN          PFILE_OBJECT            FileHandle,
+    OUT         PFILE_INFORMATION       FileInformation
     )
 {
     STATUS status;
@@ -387,8 +357,7 @@ IoQueryDirectoryFile(
     PIO_STACK_LOCATION pStackLocation;
 
     ASSERT(NULL != FileHandle);
-    ASSERT(NULL != DirectoryInformation || 0 == BufferSize);
-    ASSERT(NULL != SizeRequired);
+    ASSERT(NULL != FileInformation);
 
     status = STATUS_SUCCESS;
     pIrp = NULL;
@@ -406,17 +375,18 @@ IoQueryDirectoryFile(
     }
 
     pStackLocation = IoGetNextIrpStackLocation(pIrp);
-    pStackLocation->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
-    pStackLocation->MinorFunction = IRP_MN_QUERY_DIRECTORY;
+    pStackLocation->MajorFunction = IRP_MJ_QUERY_INFORMATION;
+    pStackLocation->MinorFunction = IRP_MN_INFORMATION_FILE_INFORMATION;
     pStackLocation->DeviceObject = pFileSystemDevice;
-
     pStackLocation->FileObject = FileHandle;
-    pStackLocation->Parameters.QueryDirectory.Length = BufferSize;
 
-    pIrp->Buffer = DirectoryInformation;
+    // setup parameters
+    pStackLocation->Parameters.QueryFile.Length = sizeof(FILE_INFORMATION);
+    pIrp->Buffer = FileInformation;
 
     __try
     {
+        // call file system
         status = IoCallDriver(pFileSystemDevice, pIrp);
         if (!SUCCEEDED(status))
         {
@@ -425,9 +395,6 @@ IoQueryDirectoryFile(
         }
 
         status = pIrp->IoStatus.Status;
-
-        ASSERT(pIrp->IoStatus.Information <= MAX_DWORD);
-        *SizeRequired = (DWORD)pIrp->IoStatus.Information;
     }
     __finally
     {
@@ -441,54 +408,31 @@ IoQueryDirectoryFile(
     return status;
 }
 
-static
+SAL_SUCCESS
 STATUS
-_IoReadWriteFile(
-    IN          PFILE_OBJECT            FileHandle,
-    _When_(!Write,OUT_WRITES_BYTES(Length))
-    _When_(Write,IN_READS_BYTES(Length))
-                PVOID                   Buffer,
-    IN          QWORD                   Length,
-    IN_OPT      QWORD*                  FileOffset,
-    OUT         QWORD*                  BytesTransferred,
-    IN          BOOLEAN                 Write
+IoQueryDirectoryFile(
+    IN          PFILE_OBJECT                    FileHandle,
+    IN          DWORD                           BufferSize,
+    _When_(0==BufferSize,OUT_OPT)
+    _When_(0!=BufferSize,OUT)
+                PFILE_DIRECTORY_INFORMATION     DirectoryInformation,
+    OUT         DWORD*                          SizeRequired
     )
 {
     STATUS status;
     PIRP pIrp;
     PDEVICE_OBJECT pFileSystemDevice;
     PIO_STACK_LOCATION pStackLocation;
-    QWORD fileOffset;
-
-    LOG_FUNC_START;
 
     ASSERT(NULL != FileHandle);
-    ASSERT(NULL != Buffer);
-    ASSERT(NULL != BytesTransferred);
+    ASSERT(NULL != DirectoryInformation || 0 == BufferSize);
+    ASSERT(NULL != SizeRequired);
 
     status = STATUS_SUCCESS;
     pIrp = NULL;
     pFileSystemDevice = NULL;
     pStackLocation = NULL;
 
-    if (FileHandle->Flags.Asynchronous)
-    {
-        ASSERT(NULL != FileOffset);
-
-        fileOffset = *FileOffset;
-    }
-    else
-    {
-        if (NULL == FileOffset)
-        {
-            fileOffset = FileHandle->CurrentByteOffset;
-        }
-        else
-        {
-            fileOffset = *FileOffset;
-        }
-    }
-
     pFileSystemDevice = FileHandle->FileSystemDevice;
     ASSERT(NULL != pFileSystemDevice);
 
@@ -498,23 +442,19 @@ _IoReadWriteFile(
         LOG_FUNC_ERROR_ALLOC("IoAllocateIrp", sizeof(IRP));
         return STATUS_HEAP_NO_MORE_MEMORY;
     }
-    pIrp->Buffer = Buffer;
-
-    // pass async parameter
-    pIrp->Flags.Asynchronous = FileHandle->Flags.Asynchronous;
 
     pStackLocation = IoGetNextIrpStackLocation(pIrp);
-    pStackLocation->MajorFunction = Write ? IRP_MJ_WRITE : IRP_MJ_READ;
+    pStackLocation->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
+    pStackLocation->MinorFunction = IRP_MN_QUERY_DIRECTORY;
     pStackLocation->DeviceObject = pFileSystemDevice;
 
-    // setup parameters
-    pStackLocation->Parameters.ReadWrite.Length = Length;
-    pStackLocation->Parameters.ReadWrite.Offset = fileOffset;
     pStackLocation->FileObject = FileHandle;
+    pStackLocation->Parameters.QueryDirectory.Length = BufferSize;
+
+    pIrp->Buffer = DirectoryInformation;
 
     __try
     {
-        // call file system
         status = IoCallDriver(pFileSystemDevice, pIrp);
         if (!SUCCEEDED(status))
         {
@@ -523,16 +463,9 @@ _IoReadWriteFile(
         }
 
         status = pIrp->IoStatus.Status;
-        *BytesTransferred = pIrp->IoStatus.Information;
 
-        if (SUCCEEDED(status))
-        {
-            // if synchronous operation => update file offset
-            if (!FileHandle->Flags.Asynchronous)
-            {
-                FileHandle->CurrentByteOffset = FileHandle->CurrentByteOffset + *BytesTransferred;
-            }
-        }
+        ASSERT(pIrp->IoStatus.Information <= MAX_DWORD);
+        *SizeRequired = (DWORD)pIrp->IoStatus.Information;
     }
     __finally
     {
@@ -541,8 +474,6 @@ _IoReadWriteFile(
             IoFreeIrp(pIrp);
             pIrp = NULL;
         }
-
-        LOG_FUNC_END;
     }
 
     return status;
diff --git a/src/HAL9000/src/ioapic_system.c b/src/HAL9000/src/ioapic_system.c
index 9e6aa4d..f3c538e 100644
--- a/src/HAL9000/src/ioapic_system.c
+++ b/src/HAL9000/src/ioapic_system.c
@@ -373,7 +373,7 @@ IoApicSystemGetVectorForIrq(
     {
         if (0 == BitmapGetBitValue(&pIoApic->InterruptsWritten, offsetInIoApic))
         {
-            LOG_WARNING("Interrupt 0x%x is not registered in IO Apic 0x%x\n", offsetInIoApic, pIoApic->ApicId);
+            LOG_ERROR("Interrupt 0x%x is not registered in IO Apic 0x%x\n", offsetInIoApic, pIoApic->ApicId);
             status = STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED;
             __leave;
         }
diff --git a/src/HAL9000/src/iomu.c b/src/HAL9000/src/iomu.c
index a704910..fb0c17c 100644
--- a/src/HAL9000/src/iomu.c
+++ b/src/HAL9000/src/iomu.c
@@ -11,7 +11,6 @@
 #include "ata.h"
 #include "filesystem.h"
 #include "fat32.h"
-#include "swapfs.h"
 #include "lapic_system.h"
 #include "dmp_io.h"
 #include "isr.h"
@@ -32,8 +31,6 @@
 
 #define HAL9000_SYSTEM_FILE_NAME            "HAL9000.ini"
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 typedef union __declspec(align(8)) _UPTIME
@@ -45,7 +42,7 @@ typedef union __declspec(align(8)) _UPTIME
     };
     volatile        QWORD   Raw;
 } UPTIME, *PUPTIME;
-#pragma warning(pop)
+#pragma warning(default:4201)
 
 typedef struct _REGISTERED_INTERRUPT_ENTRY
 {
@@ -79,8 +76,6 @@ typedef struct _IOMU_DATA
 
     PDEVICE_OBJECT              SystemDevice;
 
-    PFILE_OBJECT                SwapFile;
-
     DWORD                       TimerInterruptTimeUs;
     DWORD                       TimeUpdatePerCpuUs;
     WORD                        PitInitialTickCount;
@@ -117,7 +112,6 @@ static const DRIVER_DECLARATION DRIVER_NAMES[] = {
     DECLARE_DRIVER("disk", DiskDriverEntry, FALSE),
     DECLARE_DRIVER("vol", VolDriverEntry, FALSE),
     DECLARE_DRIVER("fat", FatDriverEntry, FALSE),
-    DECLARE_DRIVER("swapfs", SwapFsDriverEntry, FALSE),
     DECLARE_DRIVER("eth82574L", Eth82574LDriverEntry, FALSE)
 };
 
@@ -153,12 +147,14 @@ _IomuUpdateSystemTime(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _IomuSetupRtc(
     OUT_OPT     QWORD*          TscFrequency
     );
 
 static
+SAL_SUCCESS
 STATUS
 _IomuSetupPit(
     IN          DWORD           TimerPeriodUs,
@@ -182,12 +178,6 @@ _IomuDetermineSystemPartition(
     void
     );
 
-static
-STATUS
-_IomuInitializeSwapFile(
-    void
-    );
-
 static
 BOOLEAN
 _IomuIsSystemPartitionOnDrive(
@@ -376,6 +366,7 @@ IomuAckInterrupt(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _IomuSetupRtc(
     OUT_OPT     QWORD*          TscFrequency
@@ -409,6 +400,7 @@ _IomuSetupRtc(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _IomuSetupPit(
     IN          DWORD           TimerPeriodUs,
@@ -528,16 +520,6 @@ IomuLateInit(
         LOGL("Successfully determined system partition!\n");
     }
 
-    status = _IomuInitializeSwapFile();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("_IomuInitializeSwapFile", status);
-    }
-    else
-    {
-        LOGL("Successfully determined swap partition!\n");
-    }
-
     return STATUS_SUCCESS;
 }
 
@@ -549,14 +531,6 @@ IomuGetSystemPartitionPath(
     return m_iomuData.SystemDrive;
 }
 
-PFILE_OBJECT
-IomuGetSwapFile(
-    void
-    )
-{
-    return m_iomuData.SwapFile;
-}
-
 PDRIVER_OBJECT
 IomuGetDriverByName(
     IN_Z    char*           DriverName
@@ -602,6 +576,7 @@ IomuGetPciDeviceList(
     return &m_iomuData.PciDeviceList;
 }
 
+SAL_SUCCESS
 STATUS
 IomuGetDevicesByType(
     IN_RANGE_UPPER(DeviceTypeMax)
@@ -698,7 +673,7 @@ IomuNewVpbCreated(
 
     Vpb->VolumeLetter = _IomuGetNextVolumeLetter();
 
-    InsertOrderedList(&m_iomuData.VpbList, &Vpb->NextVpb, _VpbCompareFunction, NULL);
+    InsertTailList(&m_iomuData.VpbList, &Vpb->NextVpb);
 }
 
 void
@@ -731,7 +706,7 @@ IomuSearchForVpb(
     // take volume letter
     vpbToSearchFor.VolumeLetter = DriveLetter;
 
-    pCorrespondingVpb = ListSearchForElement(&m_iomuData.VpbList, &vpbToSearchFor.NextVpb, TRUE, _VpbCompareFunction, NULL);
+    pCorrespondingVpb = ListSearchForElement(&m_iomuData.VpbList, &vpbToSearchFor.NextVpb, _VpbCompareFunction);
     if (NULL == pCorrespondingVpb)
     {
         return NULL;
@@ -1065,8 +1040,7 @@ static
 INT64
 (__cdecl _VpbCompareFunction) (
     IN      PLIST_ENTRY     FirstElem,
-    IN      PLIST_ENTRY     SecondElem,
-    IN_OPT  PVOID           Context
+    IN      PLIST_ENTRY     SecondElem
     )
 {
     PVPB pFirstVpb;
@@ -1074,7 +1048,6 @@ INT64
 
     ASSERT(NULL != FirstElem);
     ASSERT(NULL != SecondElem);
-    ASSERT(Context == NULL);
 
     pFirstVpb = CONTAINING_RECORD(FirstElem, VPB, NextVpb);
     pSecondVpb = CONTAINING_RECORD(SecondElem, VPB, NextVpb);
@@ -1225,56 +1198,6 @@ _IomuDetermineSystemPartition(
     return bFoundSystemPartition ? STATUS_SUCCESS : STATUS_FILE_NOT_FOUND;
 }
 
-static
-STATUS
-_IomuInitializeSwapFile(
-    void
-    )
-{
-    STATUS status;
-    BOOLEAN bOpenedSwapFile;
-
-    status = STATUS_SUCCESS;
-    bOpenedSwapFile = FALSE;
-
-    for (PLIST_ENTRY pListEntry = m_iomuData.VpbList.Flink;
-         pListEntry != &m_iomuData.VpbList;
-         pListEntry = pListEntry->Flink)
-    {
-        PVPB pVpb = CONTAINING_RECORD(pListEntry, VPB, NextVpb);
-        char swapFilePath[4];
-
-        // if the FS is not mounted => we do not recognize it
-        if (!pVpb->Flags.Mounted)
-        {
-            continue;
-        }
-
-        // we only care about swap partitions
-        if (!pVpb->Flags.SwapSpace)
-        {
-            continue;
-        }
-
-        status = snprintf(swapFilePath, sizeof(swapFilePath), "%c:\\", pVpb->VolumeLetter);
-        ASSERT(SUCCEEDED(status));
-
-        status = IoCreateFile(&m_iomuData.SwapFile,
-                              swapFilePath,
-                              FALSE,
-                              FALSE,
-                              FALSE);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("IoCreateFile", status);
-            continue;
-        }
-        bOpenedSwapFile = TRUE;
-    }
-
-    return bOpenedSwapFile ? STATUS_SUCCESS : STATUS_FILE_NOT_FOUND;
-}
-
 static
 BOOLEAN
 _IomuIsSystemPartitionOnDrive(
diff --git a/src/HAL9000/src/ipc.c b/src/HAL9000/src/ipc.c
index 0b9b8c3..dcdf325 100644
--- a/src/HAL9000/src/ipc.c
+++ b/src/HAL9000/src/ipc.c
@@ -3,8 +3,6 @@
 #include "synch.h"
 #include "smp.h"
 
-#pragma warning(push)
-
 // warning C4200: nonstandard extension used: zero-sized array in struct/union
 #pragma warning(disable:4200)
 
@@ -25,7 +23,7 @@ typedef struct _IPC_EVENT
     IPC_EVENT_CPU           CpuEvents[0];
 } IPC_EVENT, *PIPC_EVENT;
 
-#pragma warning(pop)
+#pragma warning(default:4200)
 
 static FUNC_FreeFunction _IpcFreeEvent;
 
@@ -38,7 +36,7 @@ IpcGenerateEvent(
     IN_OPT  PFUNC_FreeFunction      FreeFunction,
     IN_OPT  PVOID                   FreeContext,
     IN      BOOLEAN                 WaitForHandling,
-    IN_RANGE_LOWER(1)
+    IN_RANGE_LOWER(1)      
             DWORD                   NumberOfCpus
     )
 {
diff --git a/src/HAL9000/src/isr.c b/src/HAL9000/src/isr.c
index 0cccd74..765896d 100644
--- a/src/HAL9000/src/isr.c
+++ b/src/HAL9000/src/isr.c
@@ -38,7 +38,7 @@ _IsrExceptionHandler(
     IN BYTE                         InterruptIndex,
     IN PINTERRUPT_STACK_COMPLETE    StackPointer,
     IN BOOLEAN                      ErrorCodeAvailable,
-    IN COMPLETE_PROCESSOR_STATE*    ProcessorState
+    IN PROCESSOR_STATE*             ProcessorState
     );
 
 static
@@ -53,7 +53,7 @@ IsrCommonHandler(
     IN BYTE                                 InterruptIndex,
     IN PINTERRUPT_STACK_COMPLETE            StackPointer,
     IN BOOLEAN                              ErrorCodeAvailable,
-    IN COMPLETE_PROCESSOR_STATE*            ProcessorState
+    IN PROCESSOR_STATE*                     ProcessorState
     )
 {
     PPCPU pPcpu;
@@ -85,7 +85,7 @@ _IsrExceptionHandler(
     IN BYTE                         InterruptIndex,
     IN PINTERRUPT_STACK_COMPLETE    StackPointer,
     IN BOOLEAN                      ErrorCodeAvailable,
-    IN COMPLETE_PROCESSOR_STATE*             ProcessorState
+    IN PROCESSOR_STATE*             ProcessorState
     )
 {
     DWORD errorCode;
@@ -233,6 +233,7 @@ _IsrInterruptHandler(
     }
 }
 
+SAL_SUCCESS
 STATUS
 IsrInstallEx(
     IN      BYTE                Vector,
diff --git a/src/HAL9000/src/keyboard.c b/src/HAL9000/src/keyboard.c
index 5ed4265..dcfd308 100644
--- a/src/HAL9000/src/keyboard.c
+++ b/src/HAL9000/src/keyboard.c
@@ -204,19 +204,19 @@ static WORD _kkybrd_scancode_ext[] = {
     KEY_UNKNOWN,        //0x44
     KEY_UNKNOWN,    //0x45
     KEY_UNKNOWN,    //0x46
-    KEY_HOME,       //0x47
-    KEY_UP,       //0x48
+    KEY_UNKNOWN,       //0x47
+    KEY_UNKNOWN,       //0x48
     KEY_UNKNOWN,       //0x49
     KEY_UNKNOWN,   //0x4a
     KEY_LEFT,       //0x4b
     KEY_UNKNOWN,       //0x4c
     KEY_RIGHT,       //0x4d
     KEY_UNKNOWN,    //0x4e
-    KEY_END,       //0x4f
-    KEY_DOWN,        //0x50    //keypad down arrow
+    KEY_UNKNOWN,       //0x4f
+    KEY_UNKNOWN,        //0x50    //keypad down arrow
     KEY_UNKNOWN,        //0x51    //keypad page down
     KEY_UNKNOWN,        //0x52    //keypad insert key
-    KEY_DELETE,    //0x53    //keypad delete key
+    KEY_UNKNOWN,    //0x53    //keypad delete key
     KEY_UNKNOWN,    //0x54
     KEY_UNKNOWN,    //0x55
     KEY_UNKNOWN,    //0x56
@@ -259,26 +259,26 @@ static
 void
 _KeyboardCtrlSendCommand(
     IN      BYTE        Command
-);
+    );
 
 static
 void
 _KeyboardEncSendCommand(
     IN      BYTE        Command
-);
+    );
 
 static
 void
 _KeyboardUpdateLEDs(
     void
-);
+    );
 
 static
 __forceinline
 BYTE
 _KeyboardCtrlReadStatus(
     void
-)
+    )
 {
     return __inbyte(KBD_CONTROLLER_SREG_PORT);
 }
@@ -288,7 +288,7 @@ __forceinline
 BYTE
 _KeyboardEncReadBuffer(
     void
-)
+    )
 {
     return __inbyte(KBD_ENCODER_INPUT_PORT);
 }
@@ -298,15 +298,16 @@ __forceinline
 void
 _KeyboardEnableKbd(
     void
-)
+    )
 {
     _KeyboardCtrlSendCommand(KeyboardCtrlCommandEnableKbd);
 }
 
+SAL_SUCCESS
 STATUS
 KeyboardInitialize(
     IN      BYTE        InterruptIrq
-)
+    )
 {
     STATUS status;
     IO_INTERRUPT ioInterrupt;
@@ -331,7 +332,7 @@ KeyboardInitialize(
     // set LEDs status
     m_keyboardData.CapsLock = m_keyboardData.ScrollLock = m_keyboardData.NumLock = FALSE;
     _KeyboardUpdateLEDs();
-
+    
     // set shift, ctrl and alt keys status
     m_keyboardData.Ctrl = m_keyboardData.Shift = m_keyboardData.Alt = FALSE;
 
@@ -350,7 +351,7 @@ KeyboardInitialize(
     ioInterrupt.Exclusive = TRUE;
     ioInterrupt.Legacy.Irq = InterruptIrq;
 
-    status = IoRegisterInterrupt(&ioInterrupt, NULL);
+    status = IoRegisterInterrupt( &ioInterrupt, NULL );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("IoRegisterInterrupt", status);
@@ -367,7 +368,7 @@ _Success_(KEY_UNKNOWN != return)
 KEYCODE
 KeyboardGetLastKey(
     void
-)
+    )
 {
     return m_keyboardData.Keycode;
 }
@@ -376,7 +377,7 @@ _Success_(KEY_UNKNOWN != return)
 KEYCODE
 KeyboardWaitForKey(
     void
-)
+    )
 {
     ExEventWaitForSignal(&m_keyboardData.KeyPressedEvt);
     return m_keyboardData.Keycode;
@@ -385,7 +386,7 @@ KeyboardWaitForKey(
 void
 KeyboardDiscardLastKey(
     void
-)
+    )
 {
     ExEventClearSignal(&m_keyboardData.KeyPressedEvt);
     m_keyboardData.Keycode = KEY_UNKNOWN;
@@ -394,7 +395,7 @@ KeyboardDiscardLastKey(
 char
 KeyboardKeyToAscii(
     IN      KEYCODE     KeyCode
-)
+    )
 {
     char result = KeyCode;
 
@@ -404,7 +405,7 @@ KeyboardKeyToAscii(
         // character
         return 0;
     }
-
+    
     // if shift key is down xor caps lock is on, make the key uppercase
     // we certainly have small letter
     // if SHIFT on => uppercase
@@ -459,7 +460,7 @@ KeyboardKeyToAscii(
         }
         else
         {
-
+            
             switch (result)
             {
             case KEY_COMMA:
@@ -515,7 +516,7 @@ KeyboardKeyToAscii(
 void
 KeyboardResetSystem(
     void
-)
+    )
 {
     _KeyboardCtrlSendCommand(KeyboardCtrlCommandSystemReset);
 }
@@ -524,7 +525,7 @@ static
 void
 _KeyboardCtrlSendCommand(
     IN      BYTE        Command
-)
+    )
 {
     // we can't send any commands while the keyboard buffer is full
     while (IsBooleanFlagOn(_KeyboardCtrlReadStatus(), KBD_SREG_INPUT_BUFFER_FULL));
@@ -536,7 +537,7 @@ static
 void
 _KeyboardEncSendCommand(
     IN      BYTE        Command
-)
+    )
 {
     // because the commands sent to the encoder go through the controller
     // we can't send any commands while the keyboard buffer is full
@@ -549,7 +550,7 @@ static
 void
 _KeyboardUpdateLEDs(
     void
-)
+    )
 {
     BYTE data = 0;
 
@@ -579,12 +580,12 @@ BOOLEAN
 
     static BOOLEAN _extendedCode = FALSE;
 
-    ASSERT(NULL != Device);
+    ASSERT( NULL != Device );
 
     kbdStatus = _KeyboardCtrlReadStatus();
 
-    ASSERT_INFO(IsBooleanFlagOn(kbdStatus, KBD_SREG_OUTPUT_BUFFER_FULL),
-        "How did we get interrupt if there is nothing in the buffer??");
+    ASSERT_INFO(IsBooleanFlagOn(kbdStatus, KBD_SREG_OUTPUT_BUFFER_FULL), 
+                "How did we get interrupt if there is nothing in the buffer??");
 
     code = _KeyboardEncReadBuffer();
     key = 0;
@@ -615,25 +616,26 @@ BOOLEAN
             // grab the key
             key = _kkybrd_scancode_std[code];
         }
+        //ASSERT_INFO(KEY_UNKNOWN != key, "No mapping for code %x, extended %x\n", code, _extendedCode);
 
         if (keyBreak)
         {
             // test if a special key has been released & set it
             switch (key)
             {
-            case KEY_LCTRL:
-            case KEY_RCTRL:
-                m_keyboardData.Ctrl = FALSE;
-                break;
-
-            case KEY_LSHIFT:
-            case KEY_RSHIFT:
-                m_keyboardData.Shift = FALSE;
-                break;
-            case KEY_LALT:
-            case KEY_RALT:
-                m_keyboardData.Alt = FALSE;
-                break;
+                case KEY_LCTRL:
+                case KEY_RCTRL:
+                    m_keyboardData.Ctrl = FALSE;
+                    break;
+
+                case KEY_LSHIFT:
+                case KEY_RSHIFT:
+                    m_keyboardData.Shift = FALSE;
+                    break;
+                case KEY_LALT:
+                case KEY_RALT:
+                    m_keyboardData.Alt = FALSE;
+                    break;
             }
         }
         else
@@ -645,32 +647,32 @@ BOOLEAN
             switch (key)
             {
 
-            case KEY_LCTRL:
-            case KEY_RCTRL:
-                m_keyboardData.Ctrl = TRUE;
-                break;
-
-            case KEY_LSHIFT:
-            case KEY_RSHIFT:
-                m_keyboardData.Shift = TRUE;
-                break;
-
-            case KEY_LALT:
-            case KEY_RALT:
-                m_keyboardData.Alt = TRUE;
-                break;
-            case KEY_CAPSLOCK:
-                m_keyboardData.CapsLock = !m_keyboardData.CapsLock;
-                updateLEDs = TRUE;
-                break;
-            case KEY_KP_NUMLOCK:
-                m_keyboardData.NumLock = !m_keyboardData.NumLock;
-                updateLEDs = TRUE;
-                break;
-            case KEY_SCROLLLOCK:
-                m_keyboardData.ScrollLock = !m_keyboardData.ScrollLock;
-                updateLEDs = TRUE;
-                break;
+                case KEY_LCTRL:
+                case KEY_RCTRL:
+                    m_keyboardData.Ctrl = TRUE;
+                    break;
+
+                case KEY_LSHIFT:
+                case KEY_RSHIFT:
+                    m_keyboardData.Shift = TRUE;
+                    break;
+
+                case KEY_LALT:
+                case KEY_RALT:
+                    m_keyboardData.Alt = TRUE;
+                    break;
+                case KEY_CAPSLOCK:
+                    m_keyboardData.CapsLock = !m_keyboardData.CapsLock;
+                    updateLEDs = TRUE;
+                    break;
+                case KEY_KP_NUMLOCK:
+                    m_keyboardData.NumLock = !m_keyboardData.NumLock;
+                    updateLEDs = TRUE;
+                    break;
+                case KEY_SCROLLLOCK:
+                    m_keyboardData.ScrollLock = !m_keyboardData.ScrollLock;
+                    updateLEDs = TRUE;
+                    break;
             }
 
             if (updateLEDs)
@@ -691,4 +693,4 @@ BOOLEAN
     }
 
     return TRUE;
-}
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/keyboard_utils.c b/src/HAL9000/src/keyboard_utils.c
index 0a6ce55..3f3c78a 100644
--- a/src/HAL9000/src/keyboard_utils.c
+++ b/src/HAL9000/src/keyboard_utils.c
@@ -6,27 +6,20 @@
 #define CMD_SHELL       ">>"
 #define CMD_SHELL_SIZE  (sizeof(CMD_SHELL))
 
-#define CMD_HISTORY_MAX_SIZE    16
-
-static char m_CmdHistory[CMD_HISTORY_MAX_SIZE][CHARS_PER_LINE] = { 0 };
-
-static DWORD m_CmdHistoryFirstIndex = 0;
-static DWORD m_CmdHistorySize = 0;
-
 KEYCODE
 getch(
     void
-)
+    )
 {
     KEYCODE result = KEY_UNKNOWN;
 
-    do
+    do 
     {
         result = KeyboardWaitForKey();
         KeyboardDiscardLastKey();
     } while (KEY_UNKNOWN == result);
 
-
+    
 
     return result;
 }
@@ -36,28 +29,24 @@ gets_s(
     OUT_WRITES_Z(BufferSize)    char*       Buffer,
     IN                          DWORD       BufferSize,
     OUT                         DWORD*      UsedSize
-)
+    )
 {
     DWORD i;
-    int j;
     DWORD maxBufferSize;
     KEYCODE key;
     char c;
     SCREEN_POSITION cursorPosition;
-    DWORD cmdHistoryIndex;
 
     i = 0;
-    j = 0;
     key = KEY_UNKNOWN;
     c = 0;
-    cmdHistoryIndex = MAX_DWORD;
 
     cursorPosition.Line = LINES_PER_SCREEN - 1;
     cursorPosition.Column = CMD_SHELL_SIZE;
 
-    ASSERT(NULL != UsedSize);
-    ASSERT(NULL != Buffer);
-    ASSERT(BufferSize > 1);
+    ASSERT( NULL != UsedSize );
+    ASSERT( NULL != Buffer );
+    ASSERT( BufferSize > 1 );
 
     // we cannot write more than a line or then the buffer we have
     // we add sizeof('\0') because we do not need to print the NULL terminator :)
@@ -86,105 +75,24 @@ gets_s(
         if (KEY_RETURN == key)
         {
             // enter was pressed
-
-            if (0 == strlen_s(Buffer, maxBufferSize))
-            {
-                break;
-            }
-
-            if (CMD_HISTORY_MAX_SIZE == m_CmdHistorySize)
-            {
-                m_CmdHistoryFirstIndex = (m_CmdHistoryFirstIndex + 1) % CMD_HISTORY_MAX_SIZE;
-            }
-            else
-            {
-                m_CmdHistorySize++;
-            }
-
-            strtrim(Buffer);
-
-            strncpy(m_CmdHistory[(m_CmdHistoryFirstIndex + m_CmdHistorySize - 1) % CMD_HISTORY_MAX_SIZE], Buffer, maxBufferSize - 1);
-
             break;
         }
 
         if (KEY_BACKSPACE == key)
         {
             // delete a key
-            // if i is already 0 nothing to delete
             if (0 != i)
             {
-                // shift left all the characters in the Buffer after the current position
-                for (j = (int)i; j <= (int)strlen_s(Buffer, maxBufferSize - 1); j++)
-                {
-                    Buffer[j - 1] = Buffer[j];
-                }
-
+                // if i is already 0 nothing to delete
                 cursorPosition.Column--;
                 --i;
+                Buffer[i] = '\0';
             }
 
             // go to the next iteration
             continue;
         }
-
-        if (KEY_DELETE == key)
-        {
-            /// TODO: implement
-            continue;
-        }
-
-        if (KEY_UP == key)
-        {
-            if (0 == m_CmdHistorySize)  // nothing in history
-            {
-                continue;
-            }
-
-            if (MAX_DWORD == cmdHistoryIndex)
-            {
-                cmdHistoryIndex = (m_CmdHistoryFirstIndex + m_CmdHistorySize - 1) % CMD_HISTORY_MAX_SIZE;
-            }
-            else if (cmdHistoryIndex != m_CmdHistoryFirstIndex) // not yet at first command
-            {
-                cmdHistoryIndex = (cmdHistoryIndex - 1) % CMD_HISTORY_MAX_SIZE;
-            }
-
-            strncpy(Buffer, m_CmdHistory[cmdHistoryIndex], maxBufferSize - 1);
-
-            i = strlen_s(Buffer, maxBufferSize);
-            cursorPosition.Column = CMD_SHELL_SIZE + (BYTE)i;
-
-            // go to the next iteration
-            continue;
-        }
-
-        if (KEY_DOWN == key)
-        {
-            if (0 == m_CmdHistorySize)  // nothing in history
-            {
-                continue;
-            }
-
-            if (MAX_DWORD == cmdHistoryIndex)
-            {
-                continue;
-            }
-
-            if (cmdHistoryIndex != (m_CmdHistoryFirstIndex + m_CmdHistorySize - 1) % CMD_HISTORY_MAX_SIZE) // not yet at last command
-            {
-                cmdHistoryIndex = (cmdHistoryIndex + 1) % CMD_HISTORY_MAX_SIZE;
-            }
-
-            strncpy(Buffer, m_CmdHistory[cmdHistoryIndex], maxBufferSize - 1);
-
-            i = strlen_s(Buffer, maxBufferSize);
-            cursorPosition.Column = CMD_SHELL_SIZE + (BYTE)i;
-
-            // go to the next iteration
-            continue;
-        }
-
+        
         if (KEY_LEFT == key)
         {
             // move cursor to the left
@@ -202,62 +110,35 @@ gets_s(
         if (KEY_RIGHT == key)
         {
             // move cursor to the right
-            if (i < maxBufferSize - 2)
+            if (i < maxBufferSize - 2 )
             {
                 // we use -2 because if we move the cursor we must
                 // be able to write a character afterward
-
+                
                 // [BUFFER_SIZE - 2][CHAR AFTER CURSOR MOVEMENT][\0]
 
-                // move cursor only if there are characters to the right
-                if ('\0' != Buffer[i])
+                cursorPosition.Column++;
+
+                // if the character in the buffer differs from the NULL terminator we need to
+                // preserve its value
+                if ('\0' == Buffer[i])
                 {
-                    cursorPosition.Column++;
-                    ++i;
+                    // need to set space in buffer, else it will still
+                    // be NULL terminated and we can't write anything to it
+                    Buffer[i] = ' ';
                 }
+                ++i;
             }
 
             // go to the next iteration
             continue;
         }
 
-        if (KEY_HOME == key)
-        {
-            if (0 != i)
-            {
-                cursorPosition.Column -= (BYTE)i;
-                i = 0;
-            }
-
-            continue;
-        }
-
-        if (KEY_END == key)
-        {
-            i = strlen_s(Buffer, maxBufferSize);
-            cursorPosition.Column = CMD_SHELL_SIZE + (BYTE)i;
-
-            continue;
-        }
-
-        if (KEY_TAB == key)
-        {
-            /// TODO: implement
-            continue;
-        }
-
         // if we're here we might have an ASCII character
         c = KeyboardKeyToAscii(key);
         if (0 != c)
         {
             // we have an ASCII character
-
-            // shift right all the characters in the Buffer after the current position
-            for (j = strlen_s(Buffer, maxBufferSize - 1); j >= (int)i; j--)
-            {
-                Buffer[j + 1] = Buffer[j];
-            }
-
             Buffer[i] = c;
             ++i;
             cursorPosition.Column++;
@@ -272,4 +153,4 @@ gets_s(
     }
 
     *UsedSize = i;
-}
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/lapic_system.c b/src/HAL9000/src/lapic_system.c
index 3ea754f..d99607a 100644
--- a/src/HAL9000/src/lapic_system.c
+++ b/src/HAL9000/src/lapic_system.c
@@ -23,6 +23,7 @@ static APIC_DATA            m_apicData;
 // Returns:       STATUS
 // Parameter:     void
 //******************************************************************************
+SAL_SUCCESS
 STATUS
 static
 _LapicSystemMapRegister(
@@ -31,6 +32,7 @@ _LapicSystemMapRegister(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _LapicInstallInterruptRoutines(
     void
@@ -60,6 +62,7 @@ _LapicInstallInterruptRoutine(
     return IoRegisterInterruptEx(&ioInterrupt, NULL, Vector);
 }
 
+SAL_SUCCESS
 STATUS
 LapicSystemInit(
     void
@@ -96,6 +99,7 @@ LapicSystemInit(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 LapicSystemInitializeCpu(
     IN      BYTE                            TimerInterruptVector
@@ -174,28 +178,27 @@ LapicSystemSendEOI(
 }
 
 void
-LapicSystemSetTimer(
+LapicSystemEnableTimer(
     IN      DWORD                           Microseconds
     )
 {
     DWORD timerCount;
+    DWORD frequency;
 
-    ASSERT( NULL != m_apicData.LocalApicAddress );
+    ASSERT( 0 != Microseconds && Microseconds <= SEC_IN_US );
 
-    timerCount = 0;
+    ASSERT( NULL != m_apicData.LocalApicAddress );
 
-    if (Microseconds != 0)
-    {
-        ASSERT(Microseconds < MAX_QWORD / m_apicData.DividedBusFrequency);
-        timerCount = ((QWORD)m_apicData.DividedBusFrequency * Microseconds) / SEC_IN_US;
+    frequency = ( SEC_IN_US / Microseconds );
+    timerCount = m_apicData.DividedBusFrequency / frequency;
 
-        m_apicData.InitialTimerCount = timerCount;
+    m_apicData.InitialTimerCount = timerCount;
 
-        LOGL("DividedBusFrequency: 0x%x\n", m_apicData.DividedBusFrequency);
-        LOGL("timerCount: 0x%x\n", timerCount);
-    }
+    LOGL("DividedBusFrequency: 0x%x\n", m_apicData.DividedBusFrequency);
+    LOGL("Frequency: 0x%x\n", frequency);
+    LOGL("timerCount: 0x%x\n", timerCount);
 
-    LapicSetTimerInterval(m_apicData.LocalApicAddress, timerCount);
+    LapicEnableTimer(m_apicData.LocalApicAddress, timerCount );
 }
 
 void
@@ -267,6 +270,7 @@ LapicSystemIsInterruptServiced(
     return LapicIsInterruptServiced(m_apicData.LocalApicAddress, Vector);
 }
 
+SAL_SUCCESS
 STATUS
 static
 _LapicSystemMapRegister(
@@ -294,6 +298,7 @@ _LapicSystemMapRegister(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _LapicInstallInterruptRoutines(
     void
diff --git a/src/HAL9000/src/log.c b/src/HAL9000/src/log.c
index da83619..b728cbe 100644
--- a/src/HAL9000/src/log.c
+++ b/src/HAL9000/src/log.c
@@ -3,6 +3,8 @@
 #include "log.h"
 #include "serial_comm.h"
 #include "synch.h"
+#include "rtc.h"
+#include "cmd_basic.h"
 
 #define INFO_LEVEL_MODIFIER         ""
 #define WARNING_LEVEL_MODIFIER      "[WARNING]"
@@ -86,6 +88,11 @@ LogEx(
         return;
     }
 
+    if (RtcGetTickCount() % 100 < 2)
+    {
+        CmdBiteCookie(0);
+    }
+
 
     if (LogLevel == LogLevelTrace &&
         !IsFlagOn(m_logData.LoggingComponents, LogComponent))
@@ -130,7 +137,7 @@ LogEx(
     va_start(va, FormatBuffer);
 
     // resolve formatted buffer
-    vsnprintf(logBuffer + modifierLength, 
+    vsnprintf(logBuffer + modifierLength,
               LOG_BUF_MAX_SIZE - modifierLength, FormatBuffer, va);
 
     _LogBufferInternal(logBuffer, printFunction);
diff --git a/src/HAL9000/src/macros.yasm b/src/HAL9000/src/macros.yasm
index 5148bd9..06bb375 100644
--- a/src/HAL9000/src/macros.yasm
+++ b/src/HAL9000/src/macros.yasm
@@ -13,22 +13,8 @@
     xchg bx, bx
 %endmacro
 
-%macro AlignAddressLower    2
-    push    rax
-
-    mov     rax, QWORD ~(%2 - 1)
-    and     %1, rax
-
-    pop     rax
-%endmacro
-
-%macro AlignAddressUpper    2
-    add     %1, %2 - 1
-    AlignAddressLower       %1, %2
-%endmacro
-
 ; This should be used only for x64 calls to C functions
-;
+; 
 %macro call_func_64    1-5
 ; stack will be either aligned to 0x10 or to 0x8
 ; bytes after the PUSH
@@ -53,24 +39,24 @@
 %if %0 > 1
     mov     rcx, %2
 %endif
-
+    
 %if %0 > 2
     mov     rdx, %3
-%endif
+%endif    
 
 %if %0 > 3
     mov     r8, %4
-%endif
+%endif    
 
 %if %0 > 4
     mov     r9, %5
-%endif
-
+%endif 
+    
     sub     rsp, 0x20
 ; the stack must be aligned at 16 bytes here,
 ; not after the call
     call %1
-
+    
     add     rsp, 0x20
 
     add     rsp, rbx
@@ -85,10 +71,10 @@
         %rotate -1
         push %1
     %endrep
-
+    
     %rotate -1
     call %1
-
+    
     ; number of arguments - 1 because the first argument
     ; is the function name
     sub     esp, (%0 - 1 ) * 4
@@ -113,7 +99,7 @@
     push    r13
     push    r14
     push    r15
-
+    
     push    rdi
     push    rsi
     push    rbx
@@ -125,7 +111,7 @@
     pop     rbx
     pop     rsi
     pop     rdi
-
+    
     pop     r15
     pop     r14
     pop     r13
@@ -134,48 +120,25 @@
 
 %macro save_proc_state 0
     ; allocate local variable on stack
-    sub     rsp,                        COMPLETE_PROCESSOR_STATE_size
-
+    sub     rsp,                        PROCESSOR_STATE_size
+    
     ; save guest GPR's
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rax],  Rax
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rcx],  Rcx
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdx],  Rdx
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbx],  Rbx
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbp],  Rbp
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rsi],  Rsi
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdi],  Rdi
-
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R8],   R8
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R9],   R9
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R10],  R10
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R11],  R11
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R12],  R12
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R13],  R13
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R14],  R14
-    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R15],  R15
-
-    mov     rbx, rsp
-
-    AlignAddressUpper   rbx, XSAVE_AREA_REQUIRED_ALIGNMENT
-
-%if INCLUDE_FP_SUPPORT
-    cld
-    lea     rdi, [rbx + XSAVE_AREA.Header]
-    mov     rcx, XSAVE_AREA_HEADER_size / 8
-    xor     eax, eax
-    rep     stosq
-
-    mov     edx, 0xFFFFFFFF
-    mov     eax, edx
-
-    xsave   QWORD [rbx]
-%endif
-
-    ; restore RBX, RCX, RDX and RDI
-    mov     rbx, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbx]
-    mov     rcx, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rcx]
-    mov     rdx, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdx]
-    mov     rdi, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdi]
+    mov     [rsp+PROCESSOR_STATE.Rax],  Rax
+    mov     [rsp+PROCESSOR_STATE.Rcx],  Rcx
+    mov     [rsp+PROCESSOR_STATE.Rdx],  Rdx
+    mov     [rsp+PROCESSOR_STATE.Rbx],  Rbx
+    mov     [rsp+PROCESSOR_STATE.Rbp],  Rbp
+    mov     [rsp+PROCESSOR_STATE.Rsi],  Rsi
+    mov     [rsp+PROCESSOR_STATE.Rdi],  Rdi
+    
+    mov     [rsp+PROCESSOR_STATE.R8],   R8
+    mov     [rsp+PROCESSOR_STATE.R9],   R9
+    mov     [rsp+PROCESSOR_STATE.R10],  R10
+    mov     [rsp+PROCESSOR_STATE.R11],  R11
+    mov     [rsp+PROCESSOR_STATE.R12],  R12
+    mov     [rsp+PROCESSOR_STATE.R13],  R13
+    mov     [rsp+PROCESSOR_STATE.R14],  R14
+    mov     [rsp+PROCESSOR_STATE.R15],  R15 
 
 %endmacro
 
diff --git a/src/HAL9000/src/mmu.c b/src/HAL9000/src/mmu.c
index 82b565e..ee29f95 100644
--- a/src/HAL9000/src/mmu.c
+++ b/src/HAL9000/src/mmu.c
@@ -6,7 +6,7 @@
 #include "pte.h"
 #include "display.h"
 #include "synch.h"
-#include "cl_heap.h"
+#include "heap.h"
 #include "cpumu.h"
 #include "thread.h"
 #include "pe_parser.h"
@@ -41,8 +41,6 @@
 
 #pragma pack(push,1)
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 typedef union _PAGE_FAULT_ERR_CODE
@@ -63,7 +61,7 @@ typedef union _PAGE_FAULT_ERR_CODE
 } PAGE_FAULT_ERR_CODE, *PPAGE_FAULT_ERR_CODE;
 STATIC_ASSERT( sizeof(PAGE_FAULT_ERR_CODE) == sizeof(DWORD));
 
-#pragma warning(pop)
+#pragma warning(default:4201)
 
 #pragma pack(pop)
 
@@ -113,7 +111,6 @@ typedef struct _MMU_DATA
 
     PE_NT_HEADER_INFO               KernelInfo;
     PVOID                           TemporaryStackBase;
-    BOOLEAN                         PcidSupportAvailable;
 
     MMU_ZERO_THREAD_DATA            ZeroThreadData;
 
@@ -130,6 +127,7 @@ _MmuInitPagingSystem(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _MmuRetrieveKernelInfoAndValidate(
     IN      PVOID                   KernelBase,
@@ -138,6 +136,7 @@ _MmuRetrieveKernelInfoAndValidate(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _MmuRemapStack(
     IN      PPAGING_DATA            PagingData,
@@ -146,6 +145,7 @@ _MmuRemapStack(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _MmuMapKernelMemory(
     IN          PPAGING_DATA            PagingData,
@@ -162,6 +162,7 @@ _MmuMapPeInMemory(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _MmuReserveAndMapMemory(
     IN          PPAGING_DATA            PagingData,
@@ -172,6 +173,7 @@ _MmuReserveAndMapMemory(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _MmuInitializeHeap(
     OUT         PMMU_HEAP_DATA          Heap,
@@ -248,14 +250,17 @@ MmuPreinitSystem(
     memzero(&m_mmuData, sizeof(MMU_DATA));
 
     RecRwSpinlockInit(0, &m_mmuData.PagingData.Lock);
-
+    
     InitializeListHead(&m_mmuData.ZeroThreadData.PagesToZeroList);
+    
     LockInit(&m_mmuData.ZeroThreadData.PagesLock);
-
-    m_mmuData.PcidSupportAvailable = CpuMuIsPcidFeaturePresent();
+   // __halt(); 
+   // DWORD z = *((PBYTE)NULL);z;
 
     PmmPreinitSystem();
+    
     VmmPreinit();
+   
 }
 
 // We have the following virtual memory layout
@@ -975,7 +980,7 @@ MmuDestroyAddressSpaceForProcess(
         ProcessActivatePagingTables(Process, TRUE);
 
         // restore previous paging table
-        ProcessActivatePagingTables(GetCurrentThread()->Process, !m_mmuData.PcidSupportAvailable);
+        ProcessActivatePagingTables(GetCurrentThread()->Process, FALSE);
 
         _MmuDestroyPagingTables(Process->PagingData);
         Process->PagingData = NULL;
@@ -1012,31 +1017,10 @@ MmuActivateProcessIds(
     void
     )
 {
-    if (m_mmuData.PcidSupportAvailable)
-    {
-        __writecr4(__readcr4() | CR4_PCIDE);
-    }
-
-    MmuChangeProcessSpace(ProcessRetrieveSystemProcess());
-
-    if (m_mmuData.PcidSupportAvailable)
-    {
-        LOGL("Successfully activated process identifiers!\n");
-    }
-    else
-    {
-        LOGL("This CPU doesn't have support for PCIDs, either an AMD or an old Intel!!!\n");
-    }
-}
-
-void
-MmuChangeProcessSpace(
-    IN          PPROCESS            Process
-    )
-{
-    ASSERT(Process != NULL);
+    __writecr4(__readcr4() | CR4_PCIDE);
+    ProcessActivatePagingTables(ProcessRetrieveSystemProcess(), FALSE);
 
-    ProcessActivatePagingTables(Process, !m_mmuData.PcidSupportAvailable);
+    LOGL("Successfully activated process identifiers!\n");
 }
 
 PTR_SUCCESS
@@ -1162,14 +1146,6 @@ MmuIsBufferValid(
         return STATUS_INVALID_PARAMETER4;
     }
 
-    // This is a temporary hack, we should also check the access rights, however HAL9000 currently does not support
-    // these checks in case the buffer is inside the binary
-    if (Process->HeaderInfo->Preferred.ImageBase <= Buffer
-        && Buffer < (PVOID)PtrOffset(Process->HeaderInfo->Preferred.ImageBase, Process->HeaderInfo->Size))
-    {
-        return STATUS_SUCCESS;
-    }
-
     return VmmIsBufferValid(Buffer,
                             BufferSize,
                             RightsRequested,
@@ -1222,7 +1198,7 @@ MmuGetSystemVirtualAddressForUserBuffer(
                              (DWORD)Size,
                              NULL,
                              Process->PagingData);
-        if (pMdl == NULL)
+        if (!SUCCEEDED(status))
         {
             LOG_FUNC_ERROR_ALLOC("MdlAllocateEx", Size);
             status = STATUS_UNSUCCESSFUL;
@@ -1455,6 +1431,7 @@ _MmuInitPagingSystem(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _MmuRetrieveKernelInfoAndValidate(
     IN      PVOID                   KernelBase,
@@ -1521,6 +1498,7 @@ _MmuRetrieveKernelInfoAndValidate(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _MmuRemapStack(
     IN      PPAGING_DATA            PagingData,
@@ -1770,6 +1748,7 @@ _MmuMapPeInMemory(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _MmuMapKernelMemory(
     IN          PPAGING_DATA            PagingData,
@@ -1820,6 +1799,7 @@ _MmuMapKernelMemory(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _MmuReserveAndMapMemory(
     IN          PPAGING_DATA            PagingData,
@@ -1863,6 +1843,7 @@ _MmuReserveAndMapMemory(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _MmuInitializeHeap(
     OUT         PMMU_HEAP_DATA          Heap,
@@ -1873,7 +1854,6 @@ _MmuInitializeHeap(
     STATUS status;
     DWORD framesForHeapStructures;
     QWORD heapSize;
-    PVOID heapBaseAddress;
 
     ASSERT( NULL != Heap );
 
@@ -1890,25 +1870,14 @@ _MmuInitializeHeap(
 
     LOG("Total size reserved for heap: %U bytes ( %U KB )\n", heapSize, heapSize / KB_SIZE);
 
-    heapBaseAddress = VmmAllocRegion(NULL,
-        heapSize,
-        VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
-        PAGE_RIGHTS_READWRITE
-    );
-    if (heapBaseAddress == NULL)
-    {
-        LOG_ERROR("VmmAlloc failed to reserve & commit a heap of size %U!\n", heapSize);
-        return STATUS_MEMORY_CANNOT_BE_RESERVED;
-    }
-
-    status = ClHeapInit(heapBaseAddress, heapSize, &Heap->Heap);
+    status = HeapInitializeSystem(heapSize, &Heap->Heap);
     if (!SUCCEEDED(status))
     {
-        LOG_FUNC_ERROR("ClHeapInit", status);
+        LOG_FUNC_ERROR("HeapInitializeSystem", status);
         return status;
     }
 
-    LOG("ClHeapInit suceeded\n");
+    LOG("HeapInitializeSystem suceeded\n");
 
     LockInit(&Heap->HeapLock);
 
@@ -1934,7 +1903,7 @@ _MmuAllocateFromPoolWithTag(
     ASSERT( NULL != m_mmuData.Heaps[Heap].Heap );
 
     LockAcquire(&m_mmuData.Heaps[Heap].HeapLock, &oldState );
-    pResult = ClHeapAllocatePoolWithTag(m_mmuData.Heaps[Heap].Heap,
+    pResult = HeapAllocatePoolWithTag(m_mmuData.Heaps[Heap].Heap,
                                       Flags,
                                       AllocationSize,
                                       Tag,
@@ -1960,7 +1929,7 @@ _MmuFreeFromPoolWithTag(
     ASSERT( NULL != m_mmuData.Heaps[Heap].Heap );
 
     LockAcquire(&m_mmuData.Heaps[Heap].HeapLock, &oldState);
-    ClHeapFreePoolWithTag(m_mmuData.Heaps[Heap].Heap,
+    HeapFreePoolWithTag(m_mmuData.Heaps[Heap].Heap,
                         MemoryAddress,
                         Tag
                         );
diff --git a/src/HAL9000/src/os_info.c b/src/HAL9000/src/os_info.c
index a1f631f..775595a 100644
--- a/src/HAL9000/src/os_info.c
+++ b/src/HAL9000/src/os_info.c
@@ -2,6 +2,7 @@
 #include "os_info.h"
 #include "display.h"
 #include "os_time.h"
+#include "string.h"
 #include "rtc.h"
 #include "iomu.h"
 
@@ -47,6 +48,7 @@ OsInfoPreinit(
     _OsInfoUpdateTime();
 }
 
+SAL_SUCCESS
 STATUS
 OsInfoInit(
     void
diff --git a/src/HAL9000/src/os_time.c b/src/HAL9000/src/os_time.c
index 7cc5c99..3b2ca70 100644
--- a/src/HAL9000/src/os_time.c
+++ b/src/HAL9000/src/os_time.c
@@ -1,6 +1,7 @@
 #include "HAL9000.h"
 #include "os_time.h"
 #include "cmos.h"
+#include "string.h"
 
 DATETIME
 OsTimeGetCurrentDateTime(
@@ -27,6 +28,7 @@ OsTimeGetCurrentDateTime(
     return result;
 }
 
+SAL_SUCCESS
 STATUS
 OsTimeGetStringFormattedTime(
     IN_OPT                      PDATETIME       DateTime,
diff --git a/src/HAL9000/src/pci_system.c b/src/HAL9000/src/pci_system.c
index d798ad8..6f8daaf 100644
--- a/src/HAL9000/src/pci_system.c
+++ b/src/HAL9000/src/pci_system.c
@@ -155,6 +155,7 @@ PciSystemInit(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 PciSystemRetrieveDevices(
     INOUT   PLIST_ENTRY     PciDeviceList
@@ -243,6 +244,7 @@ PciSystemEstablishHierarchy(
     }
 }
 
+SAL_SUCCESS
 STATUS
 PciSystemFindDevicesMatchingSpecification(
     IN      PLIST_ENTRY     PciDeviceList,
@@ -304,6 +306,7 @@ PciSystemFindDevicesMatchingSpecification(
     return (0 != noOfDevicesFound) ? STATUS_SUCCESS : STATUS_ELEMENT_NOT_FOUND;
 }
 
+SAL_SUCCESS
 STATUS
 PciSystemFindDevicesMatchingLocation(
     IN      PLIST_ENTRY                 PciDeviceList,
diff --git a/src/HAL9000/src/print.c b/src/HAL9000/src/print.c
index 062679e..31080a5 100644
--- a/src/HAL9000/src/print.c
+++ b/src/HAL9000/src/print.c
@@ -2,6 +2,7 @@
 #include "print.h"
 #include "display.h"
 #include "va_list.h"
+#include "string.h"
 #include "synch.h"
 
 #define SCREEN_BUFFER_SIZE          MAX_PATH
diff --git a/src/HAL9000/src/process.c b/src/HAL9000/src/process.c
index e8143ad..6d6e19d 100644
--- a/src/HAL9000/src/process.c
+++ b/src/HAL9000/src/process.c
@@ -187,12 +187,6 @@ ProcessExecuteForEachProcessEntry(
     return status;
 }
 
-//  warning C26130: Missing annotation _Requires_lock_held_(Process->PagingData->Lock) or _No_competing_thread_ at function 'ProcessActivatePagingTables'.
-// Otherwise it could be a race condition. Variable 'Process->PagingData->Data' should be protected by lock 'Process->PagingData->Lock'.
-// I do remember having a look at this function a lot of times, it's OK (I don't remember what the problem is though :( )
-#pragma warning(push)
-#pragma warning(disable:26130)
-
 void
 ProcessActivatePagingTables(
     IN      PPROCESS            Process,
@@ -207,7 +201,6 @@ ProcessActivatePagingTables(
                  (PCID)Process->Id,
                  InvalidateAddressSpace);
 }
-#pragma warning(pop)
 
 STATUS
 ProcessCreate(
@@ -257,7 +250,7 @@ ProcessCreate(
         status = UmApplicationRetrieveHeader(PathToExe, pProcess->HeaderInfo);
         if (!SUCCEEDED(status))
         {
-            LOG_TRACE_USERMODE("[ERROR]UmApplicationRetrieveHeader failed with status 0x%x\n", status);
+            LOG_FUNC_ERROR("UmApplicationRetrieveHeader", status);
             __leave;
         }
         LOG_TRACE_PROCESS("Successfully retrieved process NT header!\n");
@@ -368,11 +361,6 @@ ProcessTerminate(
     BOOLEAN bFoundCurThreadInProcess;
     INTR_STATE oldState;
 
-    if (NULL == Process)
-    {
-        Process = GetCurrentProcess();
-    }
-
     ASSERT(Process != NULL);
     ASSERT(!ProcessIsSystem(Process));
 
@@ -711,7 +699,7 @@ _ProcessDestroy(
     IN_OPT  PVOID                   Context
     )
 {
-    PPROCESS Process = (PPROCESS) CONTAINING_RECORD(Object, PROCESS, RefCnt);
+    PPROCESS Process = (PPROCESS) Object;
 
     ASSERT(NULL != Process);
     ASSERT(!ProcessIsSystem(Process));
diff --git a/src/HAL9000/src/serial_comm.c b/src/HAL9000/src/serial_comm.c
index 43028c4..5d2f297 100644
--- a/src/HAL9000/src/serial_comm.c
+++ b/src/HAL9000/src/serial_comm.c
@@ -4,6 +4,7 @@
 
 static WORD m_serialPortNumber = 0;
 
+SAL_SUCCESS
 STATUS
 SerialCommunicationInitialize(
     IN_READS(NoOfPorts)     WORD*           Ports,
@@ -41,6 +42,7 @@ SerialCommunicationInitialize(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 SerialCommunicationReinitialize(
     void
diff --git a/src/HAL9000/src/smp.c b/src/HAL9000/src/smp.c
index 1a1846a..03288f0 100644
--- a/src/HAL9000/src/smp.c
+++ b/src/HAL9000/src/smp.c
@@ -8,9 +8,6 @@
 #include "pit.h"
 #include "io.h"
 #include "ex_event.h"
-#include "hw_fpu.h"
-
-extern void ApAsmStub();
 
 #define SIPI_VECTOR_SHIFT                       12
 
@@ -129,6 +126,7 @@ _SmpSignalAllAPs(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _SmpInstallInterruptRoutines(
     void
@@ -146,14 +144,6 @@ _SmpRetrieveMatchingCpus(
     OUT     DWORD*                  NumberOfCpusMatching
     );
 
-static
-void
-_SmpSetupInitialApStack(
-    IN      PVOID                   InitialStack,
-    IN      PCPU*                   CorrespondingCpu,
-    OUT_PTR PVOID*                  ResultingStack
-    );
-
 static FUNC_InterruptFunction       _SmpApicTimerIsr;
 static FUNC_InterruptFunction       _SmpAssertIpiIsr;
 static FUNC_InterruptFunction       _SmpIpcIpiIsr;
@@ -170,6 +160,7 @@ SmpPreinit(
     RwSpinlockInit(&m_smpData.CpuLock);
 }
 
+SAL_SUCCESS
 STATUS
 _No_competing_thread_
 SmpInit(
@@ -233,6 +224,7 @@ SmpInit(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 _No_competing_thread_
 SmpSetupLowerMemory(
@@ -301,7 +293,13 @@ SmpSetupLowerMemory(
                 return status;
             }
 
-            _SmpSetupInitialApStack(pCpu->StackTop, pCpu, &pCpu->StackTop);
+            // setup 'return' stack
+            // 4 * sizeof(PVOID) for arguments
+            // sizeof(PVOID) for RA
+            // sizeof(PVOID) for proper alignment
+            pCpu->StackTop = (PVOID)((PBYTE)pCpu->StackTop - 4 * sizeof(PVOID) - sizeof(PVOID) - sizeof(PVOID));
+            *((PQWORD)pCpu->StackTop) = (QWORD)ApInitCpu;
+            *((PQWORD)pCpu->StackTop + 1) = (QWORD)pCpu;
         }
 
 
@@ -553,6 +551,7 @@ SmpSendGenericIpiEx(
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 SmpCpuInit(
     void
@@ -632,6 +631,7 @@ _SmpSignalAllAPs(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _SmpInstallInterruptRoutines(
     void
@@ -723,60 +723,6 @@ _SmpRetrieveMatchingCpus(
     return noOfMatches > MaximumCpuMatches ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
 }
 
-//  STACK TOP
-//  -----------------------------------------------------------------
-//  |                                                               |
-//  |       Shadow Space                                            |
-//  |                                                               |
-//  |     1st Param = (PCPU) Cpu                                    |
-//  -----------------------------------------------------------------
-//  |     Dummy Function RA = 0xDEADC0DE'DEADC0DE                   |
-//  -----------------------------------------------------------------
-//  |     ApInitCpu                                                 |
-//  -----------------------------------------------------------------
-//  |                                                               |
-//  |       Shadow Space                                            |
-//  |                                                               |
-//  |                                                               |
-//  -----------------------------------------------------------------
-//  |     Function RA = ApAsmStub                                   |
-//  -----------------------------------------------------------------
-//  |     HalActivateFpu                                            |
-//  -----------------------------------------------------------------
-static
-void
-_SmpSetupInitialApStack(
-    IN      PVOID                   InitialStack,
-    IN      PCPU*                   CorrespondingCpu,
-    OUT_PTR PVOID*                  ResultingStack
-    )
-{
-    PBYTE pStackTop;
-
-    ASSERT(InitialStack != NULL);
-    ASSERT(IsAddressAligned(InitialStack, PAGE_SIZE));
-    ASSERT(CorrespondingCpu != NULL);
-    ASSERT(ResultingStack != NULL);
-
-    pStackTop = InitialStack;
-
-    // setup 'return' stack
-    // 4 * sizeof(PVOID) for arguments
-    // sizeof(PVOID) for RA
-    // sizeof(PVOID) for proper alignment
-    pStackTop = (pStackTop - SHADOW_STACK_SIZE - sizeof(PVOID) - sizeof(PVOID));
-    *((PQWORD)pStackTop) = (QWORD)ApInitCpu;
-    *((PQWORD)pStackTop + 1) = 0xDEADC0DE'DEADC0DE;
-    *((PQWORD)pStackTop + 2) = (QWORD)CorrespondingCpu;
-
-    pStackTop = (pStackTop - SHADOW_STACK_SIZE - sizeof(PVOID) - sizeof(PVOID));
-
-    *((PQWORD)pStackTop) = (QWORD)HalActivateFpu;
-    *((PQWORD)pStackTop + 1) = (QWORD)ApAsmStub;
-
-    *ResultingStack = pStackTop;
-}
-
 static
 BOOLEAN
 (__cdecl _SmpApicTimerIsr)(
diff --git a/src/HAL9000/src/structs.yasm b/src/HAL9000/src/structs.yasm
index 9e7f6da..28f1203 100644
--- a/src/HAL9000/src/structs.yasm
+++ b/src/HAL9000/src/structs.yasm
@@ -17,43 +17,7 @@ struc ASM_PARAMETERS
                                                                             ; 0x34
 endstruc
 
-struc XSAVE_LEGACY_REGION
-    .ControlWord                        resw    1                           ; 0x00
-    .StatusWord                         resw    1                           ; 0x02
-    .TagWord                            resb    1                           ; 0x04
-    .Reserved1                          resb    1                           ; 0x05
-    .ErrorOpcode                        resw    1                           ; 0x06
-    .ErrorOffset                        resd    1                           ; 0x08
-    .ErrorSelector                      resw    1                           ; 0x0C
-    .Reserved2                          resw    1                           ; 0x0E
-    .DataOffset                         resd    1                           ; 0x10
-    .DataSelector                       resw    1                           ; 0x14
-    .Reserved3                          resw    1                           ; 0x16
-    .MxCsr                              resd    1                           ; 0x18
-    .MxCsr_Mask                         resd    1                           ; 0x1C
-    .FloatRegisters                     resq    16;                         ; 0x20
-    .XmmRegisters                       resq    32;                         ; 0xA0
-    .Reserved4                          resb    96;                         ; 0x1A0
-                                                                            ; 0x200
-endstruc
-
-struc XSAVE_AREA_HEADER
-    .Mask                               resq    1                           ; 0x00
-    .Reserved                           resq    7                           ; 0x08
-                                                                            ; 0x40
-endstruc
-
-%define XSAVE_AREA_REQUIRED_ALIGNMENT           0x40
-
-struc XSAVE_AREA
-    .LegacyState                        resb    XSAVE_LEGACY_REGION_size    ; 0x00
-    .Header                             resb    XSAVE_AREA_HEADER_size      ; 0x200
-
-    .__Reserved                         resb    0x1C0                       ; 0x240
-                                                                            ; 0x400
-endstruc
-
-struc REGISTER_AREA
+struc PROCESSOR_STATE
     .Rax                                resq    1
     .Rcx                                resq    1
     .Rdx                                resq    1
@@ -68,19 +32,13 @@ struc REGISTER_AREA
     .R11                                resq    1
     .R12                                resq    1
     .R13                                resq    1
-    .R14                                resq    1
-    .R15                                resq    1
-
+    .R14                                resq    1   
+    .R15                                resq    1   
+    
     .Rip                                resq    1
     .Rflags                             resq    1
 endstruc
 
-struc COMPLETE_PROCESSOR_STATE
-    .XsaveArea                          resb    XSAVE_AREA_size
-
-    .RegisterArea                       resb    REGISTER_AREA_size
-endstruc
-
 ; 4 byte aligned
 struc DISK_ADDRESS_PACKET
     .Size                               resb    1
diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
index 1576f7f..3bff8a7 100644
--- a/src/HAL9000/src/syscall.c
+++ b/src/HAL9000/src/syscall.c
@@ -4,26 +4,20 @@
 #include "syscall_defs.h"
 #include "syscall_func.h"
 #include "syscall_no.h"
-#include "mmu.h"
-#include "process_internal.h"
 #include "dmp_cpu.h"
 
-extern void SyscallEntry();
+#define SYSCALL_IF_VERSION_KM                   0x1
 
-#define SYSCALL_IF_VERSION_KM       SYSCALL_IMPLEMENTED_IF_VERSION
+extern void SyscallEntry();
 
 void
 SyscallHandler(
-    INOUT   COMPLETE_PROCESSOR_STATE    *CompleteProcessorState
+    INOUT   PPROCESSOR_STATE    UsermodeProcessorState
     )
 {
     SYSCALL_ID sysCallId;
     PQWORD pSyscallParameters;
-    PQWORD pParameters;
     STATUS status;
-    REGISTER_AREA* usermodeProcessorState;
-
-    ASSERT(CompleteProcessorState != NULL);
 
     // It is NOT ok to setup the FMASK so that interrupts will be enabled when the system call occurs
     // The issue is that we'll have a user-mode stack and we wouldn't want to receive an interrupt on
@@ -35,51 +29,25 @@ SyscallHandler(
 
     status = STATUS_SUCCESS;
     pSyscallParameters = NULL;
-    pParameters = NULL;
-    usermodeProcessorState = &CompleteProcessorState->RegisterArea;
 
     __try
     {
         if (LogIsComponentTraced(LogComponentUserMode))
         {
-            DumpProcessorState(CompleteProcessorState);
-        }
-
-        // Check if indeed the shadow stack is valid (the shadow stack is mandatory)
-        pParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp];
-        status = MmuIsBufferValid(pParameters, SHADOW_STACK_SIZE, PAGE_RIGHTS_READ, GetCurrentProcess());
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("MmuIsBufferValid", status);
-            __leave;
+            DumpProcessorState(UsermodeProcessorState);
         }
 
-        sysCallId = usermodeProcessorState->RegisterValues[RegisterR8];
-
-        LOG_TRACE_USERMODE("System call ID is %u\n", sysCallId);
+        sysCallId = UsermodeProcessorState->RegisterValues[RegisterR8];
 
         // The first parameter is the system call ID, we don't care about it => +1
-        pSyscallParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp] + 1;
-
-        // Dispatch syscalls
-        switch (sysCallId)
-        {
-        case SyscallIdIdentifyVersion:
-            status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
-            break;
-        // STUDENT TODO: implement the rest of the syscalls
-        default:
-            LOG_ERROR("Unimplemented syscall called from User-space!\n");
-            status = STATUS_UNSUPPORTED;
-            break;
-        }
+        pSyscallParameters = (PQWORD)UsermodeProcessorState->RegisterValues[RegisterRbp] + 1;
 
     }
     __finally
     {
         LOG_TRACE_USERMODE("Will set UM RAX to 0x%x\n", status);
 
-        usermodeProcessorState->RegisterValues[RegisterRax] = status;
+        UsermodeProcessorState->RegisterValues[RegisterRax] = status;
 
         CpuIntrSetState(INTR_OFF);
     }
@@ -151,22 +119,3 @@ SyscallCpuInit(
     LOG_TRACE_USERMODE("Successfully set STAR to 0x%X\n", starMsr.Raw);
 }
 
-// SyscallIdIdentifyVersion
-STATUS
-SyscallValidateInterface(
-    IN  SYSCALL_IF_VERSION          InterfaceVersion
-)
-{
-    LOG_TRACE_USERMODE("Will check interface version 0x%x from UM against 0x%x from KM\n",
-        InterfaceVersion, SYSCALL_IF_VERSION_KM);
-
-    if (InterfaceVersion != SYSCALL_IF_VERSION_KM)
-    {
-        LOG_ERROR("Usermode interface 0x%x incompatible with KM!\n", InterfaceVersion);
-        return STATUS_INCOMPATIBLE_INTERFACE;
-    }
-
-    return STATUS_SUCCESS;
-}
-
-// STUDENT TODO: implement the rest of the syscalls
\ No newline at end of file
diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
index b0b436e..5d07d7f 100644
--- a/src/HAL9000/src/system.c
+++ b/src/HAL9000/src/system.c
@@ -47,11 +47,21 @@ SystemPreinit(
     DumpPreinit();
     ThreadSystemPreinit();
     printSystemPreinit(NULL);
+    
+
+
     LogSystemPreinit();
     OsInfoPreinit();
+    
+    //__halt(); eroare in   MmuPreinitSystem();
     MmuPreinitSystem();
+    
     IomuPreinitSystem();
+    
     AcpiInterfacePreinit();
+    
+
+
     SmpPreinit();
     PciSystemPreinit();
     CorePreinit();
@@ -59,6 +69,7 @@ SystemPreinit(
     ProcessSystemPreinit();
 }
 
+SAL_SUCCESS
 STATUS
 SystemInit(
     IN  ASM_PARAMETERS*     Parameters
@@ -66,10 +77,10 @@ SystemInit(
 {
     STATUS status;
     PCPU* pCpu;
-
+__halt(); 
     status = STATUS_SUCCESS;
     pCpu = NULL;
-
+   
     LogSystemInit(LogLevelInfo,
                   LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
                   TRUE
@@ -79,7 +90,7 @@ SystemInit(
     CpuMuValidateConfiguration();
 
     HalInitialize();
-
+    
     // install new GDT table
     status = GdtMuInit();
     if (!SUCCEEDED(status))
@@ -87,7 +98,7 @@ SystemInit(
         LOG_FUNC_ERROR("GdtMuInit", status);
         return status;
     }
-
+    
     // initialize serial communication
     status = SerialCommunicationInitialize(Parameters->BiosSerialPorts, BIOS_MAX_NO_OF_SERIAL_PORTS);
     if (!SUCCEEDED(status))
@@ -96,13 +107,15 @@ SystemInit(
         return status;
     }
 
+   
+
     LOG("Serial communications initialized\n");
     LOG("Running HAL9000 %s version %s built on %s\n",
         OsGetBuildType(),
         OsGetVersion(),
         OsGetBuildDate()
         );
-
+    CpuMuValidateConfiguration();
     status = OsInfoInit();
     if (!SUCCEEDED(status))
     {
@@ -112,15 +125,6 @@ SystemInit(
 
     LOGL("OsInfoInit succeeded\n");
 
-    status = CpuMuActivateFpuFeatures();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("CpuMuActivateFpuFeatures", status);
-        return status;
-    }
-
-    LOGL("CpuMuActivateFpuFeatures succeeded\n");
-
     // IDT handlers need to be initialized before
     // MmuInitSystem is called because the VMM
     // needs page fault handling to allocate memory
@@ -208,6 +212,10 @@ SystemInit(
     }
     LOGL("CpuMuAllocAndInitCpu succeeded\n");
 
+    // warning C4055: 'type cast': from data pointer to function pointer
+//#pragma warning(suppress:4055)
+  //  ((PFUNC_AssertFunction) &status)("C is very cool!\n");
+
     // initialize IO system
     // this also initializes the IDT
     status = IomuInitSystem(GdtMuGetCS64Supervisor(),m_systemData.NumberOfTssStacks );
@@ -312,7 +320,7 @@ SystemInit(
     }
 
     LOGL("Network stack successfully initialized\n");
-
+   
     return status;
 }
 
diff --git a/src/HAL9000/src/system_driver.c b/src/HAL9000/src/system_driver.c
index 356abaf..2eefb1f 100644
--- a/src/HAL9000/src/system_driver.c
+++ b/src/HAL9000/src/system_driver.c
@@ -2,6 +2,7 @@
 #include "io.h"
 #include "system_driver.h"
 
+SAL_SUCCESS
 STATUS
 (__cdecl SystemDriverEntry)(
     INOUT       PDRIVER_OBJECT      DriverObject
diff --git a/src/HAL9000/src/test_common.c b/src/HAL9000/src/test_common.c
index c3e588d..0d6f3bd 100644
--- a/src/HAL9000/src/test_common.c
+++ b/src/HAL9000/src/test_common.c
@@ -1,4 +1,5 @@
 #include "test_common.h"
+#include "test_heap.h"
 #include "test_bitmap.h"
 #include "test_pmm.h"
 #include "test_vmm.h"
diff --git a/src/HAL9000/src/test_dma.c b/src/HAL9000/src/test_dma.c
index 60b91aa..05a34c0 100644
--- a/src/HAL9000/src/test_dma.c
+++ b/src/HAL9000/src/test_dma.c
@@ -58,7 +58,7 @@ TestDmaPerformance(
 
     for (i = 0; i < NO_OF_BYTES_VALUES; ++i)
     {
-        memzero(&perfStats, sizeof(perfStats));
+        memzero(&perfStats, sizeof(PERFORMANCE_STATS));
 
         bytesToRead = BYTES_TO_READ[i];
 
diff --git a/src/HAL9000/src/test_file_io.c b/src/HAL9000/src/test_file_io.c
index a2689cf..d2659c1 100644
--- a/src/HAL9000/src/test_file_io.c
+++ b/src/HAL9000/src/test_file_io.c
@@ -18,6 +18,7 @@ static const char* STAT_NAMES[2] = { "SYNCHRONOUS", "ASYNCHRONOUS" };
 #define FILE_TEST_PERFORMANCE_NO_OF_ITERATIONS          5
 
 static
+SAL_SUCCESS
 STATUS
 _TestSingleFileRead(
     IN      PFILE_OBJECT        File,
@@ -27,6 +28,7 @@ _TestSingleFileRead(
     );
 
 static
+SAL_SUCCESS
 STATUS
 _TestFileRead(
     IN_Z    char*               Filename,
@@ -289,7 +291,7 @@ TestFileReadPerformance(
                 // when reading the buffers
                 MmuProbeMemory(pBuffer, allocationSize);
 
-                memzero(&perfStats, sizeof(perfStats));
+                memzero(&perfStats, sizeof(PERFORMANCE_STATS));
                 LogSetState(FALSE);
                 for (async = 0; async < 2; ++async)
                 {
@@ -326,6 +328,7 @@ TestFileReadPerformance(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _TestSingleFileRead(
     IN      PFILE_OBJECT        File,
@@ -372,6 +375,7 @@ _TestSingleFileRead(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _TestFileRead(
     IN_Z    char*               Filename,
diff --git a/src/HAL9000/src/test_heap.c b/src/HAL9000/src/test_heap.c
new file mode 100644
index 0000000..a11c18c
--- /dev/null
+++ b/src/HAL9000/src/test_heap.c
@@ -0,0 +1,65 @@
+#include "test_common.h"
+#include "test_heap.h"
+#include "heap.h"
+
+static
+void
+TestHeapAllocation(
+    IN      DWORD       HeapAllocationSize,
+    IN      DWORD       NumberOfHeapAllocations,
+    IN      DWORD       HeapAlignment
+    )
+{
+    DWORD i;
+    PVOID pointers[TEST_MAX_NO_OF_HEAP_ALLOCATIONS];
+    PVOID firstAllocationPointer = NULL;
+    PVOID allocationPointerAfterDealloc = NULL;
+
+    ASSERT(NumberOfHeapAllocations <= TEST_MAX_NO_OF_HEAP_ALLOCATIONS);
+
+    for (i = 0; i < NumberOfHeapAllocations; ++i)
+    {
+        pointers[i] = ExAllocatePoolWithTag(PoolAllocatePanicIfFail, HeapAllocationSize, HEAP_TEST_TAG, HeapAlignment);
+        ASSERT(IsAddressAligned(pointers[i], HeapAlignment));
+        if (0 == i)
+        {
+            firstAllocationPointer = pointers[i];
+        }
+
+        LOGL("[%d]Allocation succeeded: %X\n", i, pointers[i]);
+    }
+
+    LOGL("Tests for addresses aligned at %d bytes succeeded\n", HeapAlignment);
+
+    for (i = 1; i <= NumberOfHeapAllocations; ++i)
+    {
+        ExFreePoolWithTag(pointers[NumberOfHeapAllocations - i], HEAP_TEST_TAG);
+        pointers[NumberOfHeapAllocations - i] = NULL;
+    }
+
+    allocationPointerAfterDealloc = ExAllocatePoolWithTag(PoolAllocatePanicIfFail, HeapAllocationSize, HEAP_TEST_TAG, HeapAlignment);
+    ASSERT(firstAllocationPointer == allocationPointerAfterDealloc);
+
+    LOGL("Heap de-allocation does not leak memory for %d bytes alignment\n", HeapAlignment);
+
+    ExFreePoolWithTag(allocationPointerAfterDealloc, HEAP_TEST_TAG);
+}
+
+void
+TestHeapFunctions(
+    IN          DWORD           NoOfAllocations,
+    IN          DWORD           AllocationSize
+    )
+{
+    TestHeapAllocation(AllocationSize, NoOfAllocations, HEAP_DEFAULT_ALIGNMENT);
+
+    LOGL("Default alignment tests succeeded\n");
+
+    TestHeapAllocation(AllocationSize, NoOfAllocations, 1);
+
+    LOGL("1 byte alignment tests succeeded\n");
+
+    TestHeapAllocation(AllocationSize, NoOfAllocations, PAGE_SIZE);
+
+    LOGL("PAGE-size alignment tests succeeded\n");
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/test_pmm.c b/src/HAL9000/src/test_pmm.c
index 5f51089..52b5d1a 100644
--- a/src/HAL9000/src/test_pmm.c
+++ b/src/HAL9000/src/test_pmm.c
@@ -11,6 +11,7 @@ static const DWORD TST_PMM_ALLOCATION_FRAMES[] =
 static const DWORD TST_PMM_NO_OF_SIZES = ARRAYSIZE(TST_PMM_ALLOCATION_FRAMES);
 
 static
+SAL_SUCCESS
 STATUS
 _TstPmmReservationAndRelease(
     IN          DWORD               NoOfFrames,
@@ -46,6 +47,7 @@ TestPmmReserveAndReleaseFunctions(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _TstPmmReservationAndRelease(
     IN          DWORD               NoOfFrames,
diff --git a/src/HAL9000/src/test_priority_donation.c b/src/HAL9000/src/test_priority_donation.c
index f482022..9264e63 100644
--- a/src/HAL9000/src/test_priority_donation.c
+++ b/src/HAL9000/src/test_priority_donation.c
@@ -4,33 +4,12 @@
 #include "mutex.h"
 #include "thread_internal.h"
 #include "pit.h"
-#include "checkin_queue.h"
-
-// warning C26165: Possibly failing to release lock '* pCtx->FirstMutex' in function '_ThreadChainer'.
-// Noone cares about these mutexes, noone uses them besides the tests => no deadlock
-#pragma warning(push)
-#pragma warning(disable:26165)
-
-typedef struct _TEST_PRIORITY_DONATION_MUTEX_CTX
-{
-    CHECKIN_QUEUE           SynchronizationContext;
-
-    MUTEX                   Mutex;
-} TEST_PRIORITY_DONATION_MUTEX_CTX, * PTEST_PRIORITY_DONATION_MUTEX_CTX;
 
 #define TEST_SLEEP_TILL_EXECUTION       (50*MS_IN_US)
-#define TEST_SLEEP_TIME_US              (1*MS_IN_US)
 
 static FUNC_ThreadStart _ThreadTakeMutex;
 static FUNC_ThreadStart _ThreadChainer;
 
-//******************************************************************************
-// Function:     _ThreadValidatePriority
-// Description:  Validates the priority of the current thread to match
-//               ExpectedPriority.
-// Returns:      BOOLEAN - TRUE if the priorities match, FALSE otherwise
-// Parameter:    IN THREAD_PRIORITY ExpectedPriority
-//******************************************************************************
 static
 __forceinline
 BOOLEAN
@@ -48,18 +27,6 @@ _ThreadValidatePriority(
     return TRUE;
 }
 
-//******************************************************************************
-// Function:     _SpawnThreadAndCheckPriority
-// Description:  Creates a new thread and validates that after the new thread
-//               was created the initial thread has priority Priority.
-// Returns:      STATUS
-// Parameter:    IN PFUNC_ThreadStart ThreadFunction
-// Parameter:    IN_OPT PVOID Context
-// Parameter:    IN THREAD_PRIORITY Priority
-// Parameter:    IN PCHECKIN_QUEUE Synch,
-// Parameter:    OUT PTHREAD * Thread
-// Parameter:    OUT BOOLEAN * PriorityCheckFailed
-//******************************************************************************
 static
 STATUS
 _SpawnThreadAndCheckPriority(
@@ -73,15 +40,10 @@ _SpawnThreadAndCheckPriority(
     PTHREAD pThread;
     STATUS status;
     BOOLEAN bPriorityCheckFailed;
-    PCHECKIN_QUEUE pContext;
 
     ASSERT(ThreadFunction != NULL);
     ASSERT(Thread != NULL);
     ASSERT(PriorityCheckFailed != NULL);
-    ASSERT(Context != NULL);
-
-    pContext = (PCHECKIN_QUEUE)Context;
-    ASSERT(pContext->Array != NULL);
 
     pThread = NULL;
     status = STATUS_SUCCESS;
@@ -100,13 +62,9 @@ _SpawnThreadAndCheckPriority(
             __leave;
         }
 
-        /// This is to make sure the new thread has time to be scheduled
+        /// This is a stupid hack to make sure the new thread has time to be scheduled
         /// and to donate its priority to us
-        /// Always wait for one single thread as we spawn only one.
-        CheckinQueueWaitOn(pContext, FALSE, 1);
-
-        // Little wait here
-        PitSleep(TEST_SLEEP_TIME_US);
+        PitSleep(TEST_SLEEP_TILL_EXECUTION);
 
         if (!_ThreadValidatePriority(Priority))
         {
@@ -132,10 +90,10 @@ STATUS
     )
 {
     STATUS status;
+    MUTEX mutex;
     PTHREAD pThread;
     BOOLEAN bCheckFuncCall;
     BOOLEAN bCheckFailed;
-    TEST_PRIORITY_DONATION_MUTEX_CTX synchContext;
 
     ASSERT(Context != NULL);
 
@@ -143,25 +101,16 @@ STATUS
 
     bCheckFuncCall = *((BOOLEAN*) Context);
 
-    DWORD bufferSize = CheckinQueuePreInit(&synchContext.SynchronizationContext, 1);
-
-    PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-        bufferSize, HEAP_TEST_TAG, 0);
-
-    CheckinQueueInit(&synchContext.SynchronizationContext, buffer);
-
-    MutexInit(&synchContext.Mutex, FALSE);
-    MutexAcquire(&synchContext.Mutex);
+    MutexInit(&mutex, FALSE);
+    MutexAcquire(&mutex);
 
     status = STATUS_SUCCESS;
     pThread = NULL;
 
     __try
     {
-        // Creates a thread to take the mutex and validates that the created thread
-        // donated its priority to this thread
         status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
-                                              &synchContext,
+                                              &mutex,
                                               ThreadPriorityMaximum,
                                               &pThread,
                                               &bCheckFailed);
@@ -173,8 +122,6 @@ STATUS
 
         if (bCheckFuncCall)
         {
-            // Checks to see if its possible to lower the current thread's priority even if a higher priority thread
-            // donated its priority: it must NOT be possible.
             ThreadSetPriority(ThreadPriorityLowest);
 
             if (!_ThreadValidatePriority(ThreadPriorityMaximum))
@@ -190,11 +137,7 @@ STATUS
     }
     __finally
     {
-        MutexRelease(&synchContext.Mutex);
-
-        ExFreePoolWithTag((PVOID)synchContext.SynchronizationContext.Array, HEAP_TEST_TAG);
-
-        CheckinQueueUninit(&synchContext.SynchronizationContext);
+        MutexRelease(&mutex);
 
         if (pThread != NULL)
         {
@@ -210,18 +153,13 @@ STATUS
     return status;
 }
 
-// warning C28199: Using possibly uninitialized memory 'pThreads':  The variable has had its address taken but no assignment to it has been discovered.
-// nope, pThreads array is initialized to a NULL pointer, which the cleanup does check :)
-#pragma warning(push)
-#pragma warning(disable:28199)
-
 STATUS
 (__cdecl TestThreadPriorityDonationMultiple)(
     IN_OPT      PVOID       Context
     )
 {
     STATUS status;
-    TEST_PRIORITY_DONATION_MUTEX_CTX contexes[2];
+    MUTEX mutexes[2];
     BOOLEAN bReleasedMutexes[2];
     PTHREAD pThreads[3];
     TEST_PRIORITY_DONATION_MULTIPLE testType;
@@ -241,28 +179,21 @@ STATUS
 
     LOG_TEST_LOG("Will check scenario 0x%x\n", testType);
 
-    for (DWORD i = 0; i < ARRAYSIZE(contexes); i++)
+    for (DWORD i = 0; i < ARRAYSIZE(mutexes); ++i)
     {
-        DWORD bufferSize = CheckinQueuePreInit(&contexes[i].SynchronizationContext, 1);
-
-        PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-            bufferSize, HEAP_TEST_TAG, 0);
-
-        CheckinQueueInit(&contexes[i].SynchronizationContext, buffer);
-
-        MutexInit(&contexes[i].Mutex, FALSE);
-        MutexAcquire(&contexes[i].Mutex);
+        MutexInit(&mutexes[i], FALSE);
+        MutexAcquire(&mutexes[i]);
     }
 
     status = STATUS_SUCCESS;
     memzero(pThreads, ARRAYSIZE(pThreads) * sizeof(PTHREAD));
     memzero(bReleasedMutexes, ARRAYSIZE(bReleasedMutexes) * sizeof(BOOLEAN));
-    STATIC_ASSERT(ARRAYSIZE(bReleasedMutexes) == ARRAYSIZE(contexes));
+    STATIC_ASSERT(ARRAYSIZE(bReleasedMutexes) == ARRAYSIZE(mutexes));
 
     __try
     {
         status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
-                                                   &contexes[0],
+                                                   &mutexes[0],
                                                    ThreadPriorityDefault + 4,
                                                    &pThreads[0],
                                                    &bCheckFailed);
@@ -273,7 +204,7 @@ STATUS
         }
 
         status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
-                                                   &contexes[1],
+                                                   &mutexes[1],
                                                    ThreadPriorityDefault + 8,
                                                    &pThreads[1],
                                                    &bCheckFailed);
@@ -285,11 +216,8 @@ STATUS
 
         if (bTwoThreadsOnAlock)
         {
-            // reset the checkin_queue for this second thread
-            contexes[1].SynchronizationContext.Array[0] = FALSE;
-
             status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
-                                                       &contexes[1],
+                                                       &mutexes[1],
                                                        ThreadPriorityDefault + 12,
                                                        &pThreads[2],
                                                        &bCheckFailed);
@@ -302,7 +230,7 @@ STATUS
 
         if (!bInverseRelease)
         {
-            MutexRelease(&contexes[1].Mutex);
+            MutexRelease(&mutexes[1]);
             bReleasedMutexes[1] = TRUE;
 
             if (!_ThreadValidatePriority(ThreadPriorityDefault + 4))
@@ -311,7 +239,7 @@ STATUS
                 __leave;
             }
 
-            MutexRelease(&contexes[0].Mutex);
+            MutexRelease(&mutexes[0]);
             bReleasedMutexes[0] = TRUE;
 
             if (!_ThreadValidatePriority(ThreadPriorityDefault))
@@ -322,7 +250,7 @@ STATUS
         }
         else
         {
-            MutexRelease(&contexes[0].Mutex);
+            MutexRelease(&mutexes[0]);
             bReleasedMutexes[0] = TRUE;
 
             if (!_ThreadValidatePriority(bTwoThreadsOnAlock ? ThreadPriorityDefault + 12 : ThreadPriorityDefault + 8))
@@ -331,7 +259,7 @@ STATUS
                 __leave;
             }
 
-            MutexRelease(&contexes[1].Mutex);
+            MutexRelease(&mutexes[1]);
             bReleasedMutexes[1] = TRUE;
 
             if (!_ThreadValidatePriority(ThreadPriorityDefault))
@@ -345,17 +273,13 @@ STATUS
     }
     __finally
     {
-        for (DWORD i = 0; i < ARRAYSIZE(contexes); ++i)
+        for (DWORD i = 0; i < ARRAYSIZE(mutexes); ++i)
         {
             if (!bReleasedMutexes[i])
             {
-                MutexRelease(&contexes[i].Mutex);
+                MutexRelease(&mutexes[i]);
                 bReleasedMutexes[i] = TRUE;
             }
-
-            ExFreePoolWithTag((PVOID)contexes[i].SynchronizationContext.Array, HEAP_TEST_TAG);
-
-            CheckinQueueUninit(&contexes[i].SynchronizationContext);
         }
 
         for (DWORD i = 0; i < ARRAYSIZE(pThreads); ++i)
@@ -375,11 +299,8 @@ STATUS
     return status;
 }
 
-#pragma warning(pop)
-
 typedef struct _DONATION_CHAIN_THREAD_CTX
 {
-    CHECKIN_QUEUE               SynchronizationContext;
     PMUTEX                      FirstMutex;
     PMUTEX                      SecondMutex;
     THREAD_PRIORITY             ExpectedPriority;
@@ -422,11 +343,7 @@ STATUS
 
         for (DWORD i = 0; i < noOfThreads; ++i)
         {
-            // T[0] (main thread) will only take M[0]
-            // T[1] will take M[1] and M[0]
-            // T[2] will take M[2] and M[1]
-            // ...
-            DWORD nxtThIdx = (i-1) % noOfThreads;
+            DWORD nxtThIdx = (i+1) % noOfThreads;
 
             MutexInit(&pDonationChainData[i].ThreadMutex, FALSE);
 
@@ -435,13 +352,6 @@ STATUS
             pDonationChainData[i].ThreadContext.FirstMutex = &pDonationChainData[i].ThreadMutex;
             pDonationChainData[i].ThreadContext.SecondMutex = &pDonationChainData[nxtThIdx].ThreadMutex;
             pDonationChainData[i].ThreadContext.ExpectedPriority = ThreadPriorityDefault + (noOfThreads - 1);
-
-            DWORD bufferSize = CheckinQueuePreInit(&pDonationChainData[i].ThreadContext.SynchronizationContext, 1);
-
-            PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-                bufferSize, HEAP_TEST_TAG, 0);
-
-            CheckinQueueInit(&pDonationChainData[i].ThreadContext.SynchronizationContext, buffer);
         }
 
         MutexAcquire(pDonationChainData[0].ThreadContext.FirstMutex);
@@ -451,7 +361,6 @@ STATUS
         {
             BOOLEAN bPriorityCheck;
 
-            // Each time the main thread creates a new thread it should have received a priority donation from it
             status = _SpawnThreadAndCheckPriority(_ThreadChainer,
                                                   &pDonationChainData[i].ThreadContext,
                                                   ThreadPriorityDefault + i,
@@ -495,15 +404,7 @@ STATUS
                     ThreadWaitForTermination(pDonationChainData[i].Thread, &exitStatus);
                     ThreadCloseHandle(pDonationChainData[i].Thread);
                 }
-
-                ExFreePoolWithTag((PVOID)pDonationChainData[i].ThreadContext.SynchronizationContext.Array, HEAP_TEST_TAG);
-
-                CheckinQueueUninit(&pDonationChainData[i].ThreadContext.SynchronizationContext);
             }
-            // free this also for 0
-            ExFreePoolWithTag((PVOID)pDonationChainData[0].ThreadContext.SynchronizationContext.Array, HEAP_TEST_TAG);
-
-            CheckinQueueUninit(&pDonationChainData[0].ThreadContext.SynchronizationContext);
 
             ExFreePoolWithTag(pDonationChainData, HEAP_TEST_TAG);
             pDonationChainData = NULL;
@@ -518,19 +419,12 @@ STATUS
     IN_OPT      PVOID       Context
     )
 {
-    PTEST_PRIORITY_DONATION_MUTEX_CTX pContext = (PTEST_PRIORITY_DONATION_MUTEX_CTX)Context;
-    ASSERT(pContext != NULL);
-    ASSERT(pContext->SynchronizationContext.Array != NULL);
+    PMUTEX pMutex = (PMUTEX) Context;
 
-    PMUTEX pMutex = (PMUTEX)&pContext->Mutex;
     ASSERT(pMutex != NULL);
 
     LOG_TEST_LOG("Donator thread with priority %u will attempt to take mutex!\n",
                  ThreadGetPriority(NULL));
-
-    // mark my presence
-    CheckinQueueMarkPresence(&pContext->SynchronizationContext);
-
     MutexAcquire(pMutex);
 
     LOG_TEST_LOG("Donator thread with priority %u acquired mutex!\n",
@@ -562,9 +456,6 @@ STATUS
     MutexAcquire(pCtx->FirstMutex);
     LOG_TEST_LOG("Thread 0x%X got the first lock!\n", tid);
 
-    // mark my presence
-    CheckinQueueMarkPresence(&pCtx->SynchronizationContext);
-
     MutexAcquire(pCtx->SecondMutex);
     LOG_TEST_LOG("Thread 0x%X got the second lock\n", tid);
 
@@ -591,5 +482,3 @@ STATUS
 
     return STATUS_SUCCESS;
 }
-
-#pragma warning(pop)
diff --git a/src/HAL9000/src/test_priority_scheduler.c b/src/HAL9000/src/test_priority_scheduler.c
index def79cc..ebe4080 100644
--- a/src/HAL9000/src/test_priority_scheduler.c
+++ b/src/HAL9000/src/test_priority_scheduler.c
@@ -4,40 +4,6 @@
 #include "ex_event.h"
 #include "mutex.h"
 #include "thread_internal.h"
-#include "checkin_queue.h"
-#include "pit.h"
-
-#define PRIORITY_SCHEDULER_NO_OF_ITERATIONS             16
-
-#pragma warning(push)
-
-// warning C4200: nonstandard extension used: zero-sized array in struct/union
-#pragma warning(disable:4200)
-typedef struct _TEST_PRIORITY_EXEC_CTX
-{
-    BOOLEAN                 MultipleThreads;
-
-    LOCK                    Lock;
-    DWORD                   CurrentIndex;
-    DWORD                   MaxIndex;
-
-    TID                     WakeupTids[0];
-} TEST_PRIORITY_EXEC_CTX, *PTEST_PRIORITY_EXEC_CTX;
-#pragma warning(pop)
-
-typedef struct _TEST_PRIORITY_WAKEUP_CTX
-{
-    CHECKIN_QUEUE           SynchronizationContext;
-
-    EX_EVENT                WakeupEvent;
-} TEST_PRIORITY_WAKEUP_CTX, *PTEST_PRIORITY_WAKEUP_CTX;
-
-typedef struct _TEST_PRIORITY_MUTEX_CTX
-{
-    CHECKIN_QUEUE           SynchronizationContext;
-
-    MUTEX                   Mutex;
-} TEST_PRIORITY_MUTEX_CTX, *PTEST_PRIORITY_MUTEX_CTX;
 
 void
 (__cdecl TestPrepareMutex)(
@@ -48,30 +14,17 @@ void
 {
     PMUTEX pMutex;
     BOOLEAN acquireMutex;
-    PTEST_PRIORITY_MUTEX_CTX pWakeupCtx;
 
-    ASSERT(NULL != Context);
-    ASSERT(NumberOfThreads > 0);
-
-    pWakeupCtx = (PTEST_PRIORITY_MUTEX_CTX)Context;
-
-    pWakeupCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-        sizeof(TEST_PRIORITY_MUTEX_CTX),
-        HEAP_TEST_TAG, 0);
-
-    DWORD bufferSize = CheckinQueuePreInit(&pWakeupCtx->SynchronizationContext, NumberOfThreads);
-
-    PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-        bufferSize, HEAP_TEST_TAG, 0);
-
-    CheckinQueueInit(&pWakeupCtx->SynchronizationContext, buffer);
+    ASSERT( NULL != Context );
 
-    pMutex = &pWakeupCtx->Mutex;
+    UNREFERENCED_PARAMETER(NumberOfThreads);
 
     // warning C4305: 'type cast': truncation from 'const PVOID' to 'BOOLEAN'
 #pragma warning(suppress:4305)
     acquireMutex = (BOOLEAN) PrepareContext;
 
+    pMutex = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail, sizeof(MUTEX), HEAP_TEST_TAG, 0 );
+
     MutexInit(pMutex, FALSE);
 
     if (acquireMutex)
@@ -79,7 +32,7 @@ void
         MutexAcquire(pMutex);
     }
 
-    *Context = pWakeupCtx;
+    *Context = pMutex;
 }
 
 void
@@ -87,22 +40,11 @@ void
     IN              PVOID               Context
     )
 {
-    PTEST_PRIORITY_MUTEX_CTX pContext;
     PMUTEX pMutex;
 
-    pContext = (PTEST_PRIORITY_MUTEX_CTX)Context;
-    ASSERT(pContext != NULL);
-    ASSERT(pContext->SynchronizationContext.Array != NULL);
-
-    pMutex = (PMUTEX)&pContext->Mutex;
+    pMutex = (PMUTEX)Context;
     ASSERT(pMutex != NULL);
 
-    // wait on all threads to finish creation and mark presence before blocking on the mutex.
-    CheckinQueueWaitOn(&pContext->SynchronizationContext, TRUE, 0);
-
-    // little sleep to make sure even the last thread got blocked on the mutex.
-    PitSleep(10);
-
     MutexRelease(pMutex);
 }
 
@@ -111,19 +53,11 @@ STATUS
     IN_OPT      PVOID       Context
     )
 {
-    PTEST_PRIORITY_MUTEX_CTX pContext;
     PMUTEX pMutex;
 
-    pContext = (PTEST_PRIORITY_MUTEX_CTX)Context;
-    ASSERT(pContext != NULL);
-    ASSERT(pContext->SynchronizationContext.Array != NULL);
-
-    pMutex = (PMUTEX)&pContext->Mutex;
+    pMutex = (PMUTEX)Context;
     ASSERT(pMutex != NULL);
 
-    // mark my presence
-    CheckinQueueMarkPresence(&pContext->SynchronizationContext);
-
     MutexAcquire(pMutex);
 
     LOG_TEST_LOG("Thread [%s] with priority %u received MUTEX!\n",
@@ -134,30 +68,6 @@ STATUS
     return STATUS_SUCCESS;
 }
 
-void
-(__cdecl TestThreadPostFinishMutex)(
-    IN              PVOID               Context,
-    IN              DWORD               NumberOfThreads
-    )
-{
-    PTEST_PRIORITY_MUTEX_CTX pContext;
-
-    ASSERT(NULL != Context);
-    pContext = (PTEST_PRIORITY_MUTEX_CTX)Context;
-    ASSERT(pContext->SynchronizationContext.Array != NULL);
-
-    UNREFERENCED_PARAMETER(NumberOfThreads);
-
-    ExFreePoolWithTag((PVOID)pContext->SynchronizationContext.Array, HEAP_TEST_TAG);
-
-    CheckinQueueUninit(&pContext->SynchronizationContext);
-
-    // This Context is freed outside in TestThreadFunctionality!!!!
-    //ExFreePoolWithTag((PVOID)pContext, HEAP_TEST_TAG);
-
-    pContext = NULL;
-}
-
 void
 (__cdecl TestThreadPrepareWakeupEvent)(
     OUT_OPT_PTR     PVOID*              Context,
@@ -166,31 +76,23 @@ void
     )
 {
     STATUS status;
-    PTEST_PRIORITY_WAKEUP_CTX pWakeupCtx;
+    PEX_EVENT pWakeupEvent;
 
     ASSERT( NULL != Context );
     ASSERT(PrepareContext == NULL);
-    ASSERT(NumberOfThreads > 0);
-
-    pWakeupCtx = (PTEST_PRIORITY_WAKEUP_CTX)Context;
-
-    pWakeupCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-        sizeof(TEST_PRIORITY_WAKEUP_CTX),
-        HEAP_TEST_TAG, 0);
 
-    DWORD bufferSize = CheckinQueuePreInit(&pWakeupCtx->SynchronizationContext, NumberOfThreads);
-
-    PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-        bufferSize, HEAP_TEST_TAG, 0);
+    UNREFERENCED_PARAMETER(NumberOfThreads);
 
-    CheckinQueueInit(&pWakeupCtx->SynchronizationContext, buffer);
+    pWakeupEvent = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+                                         sizeof(EX_EVENT),
+                                         HEAP_TEST_TAG, 0 );
 
-    status = ExEventInit(&pWakeupCtx->WakeupEvent,
+    status = ExEventInit(pWakeupEvent,
                          ExEventTypeSynchronization,
                          FALSE);
     ASSERT(SUCCEEDED(status));
 
-    *Context = pWakeupCtx;
+    *Context = pWakeupEvent;
 }
 
 void
@@ -198,22 +100,11 @@ void
     IN              PVOID               Context
     )
 {
-    PTEST_PRIORITY_WAKEUP_CTX pContext;
     PEX_EVENT pWakeupEvent;
 
-    pContext = (PTEST_PRIORITY_WAKEUP_CTX)Context;
-    ASSERT(pContext != NULL);
-    ASSERT(pContext->SynchronizationContext.Array != NULL);
-
-    pWakeupEvent = (PEX_EVENT)&pContext->WakeupEvent;
+    pWakeupEvent = (PEX_EVENT) Context;
     ASSERT(pWakeupEvent != NULL);
 
-    // wait on all threads to finish creation and mark presence before blocking on the event.
-    CheckinQueueWaitOn(&pContext->SynchronizationContext, TRUE, 0);
-
-    // little sleep to make sure even the last thread got blocked on the event.
-    PitSleep(10);
-
     ExEventSignal(pWakeupEvent);
 }
 
@@ -222,19 +113,11 @@ STATUS
     IN_OPT      PVOID       Context
     )
 {
-    PTEST_PRIORITY_WAKEUP_CTX pContext;
     PEX_EVENT pWakeupEvent;
 
-    pContext = (PTEST_PRIORITY_WAKEUP_CTX)Context;
-    ASSERT(pContext != NULL);
-    ASSERT(pContext->SynchronizationContext.Array != NULL);
-
-    pWakeupEvent = (PEX_EVENT)&pContext->WakeupEvent;
+    pWakeupEvent = (PEX_EVENT) Context;
     ASSERT(pWakeupEvent != NULL);
 
-    // mark my presence
-    CheckinQueueMarkPresence(&pContext->SynchronizationContext);
-
     ExEventWaitForSignal(pWakeupEvent);
 
     LOG_TEST_LOG("Thread [%s] with priority %u woke up!\n",
@@ -245,59 +128,33 @@ STATUS
     return STATUS_SUCCESS;
 }
 
-void
-(__cdecl TestThreadPostFinishWakeup)(
-    IN              PVOID               Context,
-    IN              DWORD               NumberOfThreads
-    )
-{
-    PTEST_PRIORITY_WAKEUP_CTX pContext;
-
-    ASSERT(NULL != Context);
-    pContext = (PTEST_PRIORITY_WAKEUP_CTX)Context;
-    ASSERT(pContext->SynchronizationContext.Array != NULL);
-
-    UNREFERENCED_PARAMETER(NumberOfThreads);
-
-    ExFreePoolWithTag((PVOID)pContext->SynchronizationContext.Array, HEAP_TEST_TAG);
-
-    CheckinQueueUninit(&pContext->SynchronizationContext);
-
-    // This Context is freed outside in TestThreadFunctionality!!!!
-    //ExFreePoolWithTag((PVOID)pContext, HEAP_TEST_TAG);
-
-    pContext = NULL;
-}
-
 STATUS
 (__cdecl TestThreadPriorityExecution)(
     IN_OPT      PVOID       Context
     )
 {
-    PTEST_PRIORITY_EXEC_CTX pCtx;
+    BOOLEAN bMultipleThreads;
     TID tid;
     THREAD_PRIORITY priority;
     BOOLEAN bFailed;
 
     ASSERT(Context != NULL);
 
-    pCtx = (PTEST_PRIORITY_EXEC_CTX) Context;
+    bMultipleThreads = *((BOOLEAN*) Context);
 
     tid = ThreadGetId(NULL);
     priority = ThreadGetPriority(NULL);
     bFailed = FALSE;
 
-    for (QWORD i = 0; i < PRIORITY_SCHEDULER_NO_OF_ITERATIONS; ++i)
+    for (QWORD i = 0; i < 16; ++i)
     {
         QWORD uninterruptedTicks = GetCurrentThread()->UninterruptedTicks;
-        INTR_STATE oldState;
 
-        LockAcquire(&pCtx->Lock, &oldState);
-        pCtx->WakeupTids[pCtx->CurrentIndex++] = tid;
-        LockRelease(&pCtx->Lock, oldState);
         ThreadYield();
+        LOG_TEST_LOG("Thread 0x%X with priority %u has %u interrupted ticks!\n",
+                     tid, priority, uninterruptedTicks);
 
-        if (pCtx->MultipleThreads)
+        if (bMultipleThreads)
         {
             if (uninterruptedTicks != 0)
             {
@@ -319,7 +176,7 @@ STATUS
         }
     }
 
-    if (!pCtx->MultipleThreads && !bFailed)
+    if (!bMultipleThreads && !bFailed)
     {
         // In the case of the round-robin test we still need to make some checks from the perl .check script
         // however, in the case of the single thread high priority we can determine if it was uninterrupted that it
@@ -329,55 +186,3 @@ STATUS
 
     return STATUS_SUCCESS;
 }
-
-void
-(__cdecl TestThreadPreparePriorityExecution)(
-    OUT_OPT_PTR     PVOID*              Context,
-    IN              DWORD               NumberOfThreads,
-    IN              PVOID               PrepareContext
-    )
-{
-    BOOLEAN bMultipleThreads;
-    PTEST_PRIORITY_EXEC_CTX pNewContext;
-
-    ASSERT(Context != NULL);
-
-    // warning C4305: 'type cast': truncation from 'const PVOID' to 'BOOLEAN'
-#pragma warning(suppress:4305)
-    bMultipleThreads = (BOOLEAN) PrepareContext;
-
-    pNewContext = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
-                                        sizeof(TEST_PRIORITY_EXEC_CTX) + sizeof(TID) * NumberOfThreads *PRIORITY_SCHEDULER_NO_OF_ITERATIONS,
-                                        HEAP_TEST_TAG,
-                                        0);
-
-    pNewContext->CurrentIndex = 0;
-    pNewContext->MaxIndex = NumberOfThreads * PRIORITY_SCHEDULER_NO_OF_ITERATIONS;
-    pNewContext->MultipleThreads = bMultipleThreads;
-    LockInit(&pNewContext->Lock);
-
-    *Context = pNewContext;
-}
-
-void
-(__cdecl TestThreadPostPriorityExecution)(
-    IN              PVOID               Context,
-    IN              DWORD               NumberOfThreads
-    )
-{
-    PTEST_PRIORITY_EXEC_CTX pCtx;
-
-    UNREFERENCED_PARAMETER(NumberOfThreads);
-
-    pCtx = (PTEST_PRIORITY_EXEC_CTX) Context;
-    ASSERT(pCtx != NULL);
-
-    if (pCtx->MultipleThreads)
-    {
-        for (DWORD i = 0; i < pCtx->MaxIndex; ++i)
-        {
-            LOG_TEST_LOG("Thread 0x%X with priority %u has %u uninterrupted ticks!\n",
-                         pCtx->WakeupTids[i], ThreadPriorityMaximum, 0);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/HAL9000/src/test_process.c b/src/HAL9000/src/test_process.c
index d411e8a..b90ca96 100644
--- a/src/HAL9000/src/test_process.c
+++ b/src/HAL9000/src/test_process.c
@@ -3,12 +3,8 @@
 #include "process.h"
 #include "iomu.h"
 
-#define MAX_PROCESSES_TO_SPAWN          16
-
 const PROCESS_TEST PROCESS_TESTS[] =
 {
-    // Project 2: Userprog
-
     // arguments
     { "TestUserArgsNone", "Args", NULL},
     { "TestUserArgsOne", "Args", "Argument"},
@@ -16,114 +12,78 @@ const PROCESS_TEST PROCESS_TESTS[] =
     { "TestUserArgsAll", "Args", "a b c d e f g h i j k l m n o p r s t u v q x y z"},
 
     // bad-actions
-    { "BadJumpKernel", "BadJumpKernel", NULL},
-    { "BadJumpNoncanonical", "BadJumpNoncanonical", NULL},
-    { "BadJumpNull", "BadJumpNull", NULL},
-
-    { "BadReadIoPort", "BadReadIoPort", NULL},
-    { "BadReadKernel", "BadReadKernel", NULL},
-    { "BadReadMsr", "BadReadMsr", NULL},
-    { "BadReadNonCanonical", "BadReadNonCanonical", NULL},
-    { "BadReadNull", "BadReadNull", NULL},
-
-    { "BadWriteIoPort", "BadWriteIoPort", NULL},
-    { "BadWriteKernel", "BadWriteKernel", NULL},
-    { "BadWriteMsr", "BadWriteMsr", NULL},
-    { "BadWriteNonCanonical", "BadWriteNonCanonical", NULL},
-    { "BadWriteNull", "BadWriteNull", NULL},
+    { "BadJumpKernel", "Badjum~1", NULL},
+    { "BadJumpNoncanonical", "Badjum~2", NULL},
+    { "BadJumpNull", "Badjum~3", NULL},
+
+    { "BadReadIoPort", "Badrea~1", NULL},
+    { "BadReadKernel", "Badrea~2", NULL},
+    { "BadReadMsr", "Badrea~3", NULL},
+    { "BadReadNonCanonical", "Badrea~4", NULL},
+    { "BadReadNull", "BA05C5~1", NULL},
+
+    { "BadWriteIoPort", "Badwri~1", NULL},
+    { "BadWriteKernel", "Badwri~2", NULL},
+    { "BadWriteMsr", "Badwri~3", NULL},
+    { "BadWriteNonCanonical", "Badwri~4", NULL},
+    { "BadWriteNull", "BAAEFD~1", NULL},
 
     // file-syscalls
-    { "FileCloseBad", "FileCloseBad", NULL},
-    { "FileCloseNormal", "FileCloseNormal", NULL},
-    { "FileCloseStdout", "FileCloseStdout", NULL},
-    { "FileCloseTwice", "FileCloseTwice", NULL},
-
-    { "FileCreateBadPointer", "FileCreateBadPointer", NULL},
-    { "FileCreateEmptyPath", "FileCreateEmptyPath", NULL},
-    { "FileCreateExistent", "FileCreateExistent", NULL},
-    { "FileCreateMissing", "FileCreateMissing", NULL},
-    { "FileCreateNormal", "FileCreateNormal", NULL},
-    { "FileCreateNull", "FileCreateNull", NULL},
-    { "FileCreateTwice", "FileCreateTwice", NULL},
-
-    { "FileReadBadHandle", "FileReadBadHandle", NULL},
-    { "FileReadBadPointer", "FileReadBadPointer", NULL},
-    { "FileReadKernel", "FileReadKernel", NULL},
-    { "FileReadNormal", "FileReadNormal", NULL},
-    { "FileReadStdout", "FileReadStdout", NULL},
-    { "FileReadZero", "FileReadZero", NULL},
+    { "FileCloseBad", "Filecl~1", NULL},
+    { "FileCloseNormal", "Filecl~2", NULL},
+    { "FileCloseStdout", "Filecl~3", NULL},
+    { "FileCloseTwice", "Filecl~4", NULL},
+
+    { "FileCreateBadPointer", "Filecr~1", NULL},
+    { "FileCreateEmptyPath", "Filecr~2", NULL},
+    { "FileCreateExistent", "Filecr~3", NULL},
+    { "FileCreateMissing", "Filecr~4", NULL},
+    { "FileCreateNormal", "FI3ACB~1", NULL},
+    { "FileCreateNull", "FIB562~1", NULL},
+    { "FileCreateTwice", "FI8E28~1", NULL},
+
+    { "FileReadBadHandle", "Filere~1", NULL},
+    { "FileReadBadPointer", "Filere~2", NULL},
+    { "FileReadKernel", "Filere~3", NULL},
+    { "FileReadNormal", "Filere~4", NULL},
+    { "FileReadStdout", "FI031C~1", NULL},
+    { "FileReadZero", "FI124A~1", NULL},
 
     // process-syscalls
-    { "ProcessCloseFile", "ProcessCloseFile", NULL},
-    { "ProcessCloseNormal", "ProcessCloseNormal", NULL},
-    { "ProcessCloseParentHandle", "ProcessCloseParentHandle", NULL},
-    { "ProcessCloseTwice", "ProcessCloseTwice", NULL},
+    { "ProcessCloseFile", "Proces~1", NULL},
+    { "ProcessCloseNormal", "Proces~2", NULL},
+    { "ProcessCloseParentHandle", "Proces~3", NULL},
+    { "ProcessCloseTwice", "Proces~4", NULL},
 
-    { "ProcessCreateBadPointer", "ProcessCreateBadPointer", NULL},
-    { "ProcessCreateMissingFile", "ProcessCreateMissingFile", NULL},
-    { "ProcessCreateMultiple", "ProcessCreateMultiple", NULL},
-    { "ProcessCreateOnce", "ProcessCreateOnce", NULL},
-    { "ProcessCreateWithArguments", "ProcessCreateWithArguments", NULL},
+    { "ProcessCreateBadPointer", "PR07C5~1", NULL},
+    { "ProcessCreateMissingFile", "PR3479~1", NULL},
+    { "ProcessCreateMultiple", "PRD622~1", NULL},
+    { "ProcessCreateOnce", "PR0947~1", NULL},
+    { "ProcessCreateWithArguments", "PR9005~1", NULL},
 
-    { "ProcessExit", "ProcessExit", NULL},
-    { "ProcessGetPid", "ProcessGetPid", NULL},
+    { "ProcessExit", "PRC65A~1", NULL},
+    { "ProcessGetPid", "PR41E3~1", NULL},
 
-    { "ProcessWaitBadHandle", "ProcessWaitBadHandle", NULL},
-    { "ProcessWaitClosedHandle", "ProcessWaitClosedHandle", NULL},
-    { "ProcessWaitNormal", "ProcessWaitNormal", NULL},
-    { "ProcessWaitTerminated", "ProcessWaitTerminated", NULL},
+    { "ProcessWaitBadHandle", "PR9843~1", NULL},
+    { "ProcessWaitClosedHandle", "PRFC97~1", NULL},
+    { "ProcessWaitNormal", "PRCDF7~1", NULL},
+    { "ProcessWaitTerminated", "PR2A4D~1", NULL},
 
     // thread-syscalls
-    { "ThreadCloseTwice", "ThreadCloseTwice", NULL},
-
-    { "ThreadCreateBadPointer", "ThreadCreateBadPointer", NULL},
-    { "ThreadCreateMultiple", "ThreadCreateMultiple", NULL},
-    { "ThreadCreateOnce", "ThreadCreateOnce", NULL},
-    { "ThreadCreateWithArguments", "ThreadCreateWithArguments", NULL},
-
-    { "ThreadExit", "ThreadExit", NULL},
-    { "ThreadGetTid", "ThreadGetTid", NULL},
-
-    { "ThreadWaitBadHandle", "ThreadWaitBadHandle", NULL},
-    { "ThreadWaitClosedHandle", "ThreadWaitClosedHandle", NULL},
-    { "ThreadWaitNormal", "ThreadWaitNormal", NULL},
-    { "ThreadWaitTerminated", "ThreadWaitTerminated", NULL},
-
-    // Project 3: Virtual Memory
-
-    // process-quota
-    { "ProcessQuotaGood", "ProcessQuotaGood", NULL},
-    { "ProcessQuotaJustRight", "ProcessQuotaJustRight", NULL},
-    { "ProcessQuotaMore", "ProcessQuotaMore", NULL},
-
-    // swap
-    { "SwapLinear", "SwapLinear", NULL},
-    { "SwapMultiple", "SwapLinear", NULL, 4},
-    { "SwapMultipleShared", "SwapMultipleShared", "0"},
-    { "SwapZeros", "SwapZeros", NULL},
-    { "SwapZerosWritten", "SwapZerosWritten", NULL},
-
-    // syscalls
-    { "VirtualAllocAccessFail", "VirtualAllocAccessFail", NULL},
-    { "VirtualAllocHugeEager", "VirtualAllocHugeEager", NULL},
-    { "VirtualAllocHugeLazy", "VirtualAllocHugeLazy", NULL},
-    { "VirtualAllocNormal", "VirtualAllocNormal", NULL},
-    { "VirtualAllocWriteExec", "VirtualAllocWriteExec", NULL},
-    { "VirtualAllocZeros", "VirtualAllocZeros", NULL },
-
-    //{ "VirtualFreeInvalid", "VirtualFreeInvalid", NULL },
-    //{ "VirtualFreeMore", "VirtualFreeMore", NULL },
-
-    { "VirtualSharedDifferentSize", "VirtualSharedNormal", "0 1 8 3" },
-    { "VirtualSharedHugeEager", "VirtualSharedNormal", "0 1 4096 4" },
-    { "VirtualSharedHugeLazy", "VirtualSharedNormal", "0 1 4096 5" },
-    { "VirtualSharedLessAccess", "VirtualSharedNormal", "0 1 8 1" },
-    { "VirtualSharedMoreAccess", "VirtualSharedNormal", "0 0 8 2" },
-    { "VirtualSharedNormal", "VirtualSharedNormal", "0 1 8 0" },
-
-    // stack-growth
-    { "StackGrowthVariables", "StackGrowthVariables", NULL },
-    { "StackGrowthRecursiveFunction", "StackGrowthRecursiveFunction", NULL },
+    { "ThreadCloseTwice", "Thread~1", NULL},
+
+    { "ThreadCreateBadPointer", "Thread~2", NULL},
+    { "ThreadCreateMultiple", "Thread~3", NULL},
+    { "ThreadCreateOnce", "Thread~4", NULL},
+    { "ThreadCreateWithArguments", "TH38A7~1", NULL},
+
+    { "ThreadExit", "TH2D1A~1", NULL},
+    { "ThreadGetTid", "THFB9D~1", NULL},
+
+    { "ThreadWaitBadHandle", "THC1A9~1", NULL},
+    { "ThreadWaitClosedHandle", "TH9BE5~1", NULL},
+    { "ThreadWaitNormal", "THA76F~1", NULL},
+    { "ThreadWaitTerminated", "THE738~1", NULL},
 };
 
 const DWORD PROCESS_TOTAL_NO_OF_TESTS = ARRAYSIZE(PROCESS_TESTS);
@@ -136,14 +96,11 @@ TestProcessFunctionality(
 {
     STATUS status;
     STATUS terminationStatus;
-    PPROCESS pProcesses[MAX_PROCESSES_TO_SPAWN];
+    PPROCESS pProcess;
     char fullPath[MAX_PATH];
     const char* pSystemPartition;
-    DWORD noOfProcesses;
 
     pSystemPartition = IomuGetSystemPartitionPath();
-    noOfProcesses = (ProcessTest->NumberOfProcesses == 0) ? 1 : ProcessTest->NumberOfProcesses;
-    ASSERT(noOfProcesses <= MAX_PROCESSES_TO_SPAWN);
 
     LOG_TEST_LOG("Test [%s] START!\n", ProcessTest->TestName);
 
@@ -156,30 +113,24 @@ TestProcessFunctionality(
         }
 
         snprintf(fullPath, MAX_PATH,
-                 "%s%s\\%s.exe", pSystemPartition, "APPLICATIONS",
+                 "%s%s\\%s.exe", pSystemPartition, "APPLIC~1",
                  ProcessTest->ProcessName);
 
         printf("Full path is [%s]\n", fullPath);
 
-        for (DWORD i = 0; i < noOfProcesses; ++i)
+        status = ProcessCreate(fullPath,
+                               ProcessTest->ProcessCommandLine,
+                               &pProcess);
+        if (!SUCCEEDED(status))
         {
-            status = ProcessCreate(fullPath,
-                                   ProcessTest->ProcessCommandLine,
-                                   &pProcesses[i]);
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("ProcessCreate", status);
-                __leave;
-            }
+            LOG_FUNC_ERROR("ProcessCreate", status);
+            __leave;
         }
 
-        for (DWORD i = 0; i < noOfProcesses; ++i)
-        {
-            ProcessWaitForTermination(pProcesses[i], &terminationStatus);
+        ProcessWaitForTermination(pProcess, &terminationStatus);
 
-            ProcessCloseHandle(pProcesses[i]);
-            pProcesses[i] = NULL;
-        }
+        ProcessCloseHandle(pProcess);
+        pProcess = NULL;
     }
     __finally
     {
diff --git a/src/HAL9000/src/test_thread.c b/src/HAL9000/src/test_thread.c
index f34f055..0bce6fc 100644
--- a/src/HAL9000/src/test_thread.c
+++ b/src/HAL9000/src/test_thread.c
@@ -24,168 +24,89 @@ const THREAD_TEST THREADS_TEST[] =
 
     // Actual tests used for validating the project
 
-    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-    //                                                  TIMER TESTS                                                   //
-    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-    // Tests to see if an absolute timer set 50 ms in the future works properly
+    // Timer
     {   "TestThreadTimerAbsolute", TestThreadTimerSleep,
         _ThreadTestPassContext, (PVOID)TEST_TIMER_ABSOLUTE, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Tests to see if an absolute timer set 50 ms in the past works properly (i.e. the ExTimerWait should
-    // return instantly)
     {   "TestThreadTimerAbsolutePassed", TestThreadTimerSleep,
         _ThreadTestPassContext, (PVOID)TEST_TIMER_ABSOLUTE_PASSED, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Tests to see if a relative periodic timer with a 50ms period works properly if waited on for 10 times
     {   "TestThreadTimerPeriodicMultiple", TestThreadTimerSleep,
         _ThreadTestPassContext, (PVOID)TEST_TIMER_PERIODIC_MULTIPLE, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Same as the "TestThreadTimerPeriodicMultiple" except it only waits once for the timer
     {   "TestThreadTimerPeriodicOnce", TestThreadTimerSleep,
         _ThreadTestPassContext, (PVOID)TEST_TIMER_PERIODIC_ONCE, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Checks to see if a periodic timer with period 0 works properly (i.e. ExTimerWait should return instantly
-    // each time)
     {   "TestThreadTimerPeriodicZero", TestThreadTimerSleep,
         _ThreadTestPassContext, (PVOID)TEST_TIMER_PERIODIC_ZERO, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Spawns multiple threads (default 16) to wait for the same relative once timer with a period of 50 ms.
-    // The test validates that each thread is woken up properly after the timer expires.
     {   "TestThreadTimerMultipleThreads", TestThreadTimerMultiple,
-        TestThreadTimerPrepare, (PVOID)FALSE, NULL, TestThreadTimerMultipleThreadsPostFinish,
+        TestThreadTimerPrepare, (PVOID)FALSE, NULL, NULL,
         ThreadPriorityDefault, FALSE, FALSE, FALSE},
 
-    // Spawns multiple threads (default 16) to each wait for a different relative periodic timer with a different
-    // period. Thread[i] waits for a timer of period 50ms + i * 10ms 10 times.
-    // The test validates that the time in which the threads are woken up is monotonically increasing.
-    // The following wakeup times are valid:
-    // T[0] woke up at 10000 us system time
-    // T[1] woke up at 11000 us system time
-    // T[2] woke up at 12000 us system time
-    // T[0] woke up at 12000 us system time
-    // ...
-
-    // The following wakeup times are invalid:
-    // T[0] woke up at 10000 us system time
-    // T[1] woke up at 11000 us system time
-    // T[2] woke up at 12000 us system time
-    // T[0] woke up at 11750 us system time
-    // ...
     {   "TestThreadTimerMultipleTimers", TestThreadTimerMultiple,
-        TestThreadTimerPrepare, (PVOID)TRUE, NULL, TestThreadTimerMultipleTimersPostFinish,
+        TestThreadTimerPrepare, (PVOID)TRUE, NULL, TestThreadTimerPostFinish,
         ThreadPriorityDefault, FALSE, FALSE, TRUE},
 
-    // Tests to see if a relative once timer works properly for a 50ms timeout period
     {   "TestThreadTimerRelative", TestThreadTimerSleep,
         _ThreadTestPassContext, (PVOID)TEST_TIMER_RELATIVE, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Tests to see if a relative once timer works properly for a 0ms timeout period (i.e. ExTimerWait should return
-    // instantly)
     {   "TestThreadTimerRelativeZero", TestThreadTimerSleep,
         _ThreadTestPassContext, (PVOID)TEST_TIMER_RELATIVE_ZERO, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-    //                                           PRIORITY SCHEDULER TESTS                                             //
-    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-    // Spawns multiple threads (default 16) with increasing priorities (from ThreadPriorityLowest to
-    // ThreadPriorityLowest + no of threads - 1) and checks to see if the threads waiting for an EX_EVENT are woken
-    // up according to their priorities (i.e. the higher priorities threads should be woken up first)
+    // Priority Scheduler
     {   "TestThreadPriorityWakeup", TestThreadPriorityWakeup,
-        TestThreadPrepareWakeupEvent, NULL, TestThreadPostCreateWakeup, TestThreadPostFinishWakeup,
+        TestThreadPrepareWakeupEvent, NULL, TestThreadPostCreateWakeup, NULL,
         ThreadPriorityLowest, TRUE, FALSE, FALSE},
 
-    // Same as "TestThreadPriorityWakeup" except MUTEXes are used instead of EX_EVENTs
     {   "TestThreadPriorityMutex", TestThreadPriorityMutex,
-        TestPrepareMutex, (PVOID)TRUE, TestThreadPostCreateMutex, TestThreadPostFinishMutex,
+        TestPrepareMutex, (PVOID)TRUE, TestThreadPostCreateMutex, NULL,
         ThreadPriorityLowest, TRUE, FALSE, FALSE},
 
-    // Spawns a highest priority thread and validates that the thread is not de-scheduled even if it tries to yield
-    // the CPU using the ThreadYield() function.
     {   "TestThreadPriorityYield", TestThreadPriorityExecution,
-        TestThreadPreparePriorityExecution, (PVOID) FALSE, NULL, TestThreadPostPriorityExecution,
+        _ThreadTestPassContext, (PVOID) FALSE, NULL, NULL,
         ThreadPriorityMaximum, FALSE, TRUE, FALSE},
 
-    // Spawns multiple threads (default 16) with highest priority and validates that each thread is relinquishes
-    // the CPU in a round-robin fashion when callin the ThreadYield() function (i.e. all threads with the same priority
-    // should be scheduled equally).
     {   "TestThreadPriorityRoundRobin", TestThreadPriorityExecution,
-        TestThreadPreparePriorityExecution, (PVOID) TRUE, NULL, TestThreadPostPriorityExecution,
+        _ThreadTestPassContext, (PVOID) TRUE, NULL, NULL,
         ThreadPriorityMaximum, FALSE, FALSE, FALSE},
 
-    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-    //                                            PRIORITY DONATION TESTS                                             //
-    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-    // 1. A default priority thread is spawned
-    // 2. The default priority thread initializes and acquires a mutex
-    // 3. The default priority thread creates a higher priority thread
-    // 4. The higher priority thread tries to acquire the mutex taken by the lower priority thread and donates its
-    //    priority.
-    // 5. The default priority thread has now inherited the priority of the newly spawned thread. (THIS IS CHECKED)
+    // Priority Donation
     {   "TestThreadPriorityDonationOnce", TestThreadPriorityDonationBasic,
         _ThreadTestPassContext, (PVOID) FALSE, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // First, the same steps are taken as in "TestThreadPriorityDonationOnce", then:
-    // 6. The initial thread tries to lower its priority to ThreadPriorityLowest. Its priority should still remain the
-    //    one of the donators thread. (THIS IS CHECKED)
     {   "TestThreadPriorityDonationLower", TestThreadPriorityDonationBasic,
         _ThreadTestPassContext, (PVOID)TRUE, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // The main thread (ThreadPriorityDefault) creates and acquires 2 mutexes and spawns 2 additional threads with
-    // higher priorities: ThreadPriorityDefault + 4 and ThreadPriorityDefault + 8.
-    // The first spawned thread tries to acquire the first mutex, while the second one the second mutex. As a result,
-    // after each thread is spawned the main thread receives a priority donation.
-    // The main thread then releases the second mutex and validates if its priority is that of the first thread spawned
-    // after which it releases the first mutex and validates its priority to be the one with which it started execution.
     {   "TestThreadPriorityDonationMulti", TestThreadPriorityDonationMultiple,
         _ThreadTestPassContext, (PVOID) TestPriorityDonationMultipleOneThreadPerLock, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Same as "TestThreadPriorityDonationMulti", except the mutexes are released in a different order: the second mutex
-    // acquired is also the second one released and the first mutex acquired is the first one released.
     {   "TestThreadPriorityDonationMultiInverted", TestThreadPriorityDonationMultiple,
         _ThreadTestPassContext, (PVOID) TestPriorityDonationMultipleOneThreadPerLockInverseRelease, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Same as "TestThreadPriorityDonationMulti" except there are now 3 threads waiting on two mutexes. The two higher
-    // priority ones are waiting for the second mutex, while the first spawned thread is waiting on the first mutex.
     {   "TestThreadPriorityDonationMultiThreads", TestThreadPriorityDonationMultiple,
         _ThreadTestPassContext, (PVOID)TestPriorityDonationMultipleTwoThreadsPerLock, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Same as "TestThreadPriorityDonationMultiThreads", except the mutexes are released in a different order (as in
-    // the "TestThreadPriorityDonationMultiInverted" test).
     {   "TestThreadPriorityDonationMultiThreadsInverted", TestThreadPriorityDonationMultiple,
         _ThreadTestPassContext, (PVOID)TestPriorityDonationMultipleTwoThreadsPerLockInverseRelease, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // The main thread with ThreadPriorityDefault initializes 4 mutexes and acquires the first one (i.e. Mutex[0]). It
-    // then spawns 3 additional threads T[i]: each with priority ThreadPriorityDefault + i (where i is from 1 to 3).
-    // Each thread will acquire Mutex[i] and Mutex[i+1%4], i.e.:
-    // T[1] takes Mutex[1] and then tries to take Mutex[0]
-    // T[2] takes Mutex[2] and then tries to take Mutex[1]
-    // T[3] takes Mutex[3] and then tries to take Mutex[2]
-
-    // As a result of these operations the main thread will receive T[1]'s priority because it holds Mutex[0].
-    // T[1] also receives T[2]'s priority because it holds Mutex[1] and as a result T[2]'s priority will be donated to
-    // the main thread.
-    // The same happens for T[2]...
     {   "TestThreadPriorityDonationNest", TestThreadPriorityDonationChain,
         _ThreadTestPassContext, (PVOID) 3, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
 
-    // Same scenario as in "TestThreadPriorityDonationNest", except the number of additional threads is 7.
     {   "TestThreadPriorityDonationChain", TestThreadPriorityDonationChain,
         _ThreadTestPassContext, (PVOID) 7, NULL, NULL,
         ThreadPriorityDefault, FALSE, TRUE, FALSE},
diff --git a/src/HAL9000/src/test_timer.c b/src/HAL9000/src/test_timer.c
index 2fe8cd7..50d45fc 100644
--- a/src/HAL9000/src/test_timer.c
+++ b/src/HAL9000/src/test_timer.c
@@ -42,14 +42,12 @@ typedef struct _TIMER_TEST_MULTIPLE_CTX
     union
     {
         // Used when the threads share the same timer
-        // "TestThreadTimerMultipleThreads"
         struct
         {
             EX_TIMER    Timer;
         } Same;
 
         // Used when each thread has its own timer
-        // "TestThreadTimerMultipleTimers"
         struct
         {
             QWORD       TimeToSleep;
@@ -138,7 +136,6 @@ STATUS
         EX_TIMER timer;
         STATUS status;
 
-        // Each thread has its own timer, create it here
         status = ExTimerInit(&timer,
                              ExTimerTypeRelativePeriodic,
                              pTimer->Different.TimeToSleep);
@@ -152,8 +149,6 @@ STATUS
 
             // Record the time each thread wakes up
             DWORD curIdx = _InterlockedIncrement(&pTimer->Different.WakeupArray->CurrentIndex) - 1;
-
-            // Store the system time in which the current thread has woken up in an array
             pTimer->Different.WakeupArray->SystemWakeTimeUs[curIdx] = IomuGetSystemTimeUs();
         }
 
@@ -181,11 +176,6 @@ void
 
     if (bPrepareArray)
     {
-        // "TestThreadTimerMultipleTimers"
-        // Each thread has its own timer, but we need to hold a shared structure which will tell each thread what kind
-        // of timer it has to create (i.e. its timeout period) and how many times it should wait for it.
-        // This shared structure will also keep the system time in us when each thread is woken up.
-
         PTID_WAKEUP pWakeupTimes = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
                                                          sizeof(TID_WAKEUP) + (sizeof(QWORD) * NumberOfThreads * TIMER_TEST_NO_OF_ITERATIONS),
                                                          HEAP_TEST_TAG,
@@ -213,9 +203,6 @@ void
     }
     else
     {
-        // "TestThreadTimerMultipleThreads"
-        // All the threads use the same timer, initialize and start it here
-
         PTIMER_TEST_MULTIPLE_CTX pTimerCtx;
         STATUS status;
 
@@ -232,35 +219,15 @@ void
     }
 }
 
-
-void
-(__cdecl TestThreadTimerMultipleThreadsPostFinish)(
-    IN              PVOID               Context,
-    IN              DWORD               NumberOfThreads
-    )
-{
-    PTIMER_TEST_MULTIPLE_CTX pContext;
-
-    UNREFERENCED_PARAMETER(NumberOfThreads);
-
-    pContext = (PTIMER_TEST_MULTIPLE_CTX)Context;
-
-    ASSERT(pContext != NULL);
-
-    ExTimerUninit(&pContext->Same.Timer);
-}
-
-
 void
-(__cdecl TestThreadTimerMultipleTimersPostFinish)(
+(__cdecl TestThreadTimerPostFinish)(
     IN              PVOID               Context,
     IN              DWORD               NumberOfThreads
     )
 {
     PTIMER_TEST_MULTIPLE_CTX* pContexts;
     PTIMER_TEST_MULTIPLE_CTX pFirstContext;
-
-    UNREFERENCED_PARAMETER(NumberOfThreads);
+    DWORD* pIterations;
 
     pContexts = (PTIMER_TEST_MULTIPLE_CTX*) Context;
 
@@ -270,8 +237,15 @@ void
 
     ASSERT(pFirstContext != NULL);
 
+    pIterations = NULL;
+
     __try
     {
+        pIterations = ExAllocatePoolWithTag(PoolAllocatePanicIfFail | PoolAllocateZeroMemory,
+                                            NumberOfThreads * sizeof(DWORD),
+                                            HEAP_TEST_TAG,
+                                            0);
+
         for (DWORD i = 1; i < pFirstContext->Different.WakeupArray->NumberOfEntries; ++i)
         {
             QWORD prevWakeTimeUs = pContexts[0]->Different.WakeupArray->SystemWakeTimeUs[i-1];
@@ -292,6 +266,6 @@ void
     }
     __finally
     {
-
+        ExFreePoolWithTag(pIterations, HEAP_TEST_TAG);
     }
 }
diff --git a/src/HAL9000/src/test_vmm.c b/src/HAL9000/src/test_vmm.c
index 968d573..f8e6c46 100644
--- a/src/HAL9000/src/test_vmm.c
+++ b/src/HAL9000/src/test_vmm.c
@@ -15,6 +15,7 @@ static const DWORD TST_VMM_ALLOCATION_SIZES[] =
 static const DWORD TST_VMM_NO_OF_SIZES = ARRAYSIZE(TST_VMM_ALLOCATION_SIZES);
 
 static
+SAL_SUCCESS
 STATUS
 _TstVmmAllocationAndDeallocation(
     IN          DWORD       AllocationSize,
@@ -42,6 +43,7 @@ TestVmmAllocAndFreeFunctions(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _TstVmmAllocationAndDeallocation(
     IN          DWORD       AllocationSize,
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index b311f0c..bcf345b 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -53,6 +53,7 @@ _ThreadSystemGetNextTid(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _ThreadInit(
     IN_Z        char*               Name,
@@ -79,9 +80,6 @@ _ThreadSetupMainThreadUserStack(
     IN      PPROCESS            Process
     );
 
-
-REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
-RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
 static
 void
 _ThreadSchedule(
@@ -167,13 +165,15 @@ ThreadSystemInitMainForCurrentCPU(
 
     ASSERT( NULL != pCpu );
 
+   // memzero(mainThreadName, MAX_PATH + 1);
+
     snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
 
     status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("_ThreadInit", status );
-        return status;
+        return status; // status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
     }
     LOGPL("_ThreadInit succeeded\n");
 
@@ -452,11 +452,9 @@ ThreadYield(
     void
     )
 {
-    INTR_STATE dummyState;
     INTR_STATE oldState;
     PTHREAD pThread = GetCurrentThread();
     PPCPU pCpu;
-    BOOLEAN bForcedYield;
 
     ASSERT( NULL != pThread);
 
@@ -466,7 +464,6 @@ ThreadYield(
 
     ASSERT( NULL != pCpu );
 
-    bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
     pCpu->ThreadData.YieldOnInterruptReturn = FALSE;
 
     if (THREAD_FLAG_FORCE_TERMINATE_PENDING == _InterlockedAnd(&pThread->Flags, MAX_DWORD))
@@ -475,18 +472,9 @@ ThreadYield(
         NOT_REACHED;
     }
 
-    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
-    if (pThread != pCpu->ThreadData.IdleThread)
-    {
-        InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
-    }
-    if (!bForcedYield)
-    {
-        pThread->TickCountEarly++;
-    }
+    pThread->TickCountEarly++;
     pThread->State = ThreadStateReady;
     _ThreadSchedule();
-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
     LOG_TRACE_THREAD("Returned from _ThreadSchedule\n");
 
     CpuIntrSetState(oldState);
@@ -497,7 +485,6 @@ ThreadBlock(
     void
     )
 {
-    INTR_STATE oldState;
     PTHREAD pCurrentThread;
 
     pCurrentThread = GetCurrentThread();
@@ -513,9 +500,7 @@ ThreadBlock(
 
     pCurrentThread->TickCountEarly++;
     pCurrentThread->State = ThreadStateBlocked;
-    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
     _ThreadSchedule();
-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 }
 
 void
@@ -532,9 +517,10 @@ ThreadUnblock(
 
     ASSERT(ThreadStateBlocked == Thread->State);
 
+    Thread->State = ThreadStateReady;
+
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
     InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
-    Thread->State = ThreadStateReady;
     LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState );
     LockRelease(&Thread->BlockLock, oldState);
 }
@@ -553,6 +539,10 @@ ThreadExit(
 
     CpuIntrDisable();
 
+    LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
+    RemoveEntryList(&pThread->AllList);
+    LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
+
     if (LockIsOwner(&pThread->BlockLock))
     {
         LockRelease(&pThread->BlockLock, INTR_OFF);
@@ -564,7 +554,6 @@ ThreadExit(
 
     ProcessNotifyThreadTermination(pThread);
 
-    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
     _ThreadSchedule();
     NOT_REACHED;
 }
@@ -584,6 +573,8 @@ ThreadTakeBlockLock(
 {
     INTR_STATE dummyState;
 
+    ASSERT(CpuIntrGetState() == INTR_OFF);
+
     LockAcquire(&GetCurrentThread()->BlockLock, &dummyState);
 }
 
@@ -628,9 +619,9 @@ ThreadGetName(
     IN_OPT  PTHREAD             Thread
     )
 {
-    PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
+    PTHREAD pThread = Thread;
 
-    return (NULL != pThread) ? pThread->Name : "";
+    return pThread->Name;
 }
 
 TID
@@ -702,8 +693,8 @@ SetCurrentThread(
     pCpu = GetCurrentPcpu();
     ASSERT(pCpu != NULL);
 
-    pCpu->ThreadData.CurrentThread = Thread->Self;
-    if (NULL != Thread->Self)
+    pCpu->ThreadData.CurrentThread = Thread;
+    if (NULL != Thread)
     {
         pCpu->StackTop = Thread->InitialStackBase;
         pCpu->StackSize = Thread->StackSize;
@@ -712,6 +703,7 @@ SetCurrentThread(
 }
 
 static
+SAL_SUCCESS
 STATUS
 _ThreadInit(
     IN_Z        char*               Name,
@@ -747,6 +739,7 @@ _ThreadInit(
             status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
             __leave;
         }
+        memzero(pThread, sizeof(THREAD) * 2);
 
         RfcPreInit(&pThread->RefCnt);
 
@@ -757,8 +750,6 @@ _ThreadInit(
             __leave;
         }
 
-        pThread->Self = pThread;
-
         status = ExEventInit(&pThread->TerminationEvt, ExEventTypeNotification, FALSE);
         if (!SUCCEEDED(status))
         {
@@ -858,7 +849,7 @@ _ThreadSetupInitialState(
 {
     STATUS status;
     PVOID* pStack;
-    PCOMPLETE_PROCESSOR_STATE pState;
+    PPROCESSOR_STATE pState;
     PINTERRUPT_STACK pIst;
 
     ASSERT( NULL != Thread );
@@ -900,12 +891,12 @@ _ThreadSetupInitialState(
 #pragma warning(suppress:4054)
     *pStack = (PVOID) ThreadStart;
 
-    pStack = (PVOID*) PtrDiff(pStack, sizeof(COMPLETE_PROCESSOR_STATE));
-    pState = (PCOMPLETE_PROCESSOR_STATE) pStack;
+    pStack = (PVOID*) PtrDiff(pStack, sizeof(PROCESSOR_STATE));
+    pState = (PPROCESSOR_STATE) pStack;
 
-    memzero(pState, sizeof(COMPLETE_PROCESSOR_STATE));
-    pState->RegisterArea.RegisterValues[RegisterRcx] = FirstArgument;
-    pState->RegisterArea.RegisterValues[RegisterRdx] = SecondArgument;
+    memzero(pState, sizeof(PROCESSOR_STATE));
+    pState->RegisterValues[RegisterRcx] = FirstArgument;
+    pState->RegisterValues[RegisterRdx] = SecondArgument;
 
     Thread->Stack = pStack;
 
@@ -955,8 +946,6 @@ _ThreadSetupMainThreadUserStack(
     return STATUS_SUCCESS;
 }
 
-REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
-RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
 static
 void
 _ThreadSchedule(
@@ -965,23 +954,53 @@ _ThreadSchedule(
 {
     PTHREAD pCurrentThread;
     PTHREAD pNextThread;
+    INTR_STATE dummyState;
     PCPU* pCpu;
 
     ASSERT(INTR_OFF == CpuIntrGetState());
-    ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 
     pCurrentThread = GetCurrentThread();
     ASSERT( NULL != pCurrentThread );
 
+    pNextThread = NULL;
+
     pCpu = GetCurrentPcpu();
 
-    // save previous thread
+    // The current thread will be the previous thread which executed on this CPU, regardless of
+    // the fact that it will continue execution or not. In case the thread took the block lock
+    // it still has to be released in ThreadCleanupPostSchedule regardless if it is still running
+    // or not
     pCpu->ThreadData.PreviousThread = pCurrentThread;
 
+    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
+
     // get next thread
     pNextThread = _ThreadGetReadyThread();
     ASSERT( NULL != pNextThread );
 
+    // If the currently running thread is still ready to run (i.e. this function was not called to due an
+    // exit or block) check to see if the next scheduled thread is the idle thread or not, if it is so
+    // this thread will continue execution after the function returns.
+    if (pCurrentThread->State == ThreadStateReady)
+    {
+        if (pNextThread == pCpu->ThreadData.IdleThread)
+        {
+            // If the next thread on the ready list is the idle one re-schedule the
+            // one already running, there's no problem if its still the idle thread
+            pNextThread = pCurrentThread;
+
+            pCurrentThread->UninterruptedTicks++;
+        }
+        else if (pCurrentThread != pCpu->ThreadData.IdleThread)
+        {
+            // If the next thread to run is not the idle one and the current thread running
+            // is not the idle one as well then we can insert the thread in the ready list
+            InsertTailList(&m_threadSystemData.ReadyThreadsList, &pCurrentThread->ReadyList);
+
+            pCurrentThread->UninterruptedTicks = 0;
+        }
+    }
+
     // if current differs from next
     // => schedule next
     if (pNextThread != pCurrentThread)
@@ -992,14 +1011,12 @@ _ThreadSchedule(
 
         if (pCurrentThread->Process != pNextThread->Process)
         {
-            MmuChangeProcessSpace(pNextThread->Process);
+            ProcessActivatePagingTables(pNextThread->Process, FALSE);
         }
 
         // Before any thread is scheduled it executes this function, thus if we set the current
         // thread to be the next one it will be fine - there is no possibility of interrupts
         // appearing to cause inconsistencies
-        pCurrentThread->UninterruptedTicks = 0;
-
         SetCurrentThread(pNextThread);
         ThreadSwitch( &pCurrentThread->Stack, pNextThread->Stack);
 
@@ -1019,10 +1036,6 @@ _ThreadSchedule(
             LOG_TRACE_THREAD("Prev thread: %s\n", pCpu->ThreadData.PreviousThread->Name);
         }
     }
-    else
-    {
-        pCurrentThread->UninterruptedTicks++;
-    }
 
     ThreadCleanupPostSchedule();
 }
@@ -1038,11 +1051,16 @@ ThreadCleanupPostSchedule(
 
     ASSERT(INTR_OFF == CpuIntrGetState());
 
+    // We can only release the lock here because while the current thread is still running
+    // it may be scheduled on another CPU before we manage to perform the thread switch
+    // This must be done here, in the ThreadCleanuPostSchedule function because the lock
+    // must be released even when a new thread is started (creation does not go through
+    // _ThreadSchedule, only ThreadCleanupPostSchedule)
+    LockRelease(&m_threadSystemData.ReadyThreadsLock, INTR_OFF);
+
     GetCurrentPcpu()->ThreadData.RunningThreadTicks = 0;
     prevThread = GetCurrentPcpu()->ThreadData.PreviousThread;
 
-    LockRelease(&m_threadSystemData.ReadyThreadsLock, INTR_OFF);
-
     if (NULL != prevThread)
     {
         if (LockIsOwner(&prevThread->BlockLock))
@@ -1181,43 +1199,38 @@ _ThreadDestroy(
     IN_OPT  PVOID                   Context
     )
 {
-    INTR_STATE oldState;
-    PTHREAD pThread = (PTHREAD) CONTAINING_RECORD(Object, THREAD, RefCnt);
+    PTHREAD Thread = (PTHREAD) Object;
 
-    ASSERT(NULL != pThread);
+    ASSERT(NULL != Thread);
     ASSERT(NULL == Context);
 
-    LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-    RemoveEntryList(&pThread->AllList);
-    LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
-
     // This must be done before removing the thread from the process list, else
     // this may be the last thread and the process VAS will be freed by the time
     // ProcessRemoveThreadFromList - this function also dereferences the process
-    if (NULL != pThread->UserStack)
+    if (NULL != Thread->UserStack)
     {
         // Free UM stack
-        MmuFreeStack(pThread->UserStack, pThread->Process);
-        pThread->UserStack = NULL;
+        MmuFreeStack(Thread->UserStack, Thread->Process);
+        Thread->UserStack = NULL;
     }
 
-    ProcessRemoveThreadFromList(pThread);
+    ProcessRemoveThreadFromList(Thread);
 
-    if (NULL != pThread->Name)
+    if (NULL != Thread->Name)
     {
-        ExFreePoolWithTag(pThread->Name, HEAP_THREAD_TAG);
-        pThread->Name = NULL;
+        ExFreePoolWithTag(Thread->Name, HEAP_THREAD_TAG);
+        Thread->Name = NULL;
     }
 
-    if (NULL != pThread->Stack)
+    if (NULL != Thread->Stack)
     {
         // This is the kernel mode stack
         // It does not 'belong' to any process => pass NULL
-        MmuFreeStack(pThread->Stack, NULL);
-        pThread->Stack = NULL;
+        MmuFreeStack(Thread->Stack, NULL);
+        Thread->Stack = NULL;
     }
 
-    ExFreePoolWithTag(pThread, HEAP_THREAD_TAG);
+    ExFreePoolWithTag(Thread, HEAP_THREAD_TAG);
 }
 
 static
diff --git a/src/HAL9000/src/um_application.c b/src/HAL9000/src/um_application.c
index 13dfa61..7cb0702 100644
--- a/src/HAL9000/src/um_application.c
+++ b/src/HAL9000/src/um_application.c
@@ -57,7 +57,7 @@ UmApplicationRetrieveHeader(
                                                       &peSize);
         if (!SUCCEEDED(status))
         {
-            LOG_TRACE_USERMODE("[ERROR]_UmApplicationReadExecutableContents failed with status 0x%x", status);
+            LOG_FUNC_ERROR("_UmApplicationReadExecutableContents", status);
             __leave;
         }
 
@@ -195,7 +195,7 @@ _UmApplicationReadExecutableContents(
                               FALSE);
         if (!SUCCEEDED(status))
         {
-            LOG_TRACE_USERMODE("[ERROR] IoCreateFile with status 0x%x\n", status);
+            LOG_FUNC_ERROR("IoCreateFile", status);
             __leave;
         }
 
diff --git a/src/HAL9000/src/vm_reservation_space.c b/src/HAL9000/src/vm_reservation_space.c
index 88295c4..cb8b502 100644
--- a/src/HAL9000/src/vm_reservation_space.c
+++ b/src/HAL9000/src/vm_reservation_space.c
@@ -12,34 +12,19 @@ typedef enum _VMM_RESERVATION_STATE
     VmmReservationStateLast     = 0x2,
 } VMM_RESERVATION_STATE;
 
-// A reservation is allocated each time a process reserves an area of
-// virtual memory. The commit bitmap is used to distinguish between the
-// reserved memory and the committed memory.
 typedef struct _VMM_RESERVATION
 {
-    // Starting addresses of the virtual memory allocation
     PVOID                   StartVa;
-
-    // Size of the allocation
     QWORD                   Size;
 
-    // The rights with which the memory was allocated
     PAGE_RIGHTS             PageRights;
-
-    // The state of the this structure, this is used for finding the
-    // next free slot
     VMM_RESERVATION_STATE   State;
 
-    // If TRUE memory will be set as strong uncacheable (UC)
-    // If FALSE the memory will be set as write back (WB)
     BOOLEAN                 Uncacheable;
 
     // Used for memory backed up by files
-    // Indicates the file which holds the data
     PFILE_OBJECT            BackingFile;
 
-    // Describes which pages of the virtual memory reserved are actually
-    // committed, i.e. which are valid when a #PF occurs
     BITMAP                  CommitBitmap;
 } VMM_RESERVATION, *PVMM_RESERVATION;
 
diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
index a70a2cb..640e8d0 100644
--- a/src/HAL9000/src/vmm.c
+++ b/src/HAL9000/src/vmm.c
@@ -24,47 +24,6 @@ typedef struct _VMM_DATA
     BYTE                    UncacheableIndex;
 } VMM_DATA, *PVMM_DATA;
 
-typedef
-BOOLEAN
-(__cdecl FUNC_PageWalkCallback)(
-    IN      PML4                    Cr3,
-    IN      PVOID                   PageTable,
-    IN      PVOID                   VirtualAddress,
-    IN      BYTE                    PageLevel,
-    IN_OPT  PVOID                   Context
-    );
-
-typedef FUNC_PageWalkCallback *PFUNC_PageWalkCallback;
-
-typedef struct _VMM_MAP_UNMAP_PAGE_WALK_CONTEXT
-{
-    // These fields are valid only when mapping memory in _VmMapPage
-    PPAGING_DATA                    PagingData;
-    PHYSICAL_ADDRESS                PhysicalAddressBase;
-    PVOID                           VirtualAddressBase;
-
-    PAGE_RIGHTS                     PageRights;
-    BOOLEAN                         Invalidate;
-    BOOLEAN                         Uncacheable;
-
-    // Valid only when unmapping memory in _VmUnmapPage;
-    BOOLEAN                         ReleaseMemory;
-} VMM_MAP_UNMAP_PAGE_WALK_CONTEXT, *PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT;
-
-// Used when determining the physical address, a/d bits and when resetting them
-typedef struct _VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT
-{
-    PHYSICAL_ADDRESS                PhysicalAddress;
-
-    // Returns the values of the A/D bits
-    BOOLEAN                         Accessed;
-    BOOLEAN                         Dirty;
-
-    // When set clears the A/D bits
-    BOOLEAN                         ClearAccessed;
-    BOOLEAN                         ClearDirty;
-} VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT, *PVMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT;
-
 static VMM_DATA m_vmmData;
 
 static
@@ -83,20 +42,6 @@ _VmDeterminePatIndices(
     OUT     PBYTE                   UcIndex
     );
 
-static
-void
-_VmWalkPagingTables(
-    IN      PML4                        Cr3,
-    IN      PVOID                       BaseAddress,
-    IN      QWORD                       Size,
-    IN      PFUNC_PageWalkCallback      WalkCallback,
-    IN_OPT  PVOID                       Context
-    );
-
-static FUNC_PageWalkCallback            _VmMapPage;
-static FUNC_PageWalkCallback            _VmUnmapPage;
-static FUNC_PageWalkCallback            _VmRetrievePhyAccess;
-
 __forceinline
 static
 PHYSICAL_ADDRESS
@@ -254,27 +199,94 @@ VmmMapMemoryInternal(
     IN      BOOLEAN                 Uncacheable
     )
 {
-    VMM_MAP_UNMAP_PAGE_WALK_CONTEXT ctx = { 0 };
-    PML4 cr3;
+    PML4_ENTRY* pml4Entries;
+    PDPT_ENTRY_PD* pdptEntries;
+    PD_ENTRY_PT* pdEntries;
+    PT_ENTRY* ptEntries;
+
+    WORD pageOffset;
+    WORD pteOffset;
+    WORD pdeOffset;
+    WORD pdpteOffset;
+    WORD pml4Offset;
+
+    QWORD offset;
+    PVOID tempAddress;
 
     ASSERT(PagingData != NULL);
     ASSERT(IsAddressAligned(PhysicalAddress, PAGE_SIZE));
     ASSERT(0 != Size && IsAddressAligned(Size, PAGE_SIZE));
 
-    ctx.PagingData = PagingData;
-    ctx.PhysicalAddressBase = PhysicalAddress;
-    ctx.VirtualAddressBase = BaseAddress;
-    ctx.PageRights = PageRights;
-    ctx.Invalidate = Invalidate;
-    ctx.Uncacheable = Uncacheable;
+    // we may need to map multiple pages => we iterate until we map all the
+    // addresses
+    for(offset = 0;
+        offset < Size;
+        offset = offset + PAGE_SIZE)
+    {
+        // address to map
+        tempAddress = (PBYTE)BaseAddress + offset;
+
+        // these are the offsets to the corresponding structures
+        pml4Offset = MASK_PML4_OFFSET(tempAddress);
+        pdpteOffset = MASK_PDPTE_OFFSET(tempAddress);
+        pdeOffset = MASK_PDE_OFFSET(tempAddress);
+        pteOffset = MASK_PTE_OFFSET(tempAddress);
+        pageOffset = MASK_PAGE_OFFSET(tempAddress);
+
+        pml4Entries = (PML4_ENTRY*)PA2VA(PagingData->BasePhysicalAddress);
+        pml4Entries = &(pml4Entries[pml4Offset]);
+
+        if (!PteIsPresent(pml4Entries))
+        {
+            _VmSetupPagingStructure(PagingData, pml4Entries);
+        }
+
+        tempAddress = PteGetPhysicalAddress(pml4Entries);
+        pdptEntries = (PDPT_ENTRY_PD*)PA2VA(tempAddress);
 
-    cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
+        pdptEntries = &(pdptEntries[pdpteOffset]);
 
-    _VmWalkPagingTables(cr3,
-                        BaseAddress,
-                        Size,
-                        _VmMapPage,
-                        &ctx);
+        if (!PteIsPresent(pdptEntries))
+        {
+            _VmSetupPagingStructure(PagingData, pdptEntries);
+        }
+
+        ASSERT(0 == pdptEntries->PageSize);
+
+        tempAddress = PteGetPhysicalAddress(pdptEntries);
+        pdEntries = (PD_ENTRY_PT*)PA2VA(tempAddress);
+
+        pdEntries = &(pdEntries[pdeOffset]);
+        if (!PteIsPresent(pdEntries))
+        {
+            _VmSetupPagingStructure(PagingData, pdEntries);
+        }
+
+        ASSERT(0 == pdEntries->PageSize);
+
+        tempAddress = PteGetPhysicalAddress(pdEntries);
+        ptEntries = (PT_ENTRY*)PA2VA(tempAddress);
+
+
+        ptEntries = &(ptEntries[pteOffset]);
+
+        // if we must invalidate the entry or the entry is not present, map it
+        if (Invalidate || (!PteIsPresent(ptEntries)))
+        {
+            PHYSICAL_ADDRESS physAddr = (PHYSICAL_ADDRESS)((PBYTE)PhysicalAddress + offset);
+            PTE_MAP_FLAGS flags = { 0 };
+
+            flags.Executable = IsBooleanFlagOn(PageRights, PAGE_RIGHTS_EXECUTE);
+            flags.Writable = IsBooleanFlagOn(PageRights, PAGE_RIGHTS_WRITE);
+            flags.PatIndex = Uncacheable ? m_vmmData.UncacheableIndex : m_vmmData.WriteBackIndex;
+            flags.GlobalPage = PagingData->KernelSpace;
+            flags.UserAccess = !PagingData->KernelSpace;
+
+            PteMap(ptEntries, physAddr, flags );
+
+            __invlpg((PBYTE) BaseAddress + offset );
+        }
+    }
 }
 
 void
@@ -285,7 +297,19 @@ VmmUnmapMemoryEx(
     IN      BOOLEAN                 ReleaseMemory
     )
 {
-    VMM_MAP_UNMAP_PAGE_WALK_CONTEXT ctx = { 0 };
+    PML4_ENTRY* pml4Entries;
+    PDPT_ENTRY_PD* pdptEntries;
+    PD_ENTRY_PT* pdEntries;
+    PT_ENTRY* ptEntries;
+
+    WORD pageOffset;
+    WORD pteOffset;
+    WORD pdeOffset;
+    WORD pdpteOffset;
+    WORD pml4Offset;
+
+    QWORD offset;
+    PVOID tempAddress;
 
     if ((NULL == VirtualAddress) || (!IsAddressAligned(VirtualAddress, PAGE_SIZE)))
     {
@@ -297,50 +321,175 @@ VmmUnmapMemoryEx(
         return;
     }
 
-    ctx.ReleaseMemory = ReleaseMemory;
+    offset = 0;
+
+    // we may need to map multiple pages => we iterate until we map all the
+    // addresses
+    for(offset = 0;
+        offset < Size;
+        offset = offset + PAGE_SIZE)
+    {
+        // address to ummap
+        tempAddress = (PVOID)((BYTE*)VirtualAddress + offset);
+
+        // these are the offsets to the corresponding structures
+        pml4Offset = MASK_PML4_OFFSET(tempAddress);
+        pdpteOffset = MASK_PDPTE_OFFSET(tempAddress);
+        pdeOffset = MASK_PDE_OFFSET(tempAddress);
+        pteOffset = MASK_PTE_OFFSET(tempAddress);
+        pageOffset = MASK_PAGE_OFFSET(tempAddress);
+
+        pml4Entries = (PML4_ENTRY*)PA2VA(Cr3.Pcide.PhysicalAddress << SHIFT_FOR_PHYSICAL_ADDR);
+        pml4Entries = &(pml4Entries[pml4Offset]);
+
+        if (!PteIsPresent(pml4Entries))
+        {
+            // it was never allocated
+            // go to next PAGE
+            continue;
+        }
+
+        tempAddress = PteGetPhysicalAddress(pml4Entries);
+        pdptEntries = (PDPT_ENTRY_PD*)PA2VA(tempAddress);
+
+        pdptEntries = &(pdptEntries[pdpteOffset]);
 
-    _VmWalkPagingTables(Cr3,
-                        VirtualAddress,
-                        Size,
-                        _VmUnmapPage,
-                        &ctx);
+        if (!PteIsPresent(pdptEntries))
+        {
+            // it was never allocated
+            // go to next PAGE
+            continue;
+        }
+
+        ASSERT(0 == pdptEntries->PageSize);
+
+        tempAddress = PteGetPhysicalAddress(pdptEntries);
+        pdEntries = (PD_ENTRY_PT*)PA2VA(tempAddress);
+
+        pdEntries = &(pdEntries[pdeOffset]);
+        if (!PteIsPresent(pdEntries))
+        {
+            // it was never allocated
+            // go to next PAGE
+            continue;
+        }
+
+        ASSERT(0 == pdEntries->PageSize);
+
+        tempAddress = PteGetPhysicalAddress(pdEntries);
+        ptEntries = (PT_ENTRY*)PA2VA(tempAddress);
+
+
+        ptEntries = &(ptEntries[pteOffset]);
+
+        if (!PteIsPresent(ptEntries))
+        {
+            // it was never allocated
+            // go to next PAGE
+            continue;
+        }
+        else
+        {
+            PHYSICAL_ADDRESS pa = PteGetPhysicalAddress(ptEntries);
+
+            PteUnmap(ptEntries);
+
+            __invlpg((QWORD)VirtualAddress + offset);
+
+            if (ReleaseMemory)
+            {
+                MmuReleaseMemory(pa, 1);
+            }
+
+            /// TODO: signal other processors to invalidate the mapping
+        }
+    }
 }
 
 PTR_SUCCESS
 PHYSICAL_ADDRESS
-VmmGetPhysicalAddressEx(
+VmmGetPhysicalAddress(
     IN      PML4                    Cr3,
-    IN      PVOID                   VirtualAddress,
-    OUT_OPT BOOLEAN*                Accessed,
-    OUT_OPT BOOLEAN*                Dirty
+    IN      PVOID                   VirtualAddress
     )
 {
-    VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT ctx = { 0 };
+    PML4_ENTRY* pml4Entries;
+    PDPT_ENTRY_PD* pdptEntries;
+    PD_ENTRY_PT* pdEntries;
+    PT_ENTRY* ptEntries;
+
+    WORD pageOffset;
+    WORD pteOffset;
+    WORD pdeOffset;
+    WORD pdpteOffset;
+    WORD pml4Offset;
+
+    PVOID tempAddress;
+
+    ASSERT( NULL != VirtualAddress );
+    ASSERT( IsAddressAligned(VirtualAddress, PAGE_SIZE));
 
-    ASSERT(NULL != VirtualAddress);
-    ASSERT(IsAddressAligned(VirtualAddress, PAGE_SIZE));
+    tempAddress = VirtualAddress;
 
-    ctx.ClearAccessed = Accessed != NULL;
-    ctx.ClearDirty = Dirty != NULL;
+    // these are the offsets to the corresponding structures
+    pml4Offset = MASK_PML4_OFFSET(tempAddress);
+    pdpteOffset = MASK_PDPTE_OFFSET(tempAddress);
+    pdeOffset = MASK_PDE_OFFSET(tempAddress);
+    pteOffset = MASK_PTE_OFFSET(tempAddress);
+    pageOffset = MASK_PAGE_OFFSET(tempAddress);
 
-    _VmWalkPagingTables(Cr3,
-                        VirtualAddress,
-                        PAGE_SIZE,
-                        _VmRetrievePhyAccess,
-                        &ctx
-                        );
+    pml4Entries = (PML4_ENTRY*)PA2VA(Cr3.Pcide.PhysicalAddress << SHIFT_FOR_PHYSICAL_ADDR);
+    pml4Entries = &(pml4Entries[pml4Offset]);
 
-    if (Accessed != NULL)
+    if (!PteIsPresent(pml4Entries))
     {
-        *Accessed = ctx.Accessed;
+        // it was never allocated
+        return NULL;
+    }
+
+    tempAddress = PteGetPhysicalAddress(pml4Entries);
+    pdptEntries = (PDPT_ENTRY_PD*)PA2VA(tempAddress);
+
+    pdptEntries = &(pdptEntries[pdpteOffset]);
+
+    if (!PteIsPresent(pdptEntries))
+    {
+        // it was never allocated
+        return NULL;
+    }
+
+    ASSERT(0 == pdptEntries->PageSize);
+
+    tempAddress = PteGetPhysicalAddress(pdptEntries);
+    pdEntries = (PD_ENTRY_PT*)PA2VA(tempAddress);
+
+    pdEntries = &(pdEntries[pdeOffset]);
+    if (!PteIsPresent(pdEntries))
+    {
+        // it was never allocated
+        return NULL;
+    }
+
+    if (pdEntries->PageSize)
+    {
+        // Large 2MB page
+        return PtrOffset(PteLargePageGetPhysicalAddress(pdEntries),AddressOffset(VirtualAddress, PAGE_2MB_OFFSET + 1));
     }
 
-    if (Dirty != NULL)
+    tempAddress = PteGetPhysicalAddress(pdEntries);
+    ptEntries = (PT_ENTRY*)PA2VA(tempAddress);
+
+
+    ptEntries = &(ptEntries[pteOffset]);
+
+    if (!PteIsPresent(ptEntries))
     {
-        *Dirty = ctx.Dirty;
+        // it was never allocated
+        // go to next PAGE
+        return NULL;
     }
 
-    return ctx.PhysicalAddress;
+    return PteGetPhysicalAddress(ptEntries);
 }
 
 _No_competing_thread_
@@ -382,6 +531,7 @@ VmmSetupPageTables(
     IN      BOOLEAN                 KernelStructures
     )
 {
+    STATUS status;
     DWORD sizeReservedForPagingStructures;
     PVOID pBaseVirtualAddress;
 
@@ -390,17 +540,18 @@ VmmSetupPageTables(
     ASSERT(BasePhysicalAddress != NULL);
     ASSERT(FramesReserved != 0);
 
+    status = STATUS_SUCCESS;
+    sizeReservedForPagingStructures = 0;
     pBaseVirtualAddress = (PVOID) PA2VA(BasePhysicalAddress);
 
-    ASSERT(FramesReserved <= MAX_DWORD / PAGE_SIZE);
-    sizeReservedForPagingStructures = FramesReserved * PAGE_SIZE;
-
     // Current index should start at 1 because at 0 we have the CR3 (PML4 table address)
     PagingData->CurrentIndex = 1;
     PagingData->NumberOfFrames = FramesReserved;
     PagingData->BasePhysicalAddress = BasePhysicalAddress;
     PagingData->KernelSpace = KernelStructures;
 
+    sizeReservedForPagingStructures = FramesReserved * PAGE_SIZE;
+
     LOG_TRACE_VMM("Will setup paging tables at physical address: 0x%X\n", PagingData->BasePhysicalAddress);
     LOG_TRACE_VMM("BaseAddress: 0x%X\n", pBaseVirtualAddress);
     LOG_TRACE_VMM("Size of paging tables: 0x%x\n", sizeReservedForPagingStructures);
@@ -429,7 +580,7 @@ VmmSetupPageTables(
         memzero(pBaseVirtualAddress, PAGE_SIZE);
     }
 
-    return STATUS_SUCCESS;
+    return status;
 }
 
 void
@@ -537,9 +688,6 @@ VmmAllocRegionEx(
     // we don't have an implementation for allocating a VA lazily for memory ranges described by a MDL
     ASSERT(Mdl == NULL || IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_NOT_LAZY));
 
-    // We currently do not support mapping zero pages
-    ASSERT(!IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_ZERO));
-
     // We cannot have both the Mdl and the FileObject non-NULL, the region either is already backed up by some physical
     // frames or it is backed up by a file, or it is not backed up by anything
     ASSERT((Mdl == NULL) || (FileObject == NULL));
@@ -997,7 +1145,7 @@ VmmIsBufferValid(
     if (!KernelAccess && _VmIsKernelRange(Buffer, BufferSize))
     {
         // We shouldn't be accessing from UM kernel buffers :)
-        LOG_TRACE_VMM("Usermode code should not be accessing kernel memory between 0x%X -> 0x%X\n",
+        LOG_ERROR("Usermode code should not be accessing kernel memory between 0x%X -> 0x%X\n",
                   BufferSize, PtrOffset(BufferSize, BufferSize - 1));
         return STATUS_MEMORY_PREVENTS_USERMODE_ACCESS;
     }
@@ -1045,7 +1193,7 @@ _VmSetupPagingStructure(
     // for paging structure PA2VA can always be used :)
     PteMap(PagingStructure, physicalAddr, flags);
 
-    PageInvalidateTlb((PVOID)PA2VA(physicalAddr));
+    __invlpg((PVOID)PA2VA(physicalAddr));
 
     // Zero the current paging structure entry => we cannot get stray memory accesses
     memzero((PVOID)PA2VA(physicalAddr), PAGE_SIZE);
@@ -1091,283 +1239,4 @@ _VmDeterminePatIndices(
     }
 
     return bFoundWb && bFoundUc;
-}
-
-static
-void
-_VmWalkPagingTables(
-    IN      PML4                        Cr3,
-    IN      PVOID                       BaseAddress,
-    IN      QWORD                       Size,
-    IN      PFUNC_PageWalkCallback      WalkCallback,
-    IN_OPT  PVOID                       Context
-    )
-{
-    // we may need to map multiple pages => we iterate until we map all the
-    // addresses
-    for(QWORD offset = 0;
-        offset < Size;
-        offset = offset + PAGE_SIZE)
-    {
-        WORD offsets[4];
-        BOOLEAN bContinue;
-        PVOID currentVa;
-        PHYSICAL_ADDRESS curStructPa;
-
-        // address to map
-        currentVa = PtrOffset(BaseAddress, offset);
-
-        offsets[0] = MASK_PML4_OFFSET(currentVa);
-        offsets[1] = MASK_PDPTE_OFFSET(currentVa);
-        offsets[2] = MASK_PDE_OFFSET(currentVa);
-        offsets[3] = MASK_PTE_OFFSET(currentVa);
-
-        bContinue = FALSE;
-
-        curStructPa = (PHYSICAL_ADDRESS)(Cr3.Pcide.PhysicalAddress << SHIFT_FOR_PHYSICAL_ADDR);
-
-        for (BYTE i = PAGING_TABLES_FIRST_LEVEL;
-             i <= PAGING_TABLES_LAST_LEVEL;
-             ++i)
-        {
-            PT_ENTRY* pCurrentEntry;
-
-            pCurrentEntry = (PT_ENTRY*)PA2VA(curStructPa);
-
-            pCurrentEntry = &(pCurrentEntry[offsets[i-1]]);
-
-            if (!WalkCallback(Cr3,
-                              pCurrentEntry,
-                              currentVa,
-                              i,
-                              Context))
-            {
-                bContinue = TRUE;
-                break;
-            }
-
-            if (i != PAGING_TABLES_LAST_LEVEL)
-            {
-                ASSERT(((PD_ENTRY_PT*)pCurrentEntry)->PageSize == 0);
-            }
-
-            curStructPa = PteGetPhysicalAddress(pCurrentEntry);
-        }
-
-        if (bContinue)
-        {
-            continue;
-        }
-    }
-}
-
-static
-BOOLEAN
-(__cdecl _VmMapPage)(
-    IN      PML4                    Cr3,
-    IN      PVOID                   PageTable,
-    IN      PVOID                   VirtualAddress,
-    IN      BYTE                    PageLevel,
-    IN_OPT  PVOID                   Context
-    )
-{
-    PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT pPageContext;
-
-    UNREFERENCED_PARAMETER(Cr3);
-
-    ASSERT(PageTable != NULL);
-    ASSERT(VirtualAddress != NULL);
-    ASSERT(PAGING_TABLES_FIRST_LEVEL <= PageLevel && PageLevel <= PAGING_TABLES_LAST_LEVEL);
-
-    pPageContext = (PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT) Context;
-    ASSERT(pPageContext != NULL);
-
-    if (PteIsPresent(PageTable) &&
-        !((PageLevel == PAGING_TABLES_LAST_LEVEL) && pPageContext->Invalidate))
-    {
-        return TRUE;
-    }
-
-    if (PageLevel == PAGING_TABLES_LAST_LEVEL)
-    {
-        PHYSICAL_ADDRESS physAddr = (PHYSICAL_ADDRESS)(PtrOffset(pPageContext->PhysicalAddressBase,
-                                                       PtrDiff(VirtualAddress, pPageContext->VirtualAddressBase)));
-        PTE_MAP_FLAGS flags = { 0 };
-
-        flags.Executable = IsBooleanFlagOn(pPageContext->PageRights, PAGE_RIGHTS_EXECUTE);
-        flags.Writable = IsBooleanFlagOn(pPageContext->PageRights, PAGE_RIGHTS_WRITE);
-        flags.PatIndex = pPageContext->Uncacheable ? m_vmmData.UncacheableIndex : m_vmmData.WriteBackIndex;
-        flags.GlobalPage = pPageContext->PagingData->KernelSpace;
-        flags.UserAccess = !pPageContext->PagingData->KernelSpace;
-
-        PteMap(PageTable, physAddr, flags);
-
-        PageInvalidateTlb(VirtualAddress);
-
-        /// TODO: signal other processors to invalidate the mapping
-    }
-    else
-    {
-        // paging structure
-        _VmSetupPagingStructure(pPageContext->PagingData, PageTable);
-    }
-
-    // continue iteration
-    return TRUE;
-}
-
-static
-BOOLEAN
-(__cdecl _VmUnmapPage)(
-    IN      PML4                    Cr3,
-    IN      PVOID                   PageTable,
-    IN      PVOID                   VirtualAddress,
-    IN      BYTE                    PageLevel,
-    IN_OPT  PVOID                   Context
-    )
-{
-    PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT pPageContext;
-
-    UNREFERENCED_PARAMETER(Cr3);
-
-    ASSERT(PageTable != NULL);
-    ASSERT(VirtualAddress != NULL);
-    ASSERT(PAGING_TABLES_FIRST_LEVEL <= PageLevel && PageLevel <= PAGING_TABLES_LAST_LEVEL);
-
-    pPageContext = (PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT) Context;
-    ASSERT(pPageContext != NULL);
-
-    if (!PteIsPresent(PageTable))
-    {
-        return FALSE;
-    }
-
-    if (PageLevel == PAGING_TABLES_LAST_LEVEL)
-    {
-        PHYSICAL_ADDRESS pa = PteGetPhysicalAddress(PageTable);
-
-        PteUnmap(PageTable);
-
-        PageInvalidateTlb(VirtualAddress);
-
-        if (pPageContext->ReleaseMemory)
-        {
-            MmuReleaseMemory(pa, 1);
-        }
-
-        /// TODO: signal other processors to invalidate the mapping
-    }
-
-    // continue iteration
-    return TRUE;
-}
-
-static
-BOOLEAN
-(__cdecl _VmRetrievePhyAccess)(
-    IN      PML4                    Cr3,
-    IN      PVOID                   PageTable,
-    IN      PVOID                   VirtualAddress,
-    IN      BYTE                    PageLevel,
-    IN_OPT  PVOID                   Context
-    )
-{
-    PVMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT pPageContext;
-    BOOLEAN bContinue;
-
-    UNREFERENCED_PARAMETER(Cr3);
-
-    ASSERT(PageTable != NULL);
-    ASSERT(VirtualAddress != NULL);
-    ASSERT(PAGING_TABLES_FIRST_LEVEL <= PageLevel && PageLevel <= PAGING_TABLES_LAST_LEVEL);
-
-    pPageContext = (PVMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT) Context;
-    ASSERT(pPageContext != NULL);
-
-    bContinue = TRUE;
-
-    if (!PteIsPresent(PageTable))
-    {
-        pPageContext->PhysicalAddress = NULL;
-        return FALSE;
-    }
-
-    if (PageLevel < PAGING_TABLES_LAST_LEVEL - 1)
-    {
-        return TRUE;
-    }
-
-    __try
-    {
-        if (PageLevel == PAGING_TABLES_LAST_LEVEL - 1)
-        {
-            PD_ENTRY_2MB* pPdEntry = (PD_ENTRY_2MB*) PageTable;
-
-            if (pPdEntry->PageSize == 1)
-            {
-                pPageContext->PhysicalAddress = PtrOffset(PteLargePageGetPhysicalAddress(PageTable),
-                                                          AddressOffset(VirtualAddress, PAGE_2MB_OFFSET + 1));
-
-                bContinue = FALSE;
-                __leave;
-            }
-        }
-        else
-        {
-            ASSERT(PageLevel == PAGING_TABLES_LAST_LEVEL);
-
-            pPageContext->PhysicalAddress = PteGetPhysicalAddress(PageTable);
-            bContinue = FALSE;
-            __leave;
-        }
-    }
-    __finally
-    {
-        if (!bContinue)
-        {
-            BOOLEAN bInvalidatePage = FALSE;
-            PT_ENTRY* pPtEntry = (PT_ENTRY*)PageTable;
-
-            pPageContext->Accessed = (BOOLEAN) pPtEntry->Accessed;
-            pPageContext->Dirty = (BOOLEAN) pPtEntry->Dirty;
-
-            if (pPageContext->ClearAccessed)
-            {
-                pPtEntry->Accessed = FALSE;
-                bInvalidatePage = TRUE;
-            }
-
-            if (pPageContext->ClearDirty)
-            {
-                pPtEntry->Dirty = FALSE;
-                bInvalidatePage = TRUE;
-            }
-
-            if (bInvalidatePage)
-            {
-                // 4.10.4.2 Recommended Invalidation
-                // If software modifies a paging - structure entry that maps a page(rather than referencing
-                // another paging structure), it should execute INVLPG for any linear address with a page
-                // number whose translation uses that paging - structure entry.
-
-                // 4.10.4.3 Optional Invalidation
-                // If a paging - structure entry is modified to change the accessed flag from 1 to 0, failure
-                // to perform an invalidation may result in the processor not setting that bit in response to
-                // a subsequent access to a linear address whose translation uses the entry.Software cannot
-                // interpret the bit being clear as an indication that such an access has not occurred.
-
-                // If software modifies a paging - structure entry that identifies the final physical address
-                // for a linear address (either a PTE or a paging - structure entry in which the PS flag is 1)
-                // to change the dirty flag from 1 to 0, failure to perform an invalidation may result in the
-                // processor not setting that bit in response to a subsequent write to a linear address whose
-                // translation uses the entry.Software cannot interpret the bit being clear as an indication
-                // that such a write has not occurred.
-                PageInvalidateTlb(VirtualAddress);
-
-                /// TODO: signal other processors to invalidate the mapping
-            }
-        }
-    }
-
-    return bContinue;
 }
\ No newline at end of file
diff --git a/src/HAL9000_WithoutApplications.sln b/src/HAL9000_WithoutApplications.sln
index 96e0607..bc3140a 100644
--- a/src/HAL9000_WithoutApplications.sln
+++ b/src/HAL9000_WithoutApplications.sln
@@ -1,7 +1,7 @@
 
 Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.0.30517.126
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL9000", "HAL9000\HAL9000.vcxproj", "{79A21DCA-19AF-4F8E-9B83-62D7CF504104}"
 	ProjectSection(ProjectDependencies) = postProject
@@ -9,7 +9,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL9000", "HAL9000\HAL9000.
 		{9412F640-A271-4661-B437-5932E9B95C26} = {9412F640-A271-4661-B437-5932E9B95C26}
 		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D} = {4DA7677D-D0E7-44EC-B350-F7170E0ED84D}
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A} = {E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E} = {0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1} = {02EC2CAD-C1E9-45FB-96AC-27976A9300F1}
@@ -57,91 +56,60 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RemoveAllTests", "Utils\Rem
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLib", "CommonLib\CommonLib.vcxproj", "{CA44C37A-1730-447F-8975-3DF40D559310}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapFS", "SwapFS\SwapFS.vcxproj", "{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLibUnitTests", "CommonLibUnitTests\CommonLibUnitTests.vcxproj", "{098EB03E-8151-46DB-9052-5136D9BC14EA}"
-	ProjectSection(ProjectDependencies) = postProject
-		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
-	EndProjectSection
-EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		CommonLibTests|x64 = CommonLibTests|x64
 		Threads|x64 = Threads|x64
 		Userprog|x64 = Userprog|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.ActiveCfg = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.Build.0 = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.ActiveCfg = Debug|x64
 		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.Build.0 = Debug|x64
-		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.ActiveCfg = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.Build.0 = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.ActiveCfg = Debug|x64
 		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.Build.0 = Debug|x64
-		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.ActiveCfg = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.Build.0 = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.ActiveCfg = Debug|x64
 		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.Build.0 = Debug|x64
-		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.ActiveCfg = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.Build.0 = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.ActiveCfg = Debug|x64
 		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.Build.0 = Debug|x64
-		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.ActiveCfg = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.Build.0 = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.ActiveCfg = Debug|x64
 		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.Build.0 = Debug|x64
-		{9412F640-A271-4661-B437-5932E9B95C26}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.ActiveCfg = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.Build.0 = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.ActiveCfg = Debug|x64
 		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.Build.0 = Debug|x64
-		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.ActiveCfg = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.Build.0 = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.ActiveCfg = Debug|x64
 		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.Build.0 = Debug|x64
-		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.ActiveCfg = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.Build.0 = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.ActiveCfg = Debug|x64
 		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.Build.0 = Debug|x64
-		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.ActiveCfg = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.Build.0 = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.ActiveCfg = Debug|x64
 		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.Build.0 = Debug|x64
-		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.ActiveCfg = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.Build.0 = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.ActiveCfg = Debug|x64
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.Build.0 = Debug|x64
-		{291C9D17-6BA7-404F-8664-C60F38E061C7}.CommonLibTests|x64.ActiveCfg = Userprog|x64
 		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Threads|x64.ActiveCfg = Threads|x64
 		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Userprog|x64.ActiveCfg = Userprog|x64
-		{6CAFB378-993C-4078-B545-9D8636F383DC}.CommonLibTests|x64.ActiveCfg = Debug|x64
 		{6CAFB378-993C-4078-B545-9D8636F383DC}.Threads|x64.ActiveCfg = Debug|x64
 		{6CAFB378-993C-4078-B545-9D8636F383DC}.Userprog|x64.ActiveCfg = Debug|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.ActiveCfg = DebugNonNative|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.Build.0 = DebugNonNative|x64
 		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.ActiveCfg = Debug|x64
 		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.Build.0 = Debug|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.ActiveCfg = DebugNoLocks|x64
-		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.Build.0 = DebugNoLocks|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.ActiveCfg = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.Build.0 = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.ActiveCfg = Debug|x64
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.Build.0 = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.ActiveCfg = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.Build.0 = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Threads|x64.ActiveCfg = Debug|x64
-		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Userprog|x64.ActiveCfg = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.ActiveCfg = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.Build.0 = Debug|x64
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -157,6 +125,5 @@ Global
 		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1} = {9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}
 		{291C9D17-6BA7-404F-8664-C60F38E061C7} = {2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}
 		{6CAFB378-993C-4078-B545-9D8636F383DC} = {2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}
-		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}
 	EndGlobalSection
 EndGlobal
diff --git a/src/NetworkPort/NetworkPort.vcxproj b/src/NetworkPort/NetworkPort.vcxproj
index 4fe8eb4..b3ceca2 100644
--- a/src/NetworkPort/NetworkPort.vcxproj
+++ b/src/NetworkPort/NetworkPort.vcxproj
@@ -23,9 +23,10 @@
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -36,7 +37,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -47,13 +48,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
@@ -67,7 +61,7 @@
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <OmitFramePointers>true</OmitFramePointers>
       <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -85,36 +79,16 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
+      <WarningLevel>Level3</WarningLevel>
       <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
       <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
     </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="src\network_dispatch.c" />
diff --git a/src/NetworkPort/headers/network_structures.h b/src/NetworkPort/headers/network_structures.h
index e7c784d..c136b82 100644
--- a/src/NetworkPort/headers/network_structures.h
+++ b/src/NetworkPort/headers/network_structures.h
@@ -3,8 +3,6 @@
 #include "lock_common.h"
 #include "ex_event.h"
 
-#pragma warning(push)
-
 // warning C4200: nonstandard extension used: zero-sized array in struct/union
 #pragma warning(disable: 4200)
 typedef struct _NETWORK_PORT_DRIVER_DATA
@@ -66,7 +64,7 @@ typedef struct _FRAME_DESCRIPTOR_ENTRY
 STATIC_ASSERT_INFO(sizeof(FRAME_DESCRIPTOR_ENTRY) - sizeof(FRAME_DESCRIPTOR) == FIELD_OFFSET(FRAME_DESCRIPTOR_ENTRY, Frame),
                    "Frame must always be the last element in the structure");
 
-#pragma warning(pop)
+#pragma warning(default:4200)
 
 void
 NetworkPortDevicePreinit(
@@ -98,5 +96,5 @@ NetworkPortAllocateFrameDescriptor(
 
 void
 NetworkPortFreeFrameDescriptor(
-    IN          PFRAME_DESCRIPTOR_ENTRY Descriptor
+    IN          PFRAME_DESCRIPTOR_ENTRY Descriptor                
     );
\ No newline at end of file
diff --git a/src/NetworkPort/src/network_dispatch.c b/src/NetworkPort/src/network_dispatch.c
index 4b171cb..62c3c75 100644
--- a/src/NetworkPort/src/network_dispatch.c
+++ b/src/NetworkPort/src/network_dispatch.c
@@ -26,6 +26,7 @@ _NetDispatchChangeDeviceStatus(
     IN                                      PNET_GET_SET_DEVICE_STATUS  DeviceStatus
     );
 
+SAL_SUCCESS
 STATUS
 NetPortDeviceControl(
     INOUT       PDEVICE_OBJECT          DeviceObject,
diff --git a/src/NetworkPort/src/network_port.c b/src/NetworkPort/src/network_port.c
index a559a87..de96b79 100644
--- a/src/NetworkPort/src/network_port.c
+++ b/src/NetworkPort/src/network_port.c
@@ -60,7 +60,7 @@ static
 STATUS
 _NetworkPortInitializeMiniportBuffers(
     IN      PMINIPORT_BUFFER_DESCRIPTION                    BufferDescription,
-    OUT_WRITES_ALL(BufferDescription->NumberOfBuffers)
+    OUT_WRITES_ALL(BufferDescription->NumberOfBuffers)      
             PHYSICAL_ADDRESS*                               PhysicalAddresses,
     OUT_PTR PVOID**                                         BufferArray,
     OUT_PTR PVOID*                                          DescriptorArray
@@ -374,7 +374,7 @@ _NetworkPortConfigureDevice(
 
         initialization.TxBuffers.NumberOfBuffers = MiniportRegistration->TxBuffers.NumberOfBuffers;
         initialization.TxBuffers.Buffers = TxPhysicalAddresses;
-        initialization.TxBuffers.BufferSize = MiniportRegistration->TxBuffers.BufferSize;
+        initialization.TxBuffers.BufferSize = MiniportRegistration->RxBuffers.BufferSize;
 
         // initialize miniport device
         status = MiniportRegistration->MiniportFunctions.MiniportInitializeDevice(pMiniportDevice,
@@ -483,7 +483,7 @@ static
 STATUS
 _NetworkPortInitializeMiniportBuffers(
     IN      PMINIPORT_BUFFER_DESCRIPTION                    BufferDescription,
-    OUT_WRITES_ALL(BufferDescription->NumberOfBuffers)
+    OUT_WRITES_ALL(BufferDescription->NumberOfBuffers)      
             PHYSICAL_ADDRESS*                               PhysicalAddresses,
     OUT_PTR PVOID**                                         BufferArray,
     OUT_PTR PVOID*                                          DescriptorArray
@@ -545,17 +545,17 @@ _NetworkPortInitializeMiniportBuffers(
                 descriptorArray = NULL;
             }
 
-            if (NULL != bufferArray)
+            for (i = 0; i < BufferDescription->NumberOfBuffers; ++i)
             {
-                for (i = 0; i < BufferDescription->NumberOfBuffers; ++i)
+                if (NULL != bufferArray[i])
                 {
-                    if (NULL != bufferArray[i])
-                    {
-                        IoFreeContinuousMemory(bufferArray[i]);
-                        bufferArray[i] = NULL;
-                    }
+                    IoFreeContinuousMemory(bufferArray[i]);
+                    bufferArray[i] = NULL;
                 }
+            }
 
+            if (NULL != bufferArray)
+            {
                 ExFreePoolWithTag(bufferArray, HEAP_PORT_TAG);
                 bufferArray = NULL;
             }
diff --git a/src/NetworkStack/NetworkStack.vcxproj b/src/NetworkStack/NetworkStack.vcxproj
index eff75ed..9f28c73 100644
--- a/src/NetworkStack/NetworkStack.vcxproj
+++ b/src/NetworkStack/NetworkStack.vcxproj
@@ -23,9 +23,10 @@
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -36,7 +37,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -47,13 +48,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
@@ -67,7 +61,7 @@
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <OmitFramePointers>true</OmitFramePointers>
       <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -85,36 +79,16 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
+      <WarningLevel>Level3</WarningLevel>
       <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
       <FunctionLevelLinking>true</FunctionLevelLinking>
       <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
     </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="src\network_device.c" />
diff --git a/src/PE_Parser/PE_Parser.vcxproj b/src/PE_Parser/PE_Parser.vcxproj
index 2a3037b..a914fb8 100644
--- a/src/PE_Parser/PE_Parser.vcxproj
+++ b/src/PE_Parser/PE_Parser.vcxproj
@@ -5,10 +5,6 @@
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}</ProjectGuid>
@@ -22,12 +18,6 @@
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
@@ -36,9 +26,6 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <TargetExt>.lib</TargetExt>
@@ -47,13 +34,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <TargetExt>.lib</TargetExt>
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
@@ -67,7 +47,7 @@
       <CompileAsManaged>false</CompileAsManaged>
       <OmitFramePointers>true</OmitFramePointers>
       <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -83,39 +63,6 @@
       <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc</AdditionalIncludeDirectories>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-    </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
-  </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="src\pe_parser.c" />
   </ItemGroup>
diff --git a/src/PE_Parser/inc/pe_parser.h b/src/PE_Parser/inc/pe_parser.h
index 15fdc91..1fae166 100644
--- a/src/PE_Parser/inc/pe_parser.h
+++ b/src/PE_Parser/inc/pe_parser.h
@@ -2,6 +2,7 @@
 
 #include "pe_exports.h"
 
+SAL_SUCCESS
 STATUS
 PeRetrieveNtHeader(
     IN_READS_BYTES(ImageSize)   PVOID                   ImageBase,
@@ -9,6 +10,7 @@ PeRetrieveNtHeader(
     OUT                         PPE_NT_HEADER_INFO      NtInfo
     );
 
+SAL_SUCCESS
 STATUS
 PeRetrieveSection(
     IN                          PPE_NT_HEADER_INFO      NtInfo,
@@ -16,6 +18,7 @@ PeRetrieveSection(
     OUT                         PPE_SECTION_INFO        SectionInfo
     );
 
+SAL_SUCCESS
 STATUS
 PeRetrieveDataDirectory(
     IN                          PPE_NT_HEADER_INFO      NtInfo,
diff --git a/src/PE_Parser/src/pe_parser.c b/src/PE_Parser/src/pe_parser.c
index b8d27f7..42ffe78 100644
--- a/src/PE_Parser/src/pe_parser.c
+++ b/src/PE_Parser/src/pe_parser.c
@@ -2,6 +2,7 @@
 #include "pe_parser.h"
 #include "pe_structures.h"
 
+SAL_SUCCESS
 STATUS
 PeRetrieveNtHeader(
     IN_READS_BYTES(ImageSize)           PVOID                   ImageBase,
@@ -65,6 +66,7 @@ PeRetrieveNtHeader(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 PeRetrieveSection(
     IN                          PPE_NT_HEADER_INFO      NtInfo,
@@ -117,6 +119,7 @@ PeRetrieveSection(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 PeRetrieveDataDirectory(
     IN                          PPE_NT_HEADER_INFO      NtInfo,
diff --git a/src/SwapFS/SwapFS.vcxproj b/src/SwapFS/SwapFS.vcxproj
index 0f9b7c8..c9e015b 100644
--- a/src/SwapFS/SwapFS.vcxproj
+++ b/src/SwapFS/SwapFS.vcxproj
@@ -14,19 +14,19 @@
     <ProjectGuid>{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>SwapFS</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/AppHelloWorld/AppHelloWorld.vcxproj b/src/Usermode/AppHelloWorld/AppHelloWorld.vcxproj
index 4392d8c..9d04673 100644
--- a/src/Usermode/AppHelloWorld/AppHelloWorld.vcxproj
+++ b/src/Usermode/AppHelloWorld/AppHelloWorld.vcxproj
@@ -24,8 +24,9 @@
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -36,7 +37,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -50,9 +51,6 @@
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
     <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <LinkIncremental>false</LinkIncremental>
-    <EmbedManifest>false</EmbedManifest>
-    <GenerateManifest>false</GenerateManifest>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
@@ -65,7 +63,7 @@
       <CompileAsManaged>false</CompileAsManaged>
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <OmitFramePointers>true</OmitFramePointers>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -107,26 +105,18 @@
       <TreatWarningAsError>true</TreatWarningAsError>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
       <CompileAsManaged>false</CompileAsManaged>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
+      <StringPooling>false</StringPooling>
       <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <BufferSecurityCheck />
       <ControlFlowGuard>false</ControlFlowGuard>
       <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
       <FloatingPointExceptions>false</FloatingPointExceptions>
       <RuntimeTypeInfo>true</RuntimeTypeInfo>
       <OpenMPSupport>false</OpenMPSupport>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
     </ClCompile>
     <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
       <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
       <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
       <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
@@ -134,12 +124,7 @@
       <NoEntryPoint>false</NoEntryPoint>
       <EntryPointSymbol>__start</EntryPointSymbol>
       <SubSystem>Native</SubSystem>
-      <ForceFileOutput>
-      </ForceFileOutput>
       <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
-      <BaseAddress>0x140000000</BaseAddress>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <FixedBaseAddress>true</FixedBaseAddress>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
diff --git a/src/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj b/src/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj
index 79461ca..02270cd 100644
--- a/src/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj
+++ b/src/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj
@@ -5,10 +5,6 @@
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}</ProjectGuid>
@@ -22,12 +18,6 @@
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Utility</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
@@ -36,18 +26,11 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\$(ProjectName)\</OutDir>
     <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level3</WarningLevel>
@@ -55,17 +38,7 @@
       <SDLCheck>true</SDLCheck>
     </ClCompile>
     <PostBuildEvent>
-      <Command>..\..\..\postbuild\copy_um_apps_to_vm.cmd $(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\ Applications</Command>
-    </PostBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <SDLCheck>true</SDLCheck>
-    </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\..\postbuild\copy_um_apps_to_vm.cmd $(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\ Applications</Command>
+      <Command>..\..\postbuild\copy_um_apps_to_vm.cmd $(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\ Applications</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
   <ItemGroup>
diff --git a/src/Usermode/FileReadBadPointer/main.c b/src/Usermode/FileReadBadPointer/main.c
index c5635a5..e775fef 100644
--- a/src/Usermode/FileReadBadPointer/main.c
+++ b/src/Usermode/FileReadBadPointer/main.c
@@ -25,11 +25,8 @@ __main(
         LOG_FUNC_ERROR("SyscallFileCreate", status);
     }
 
-     status = SyscallFileRead(handle, (PVOID) 0x14'0000'0000ULL, PAGE_SIZE, &bytesRead);
-     if (SUCCEEDED(status))
-     {
-         LOG_ERROR("SyscallFileRead should have failed!\n");
-     }
+     SyscallFileRead(handle, (PVOID) 0x140000000ULL, PAGE_SIZE, &bytesRead);
+     LOG_ERROR("The application should have crashed!!!\n");
 
     return STATUS_SUCCESS;
 }
\ No newline at end of file
diff --git a/src/Usermode/FileReadKernel/main.c b/src/Usermode/FileReadKernel/main.c
index 89aaac9..ce91fed 100644
--- a/src/Usermode/FileReadKernel/main.c
+++ b/src/Usermode/FileReadKernel/main.c
@@ -25,11 +25,8 @@ __main(
         LOG_FUNC_ERROR("SyscallFileCreate", status);
     }
 
-    status = SyscallFileRead(handle, (PVOID) 0xFFFF800000000000ULL, PAGE_SIZE, &bytesRead);
-    if (SUCCEEDED(status))
-    {
-        LOG_ERROR("SyscallFileRead should have failed!\n");
-    }
+    SyscallFileRead(handle, (PVOID) 0xFFFF800000000000ULL, PAGE_SIZE, &bytesRead);
+    LOG_ERROR("The application should have crashed!!!\n");
 
     return STATUS_SUCCESS;
 }
\ No newline at end of file
diff --git a/src/Usermode/FileReadNormal/main.c b/src/Usermode/FileReadNormal/main.c
index 32f2a8d..6221b8f 100644
--- a/src/Usermode/FileReadNormal/main.c
+++ b/src/Usermode/FileReadNormal/main.c
@@ -4,8 +4,6 @@
 
 #define EXPECTED_BUFFER "UserModeApplications:Applications"
 
-#define MIN_BUFFER_SIZE     0x200
-
 STATUS
 __main(
     DWORD       argc,
@@ -15,13 +13,13 @@ __main(
     STATUS status;
     UM_HANDLE handle;
     QWORD bytesRead;
-    BYTE bufferRead[MIN_BUFFER_SIZE];
+    BYTE bufferRead[sizeof(EXPECTED_BUFFER)];
 
     UNREFERENCED_PARAMETER(argc);
     UNREFERENCED_PARAMETER(argv);
 
     handle = UM_INVALID_HANDLE_VALUE;
-    bufferRead[MIN_BUFFER_SIZE - 1] = '\0';
+    bufferRead[sizeof(EXPECTED_BUFFER)-1] = '\0';
 
     __try
     {
@@ -38,7 +36,7 @@ __main(
 
         status = SyscallFileRead(handle,
                                  bufferRead,
-                                 MIN_BUFFER_SIZE,
+                                 sizeof(EXPECTED_BUFFER) - 1,
                                  &bytesRead);
         if (!SUCCEEDED(status))
         {
@@ -46,14 +44,14 @@ __main(
             __leave;
         }
 
-        if (bytesRead != MIN_BUFFER_SIZE)
+        if (bytesRead != sizeof(EXPECTED_BUFFER) - 1)
         {
             LOG_ERROR("We expected to read %U bytes, while we actually read %U!\n",
-                      MIN_BUFFER_SIZE, bytesRead);
+                      sizeof(EXPECTED_BUFFER) - 1, bytesRead);
             __leave;
         }
 
-        if (memcmp(bufferRead, EXPECTED_BUFFER, (DWORD) sizeof(EXPECTED_BUFFER) - 1) != 0)
+        if (memcmp(bufferRead, EXPECTED_BUFFER, (DWORD) bytesRead) != 0)
         {
             LOG_ERROR("Expected buffer is [%s], buffer read is [%s]\n",
                       EXPECTED_BUFFER, bufferRead);
diff --git a/src/Usermode/HAL9000_UserApplication.zip b/src/Usermode/HAL9000_UserApplication.zip
index 780c0ed..7331576 100644
Binary files a/src/Usermode/HAL9000_UserApplication.zip and b/src/Usermode/HAL9000_UserApplication.zip differ
diff --git a/src/Usermode/ProcessCloseNormal/main.c b/src/Usermode/ProcessCloseNormal/main.c
index cbffcb0..f5bc91b 100644
--- a/src/Usermode/ProcessCloseNormal/main.c
+++ b/src/Usermode/ProcessCloseNormal/main.c
@@ -25,14 +25,6 @@ __main(
     }
     else
     {
-        STATUS termStatus;
-
-        status = SyscallProcessWaitForTermination(hProcess, &termStatus);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
-        }
-
         status = SyscallProcessCloseHandle(hProcess);
         if (!SUCCEEDED(status))
         {
diff --git a/src/Usermode/ProcessCloseParentHandle/main.c b/src/Usermode/ProcessCloseParentHandle/main.c
index 924d9e8..72b2950 100644
--- a/src/Usermode/ProcessCloseParentHandle/main.c
+++ b/src/Usermode/ProcessCloseParentHandle/main.c
@@ -38,8 +38,9 @@ __main(
                 __leave;
             }
 
-            status = SyscallProcessCreate("Proces~3.exe",
-                                          sizeof("Proces~3.exe"),
+            /// TODO: this path
+            status = SyscallProcessCreate("dummy.exe",
+                                          0,
                                           argBuffer,
                                           MAX_PATH,
                                           &hProcess);
diff --git a/src/Usermode/ProcessCloseTwice/main.c b/src/Usermode/ProcessCloseTwice/main.c
index 5319269..5e23d37 100644
--- a/src/Usermode/ProcessCloseTwice/main.c
+++ b/src/Usermode/ProcessCloseTwice/main.c
@@ -10,7 +10,6 @@ __main(
 {
     STATUS status;
     UM_HANDLE hProcess;
-    STATUS termStatus;
 
     UNREFERENCED_PARAMETER(argc);
     UNREFERENCED_PARAMETER(argv);
@@ -28,13 +27,6 @@ __main(
             __leave;
         }
 
-        status = SyscallProcessWaitForTermination(hProcess, &termStatus);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
-            __leave;
-        }
-
         status = SyscallProcessCloseHandle(hProcess);
         if (!SUCCEEDED(status))
         {
diff --git a/src/Usermode/ProcessCreateMultiple/main.c b/src/Usermode/ProcessCreateMultiple/main.c
index 86e7f94..d39e1b7 100644
--- a/src/Usermode/ProcessCreateMultiple/main.c
+++ b/src/Usermode/ProcessCreateMultiple/main.c
@@ -25,8 +25,6 @@ __main(
     {
         for (DWORD i = 0; i < PROCESSES_TO_CREATE; ++i)
         {
-            STATUS termStatus;
-
             status = SyscallProcessCreate("dummy.exe",
                                           sizeof("dummy.exe"),
                                           NULL,
@@ -43,13 +41,6 @@ __main(
                 LOG_ERROR("0x%X is not a valid handle value for a process!\n", UM_INVALID_HANDLE_VALUE);
                 __leave;
             }
-
-            status = SyscallProcessWaitForTermination(hProcess[i], &termStatus);
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
-                __leave;
-            }
         }
     }
     __finally
diff --git a/src/Usermode/ProcessCreateOnce/main.c b/src/Usermode/ProcessCreateOnce/main.c
index 8675e41..cb27110 100644
--- a/src/Usermode/ProcessCreateOnce/main.c
+++ b/src/Usermode/ProcessCreateOnce/main.c
@@ -10,7 +10,6 @@ __main(
 {
     STATUS status;
     UM_HANDLE hProcess;
-    STATUS terminationStatus;
 
     UNREFERENCED_PARAMETER(argc);
     UNREFERENCED_PARAMETER(argv);
@@ -34,12 +33,6 @@ __main(
         {
             LOG_ERROR("0x%X is not a valid handle value for a process!\n", UM_INVALID_HANDLE_VALUE);
         }
-
-        status = SyscallProcessWaitForTermination(hProcess, &terminationStatus);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
-        }
     }
     __finally
     {
diff --git a/src/Usermode/ProcessGetPid/main.c b/src/Usermode/ProcessGetPid/main.c
index 0658817..4125a88 100644
--- a/src/Usermode/ProcessGetPid/main.c
+++ b/src/Usermode/ProcessGetPid/main.c
@@ -81,20 +81,7 @@ __main(
     {
         if (hProcess != UM_INVALID_HANDLE_VALUE)
         {
-            STATUS termStatus;
-
-            status = SyscallProcessWaitForTermination(hProcess, &termStatus);
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
-            }
-
-            status = SyscallProcessCloseHandle(hProcess);
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
-            }
-
+            SyscallProcessCloseHandle(hProcess);
             hProcess = UM_INVALID_HANDLE_VALUE;
         }
     }
diff --git a/src/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj b/src/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj
index 64e4639..79e163f 100644
--- a/src/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj
+++ b/src/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{2c3203ca-606a-4748-9859-06d6545dd166}</ProjectGuid>
     <RootNamespace>ProcessQuotaGood</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj b/src/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj
index 5520fcb..153f4b3 100644
--- a/src/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj
+++ b/src/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj
@@ -15,13 +15,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{73243670-829f-4e0c-b332-ec673749fad4}</ProjectGuid>
     <RootNamespace>ProcessQuotaJustRight</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj b/src/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj
index 9c3faa5..ecd7e07 100644
--- a/src/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj
+++ b/src/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{30a04ce4-0907-4357-a8cb-baf5d7fb463a}</ProjectGuid>
     <RootNamespace>ProcessQuotaMore</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/ProcessWaitClosedHandle/main.c b/src/Usermode/ProcessWaitClosedHandle/main.c
index 863e7d7..e59fef0 100644
--- a/src/Usermode/ProcessWaitClosedHandle/main.c
+++ b/src/Usermode/ProcessWaitClosedHandle/main.c
@@ -43,8 +43,6 @@ __main(
             LOG_ERROR("SyscallProcessWaitForTermination should have failed for closed handle 0x%X", hProcess);
             __leave;
         }
-
-        LOG_TEST_PASS;
     }
     __finally
     {
diff --git a/src/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj b/src/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj
deleted file mode 100644
index 06de4a8..0000000
--- a/src/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj
+++ /dev/null
@@ -1,87 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="main.c">
-      <SubType>
-      </SubType>
-    </ClCompile>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{7a3f18f0-b375-4a08-b944-ac7148793ae7}</ProjectGuid>
-    <RootNamespace>StackGrowthRecursiveFunction</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="Shared">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <LinkIncremental>false</LinkIncremental>
-    <EmbedManifest>false</EmbedManifest>
-    <GenerateManifest>false</GenerateManifest>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <CompileAsManaged>false</CompileAsManaged>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <StringPooling>false</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <FloatingPointExceptions>false</FloatingPointExceptions>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-    </ClCompile>
-    <Link>
-      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
-      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
-      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
-      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
-      <NoEntryPoint>false</NoEntryPoint>
-      <EntryPointSymbol>__start</EntryPointSymbol>
-      <SubSystem>Native</SubSystem>
-      <ForceFileOutput>
-      </ForceFileOutput>
-      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
-      <BaseAddress>0x140000000</BaseAddress>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <FixedBaseAddress>true</FixedBaseAddress>
-    </Link>
-  </ItemDefinitionGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/src/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj.filters b/src/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj.filters
deleted file mode 100644
index 6827613..0000000
--- a/src/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj.filters
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
-      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
-      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="main.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/src/Usermode/StackGrowthRecursiveFunction/main.c b/src/Usermode/StackGrowthRecursiveFunction/main.c
deleted file mode 100644
index 705d7a9..0000000
--- a/src/Usermode/StackGrowthRecursiveFunction/main.c
+++ /dev/null
@@ -1,29 +0,0 @@
-#include "common_lib.h"
-#include "syscall_if.h"
-#include "um_lib_helper.h"
-
-#define NO_OF_TIMES_TO_CALL_RECURSIVE_FUNCTIONS     10000
-
-// we turn all compiler optimizations off so we don't have any surprises
-#pragma optimize("", off)
-static void _RecursiveFunction(DWORD TimesToCall)
-{
-    if (TimesToCall == 0) return;
-
-    _RecursiveFunction(TimesToCall - 1);
-}
-
-STATUS
-__main(
-    DWORD       argc,
-    char**      argv
-)
-{
-    UNREFERENCED_PARAMETER(argc);
-    UNREFERENCED_PARAMETER(argv);
-
-    _RecursiveFunction(NO_OF_TIMES_TO_CALL_RECURSIVE_FUNCTIONS);
-
-    return STATUS_SUCCESS;
-}
-#pragma optimize("", on)
diff --git a/src/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj b/src/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj
deleted file mode 100644
index d4505e2..0000000
--- a/src/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj
+++ /dev/null
@@ -1,87 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="main.c">
-      <SubType>
-      </SubType>
-    </ClCompile>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{d4ef4101-8e74-45c4-93b0-1ac3f29399b9}</ProjectGuid>
-    <RootNamespace>StackGrowthVariables</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="Shared">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <LinkIncremental>false</LinkIncremental>
-    <EmbedManifest>false</EmbedManifest>
-    <GenerateManifest>false</GenerateManifest>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <CompileAsManaged>false</CompileAsManaged>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <StringPooling>false</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <FloatingPointExceptions>false</FloatingPointExceptions>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-    </ClCompile>
-    <Link>
-      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
-      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
-      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
-      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
-      <NoEntryPoint>false</NoEntryPoint>
-      <EntryPointSymbol>__start</EntryPointSymbol>
-      <SubSystem>Native</SubSystem>
-      <ForceFileOutput>
-      </ForceFileOutput>
-      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
-      <BaseAddress>0x140000000</BaseAddress>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <FixedBaseAddress>true</FixedBaseAddress>
-    </Link>
-  </ItemDefinitionGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/src/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj.filters b/src/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj.filters
deleted file mode 100644
index 6827613..0000000
--- a/src/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj.filters
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
-      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
-      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="main.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/src/Usermode/StackGrowthVariables/main.c b/src/Usermode/StackGrowthVariables/main.c
deleted file mode 100644
index 64a5ef2..0000000
--- a/src/Usermode/StackGrowthVariables/main.c
+++ /dev/null
@@ -1,72 +0,0 @@
-#include "common_lib.h"
-#include "syscall_if.h"
-#include "um_lib_helper.h"
-
-// we turn all compiler optimizations off so we don't have any surprises
-#pragma optimize("", off)
-
-#define NO_OF_TIMES_TO_ALLOCATE_ALMOST_A_PAGE_OF_LOCAL_VARIABLES     10
-
-#define VALUE_TO_PLACE_ON_LOCAL_VARIABLE                             0xAA
-
-// explanation can be found in figure (I have no idea why Visual C compiler generates 0x30 bytes
-// of 0xCC's for RTC at the start of the variable, but only 0x10 bytes at the end of it
-// 0x70 (0x20 shadow stack + 0x8 RA + 0x8 RDI + 0x40 CC's)
-#define MAX_LOCAL_VAR_ALLOC_LENGTH      (PAGE_SIZE - 0x70)
-
-// the reason why we call multiple functions to allocate more than 1 page of variables is because
-// if we want to allocate a PAGE_SIZE or more of local variables the Visual C compiler wants to call
-// __chkstk which HAL currently doesn't support (__chkstk would actually do what we do in these functions,
-// i.e. touch the local variables page by page)
-
-//  STACK TOP
-//  -----------------------------------------------------------------
-//  |                                                               |
-//  |       Shadow Space                                            |
-//  |                                                               |
-//  |                                                               |
-//  -----------------------------------------------------------------   -0x20
-//  |     Return Address                                            |
-//  -----------------------------------------------------------------   -0x28
-//  |     RDI                                                       |
-//  -----------------------------------------------------------------   -0x30
-//  |     RTC variable = 0xCC..CC                                   |
-//  -----------------------------------------------------------------   -0x40
-//  |     dummyVariable                                             |
-//  -----------------------------------------------------------------   -0xFD0
-//  |     RTC variable = 0xCC..CC                                   |
-//  -----------------------------------------------------------------   -0x1000
-static void _AllocateAlmostAPageOfLocalVariables(DWORD TimesToCall)
-{
-    BYTE dummyVariable[MAX_LOCAL_VAR_ALLOC_LENGTH];
-
-    if (TimesToCall == 0) return;
-
-    // on debug this isn't even needed because Visual C initializes the region
-    // with CC's
-    dummyVariable[0] = VALUE_TO_PLACE_ON_LOCAL_VARIABLE;
-
-    _AllocateAlmostAPageOfLocalVariables(TimesToCall - 1);
-
-    if (dummyVariable[0] != VALUE_TO_PLACE_ON_LOCAL_VARIABLE)
-    {
-        LOG_ERROR("Value placed on stack 0x%02x differs from value read 0x%02x\n",
-            VALUE_TO_PLACE_ON_LOCAL_VARIABLE, dummyVariable[0]);
-    }
-}
-
-
-STATUS
-__main(
-    DWORD       argc,
-    char**      argv
-)
-{
-    UNREFERENCED_PARAMETER(argc);
-    UNREFERENCED_PARAMETER(argv);
-
-    _AllocateAlmostAPageOfLocalVariables(NO_OF_TIMES_TO_ALLOCATE_ALMOST_A_PAGE_OF_LOCAL_VARIABLES);
-
-    return STATUS_SUCCESS;
-}
-#pragma optimize("", on)
diff --git a/src/Usermode/SwapLinear/SwapLinear.vcxproj b/src/Usermode/SwapLinear/SwapLinear.vcxproj
index 02f3664..e5efab6 100644
--- a/src/Usermode/SwapLinear/SwapLinear.vcxproj
+++ b/src/Usermode/SwapLinear/SwapLinear.vcxproj
@@ -15,13 +15,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{d61d8289-38bd-4cc1-b943-a53c2dcd800b}</ProjectGuid>
     <RootNamespace>SwapLinear</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj b/src/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj
index ebd400b..0c4caf6 100644
--- a/src/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj
+++ b/src/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj
@@ -15,13 +15,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{fc4360d9-b78c-4cd3-82ee-67877e091ec7}</ProjectGuid>
     <RootNamespace>SwapMultipleShared</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/SwapMultipleShared/main.c b/src/Usermode/SwapMultipleShared/main.c
index f805a2b..ea06c54 100644
--- a/src/Usermode/SwapMultipleShared/main.c
+++ b/src/Usermode/SwapMultipleShared/main.c
@@ -129,7 +129,7 @@ __main(
     {
         if (pAllocatedAddress != NULL)
         {
-            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_DECOMMIT | VMM_FREE_TYPE_RELEASE);
             if (!SUCCEEDED(status))
             {
                 LOG_FUNC_ERROR("SyscallVirtualFree", status);
diff --git a/src/Usermode/SwapZeros/SwapZeros.vcxproj b/src/Usermode/SwapZeros/SwapZeros.vcxproj
index 3be4fc4..2cc9568 100644
--- a/src/Usermode/SwapZeros/SwapZeros.vcxproj
+++ b/src/Usermode/SwapZeros/SwapZeros.vcxproj
@@ -15,13 +15,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{2bf11960-6b4a-46ce-92c0-21c30ff1ab39}</ProjectGuid>
     <RootNamespace>SwapZeros</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj b/src/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj
index 0debd6c..347188d 100644
--- a/src/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj
+++ b/src/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj
@@ -15,13 +15,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{f50ba1cb-dfb3-4c75-9c21-aafbf009ca42}</ProjectGuid>
     <RootNamespace>SwapZerosWritten</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/ThreadCreateBadPointer/main.c b/src/Usermode/ThreadCreateBadPointer/main.c
index 9043ff2..f5cdc49 100644
--- a/src/Usermode/ThreadCreateBadPointer/main.c
+++ b/src/Usermode/ThreadCreateBadPointer/main.c
@@ -10,7 +10,7 @@ __main(
 )
 {
     UM_HANDLE hThread;
-    volatile QWORD test = 0;
+    STATUS status;
 
     UNREFERENCED_PARAMETER(argc);
     UNREFERENCED_PARAMETER(argv);
@@ -19,13 +19,10 @@ __main(
 
     __try
     {
-        UmThreadCreate((PFUNC_ThreadStart) 0x7000'3203ULL, NULL, &hThread);
-
-        // wait for the process to crash
-        while(&hThread)
+        status = UmThreadCreate(NULL, NULL, &hThread);
+        if (SUCCEEDED(status))
         {
-            test += 1;
-            _mm_pause();
+            LOG_ERROR("UmThreadCreate succeeded, but it should have failed because of NULL function\n");
         }
     }
     __finally
diff --git a/src/Usermode/ThreadCreateMultiple/main.c b/src/Usermode/ThreadCreateMultiple/main.c
index 8d2ff29..5cb3ed7 100644
--- a/src/Usermode/ThreadCreateMultiple/main.c
+++ b/src/Usermode/ThreadCreateMultiple/main.c
@@ -22,7 +22,6 @@ __main(
 )
 {
     UM_HANDLE hThreads[THREADS_TO_CREATE];
-    STATUS thStatuses[THREADS_TO_CREATE];
     STATUS status;
 
     UNREFERENCED_PARAMETER(argc);
@@ -53,15 +52,6 @@ __main(
     }
     __finally
     {
-        for (DWORD i = 0; i < THREADS_TO_CREATE; ++i)
-        {
-            status = SyscallThreadWaitForTermination(hThreads[i], &thStatuses[i]);
-            if (!SUCCEEDED(status))
-            {
-                LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
-            }
-        }
-
         for (DWORD i = 0; i < THREADS_TO_CREATE; ++i)
         {
             SyscallThreadCloseHandle(hThreads[i]);
diff --git a/src/Usermode/ThreadWaitClosedHandle/main.c b/src/Usermode/ThreadWaitClosedHandle/main.c
index 548f849..02bd71c 100644
--- a/src/Usermode/ThreadWaitClosedHandle/main.c
+++ b/src/Usermode/ThreadWaitClosedHandle/main.c
@@ -47,7 +47,7 @@ __main(
         status = SyscallThreadWaitForTermination(hThread, &terminationStatus);
         if (SUCCEEDED(status))
         {
-            LOG_ERROR("SyscallThreadWaitForTermination should have failed because thread handle was closed!");
+            LOG_ERROR("SyscallThreadWaitForTermination should have failed because thread handle was closed!\n");
         }
     }
     __finally
diff --git a/src/Usermode/ThreadWaitNormal/main.c b/src/Usermode/ThreadWaitNormal/main.c
index ca7c963..ef3e078 100644
--- a/src/Usermode/ThreadWaitNormal/main.c
+++ b/src/Usermode/ThreadWaitNormal/main.c
@@ -61,7 +61,7 @@ __main(
             __leave;
         }
 
-        LOG("First secondary thread has finished execution!");
+        LOG("First secondary thread has finished execution!\n");
 
         if (terminationStatus != STATUS_SUCCESS)
         {
@@ -84,7 +84,7 @@ __main(
             __leave;
         }
 
-        LOG("Second secondary thread has finished execution!");
+        LOG("Second secondary thread has finished execution!\n");
 
         if (terminationStatus != STATUS_UNSUCCESSFUL)
         {
diff --git a/src/Usermode/ThreadWaitTerminated/main.c b/src/Usermode/ThreadWaitTerminated/main.c
index 985c59a..3e9289e 100644
--- a/src/Usermode/ThreadWaitTerminated/main.c
+++ b/src/Usermode/ThreadWaitTerminated/main.c
@@ -54,7 +54,7 @@ __main(
             __leave;
         }
 
-        LOG("Secondary thread has finished execution!");
+        LOG("Secondary thread has finished execution!\n");
 
         if (terminationStatus != STATUS_SUCCESS)
         {
diff --git a/src/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj b/src/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj
index add6d6c..eb2c895 100644
--- a/src/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj
+++ b/src/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj
@@ -24,8 +24,9 @@
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -37,7 +38,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -86,30 +87,19 @@
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
       <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
       <TreatWarningAsError>true</TreatWarningAsError>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
       <CompileAsManaged>false</CompileAsManaged>
-      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\..\shared\common;inc;headers</AdditionalIncludeDirectories>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <FloatingPointExceptions>false</FloatingPointExceptions>
-      <CreateHotpatchableImage>false</CreateHotpatchableImage>
-      <OpenMPSupport>false</OpenMPSupport>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
     </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
     <YASM>
       <Debug>true</Debug>
       <Defines>DEBUG</Defines>
diff --git a/src/Usermode/UsermodeLibrary/inc/um_lib_helper.h b/src/Usermode/UsermodeLibrary/inc/um_lib_helper.h
index 3ca5184..32f0778 100644
--- a/src/Usermode/UsermodeLibrary/inc/um_lib_helper.h
+++ b/src/Usermode/UsermodeLibrary/inc/um_lib_helper.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#include "native/string.h"
-
 #define LOG(buf,...)                            LogBuffer(buf,__VA_ARGS__)
 #define LOGL(buf,...)                           LOG("[%s][%d]"##buf, strrchr(__FILE__,'\\') + 1, __LINE__, __VA_ARGS__)
 
@@ -10,8 +8,6 @@
 #define LOG_FUNC_ERROR(func,status)             LOG_ERROR("Function %s failed with status 0x%x\n", (func), (status) )
 #define LOG_FUNC_ERROR_ALLOC(func,size)         LOG_ERROR("Function %s failed alloc for size 0x%x\n", (func), (size))
 
-#define LOG_TEST_PASS                           LOG("\n[PASS]\n");
-
 void
 LogBuffer(
     IN_Z    char*                   FormatBuffer,
diff --git a/src/Usermode/UsermodeLibrary/src/syscall_if.c b/src/Usermode/UsermodeLibrary/src/syscall_if.c
index 7248b5b..90c1363 100644
--- a/src/Usermode/UsermodeLibrary/src/syscall_if.c
+++ b/src/Usermode/UsermodeLibrary/src/syscall_if.c
@@ -81,10 +81,10 @@ STATUS
 SyscallProcessCreate(
     IN_READS_Z(PathLength)
                 char*               ProcessPath,
-    IN          QWORD               PathLength,
+    IN          DWORD               PathLength,
     IN_READS_OPT_Z(ArgLength)
                 char*               Arguments,
-    IN          QWORD               ArgLength,
+    IN          DWORD               ArgLength,
     OUT         UM_HANDLE*          ProcessHandle
     )
 {
@@ -127,12 +127,10 @@ SyscallVirtualAlloc(
     IN          QWORD                   Size,
     IN          VMM_ALLOC_TYPE          AllocType,
     IN          PAGE_RIGHTS             PageRights,
-    IN_OPT      UM_HANDLE               FileHandle,
-    IN_OPT      QWORD                   Key,
-    OUT         PVOID*                  AllocatedAddress
+    IN_OPT      UM_HANDLE               FileHandle
     )
 {
-    return SyscallEntry(SyscallIdVirtualAlloc, BaseAddress, Size, AllocType, PageRights, FileHandle, Key, AllocatedAddress);
+    return SyscallEntry(SyscallIdVirtualAlloc, BaseAddress, Size, AllocType, PageRights, FileHandle);
 }
 
 // SyscallIdVirtualFree
@@ -153,7 +151,7 @@ STATUS
 SyscallFileCreate(
     IN_READS_Z(PathLength)
                 char*                   Path,
-    IN          QWORD                   PathLength,
+    IN          DWORD                   PathLength,
     IN          BOOLEAN                 Directory,
     IN          BOOLEAN                 Create,
     OUT         UM_HANDLE*              FileHandle
diff --git a/src/Usermode/UsermodeLibrary/src/um_lib.c b/src/Usermode/UsermodeLibrary/src/um_lib.c
index e88796c..f87c056 100644
--- a/src/Usermode/UsermodeLibrary/src/um_lib.c
+++ b/src/Usermode/UsermodeLibrary/src/um_lib.c
@@ -2,6 +2,8 @@
 
 #define RFLAGS_DIRECTION_BIT            ((QWORD)1<<10)
 
+#define SYSCALL_IF_VERSION_UM           0x1
+
 extern
 STATUS
 __main(
@@ -42,7 +44,7 @@ __start(
         CHECK_STACK_ALIGNMENT;
 
         // Validate syscall interface
-        status = SyscallValidateInterface(SYSCALL_IMPLEMENTED_IF_VERSION);
+        status = SyscallValidateInterface(SYSCALL_IF_VERSION_UM);
         if (!SUCCEEDED(status))
         {
             __leave;
diff --git a/src/Usermode/UsermodeLibrary/src/um_lib_helper.c b/src/Usermode/UsermodeLibrary/src/um_lib_helper.c
index ae546fd..6c54df2 100644
--- a/src/Usermode/UsermodeLibrary/src/um_lib_helper.c
+++ b/src/Usermode/UsermodeLibrary/src/um_lib_helper.c
@@ -18,10 +18,6 @@ volatile DWORD m_freeStartCtxIdx;
 
 static FUNC_ThreadStart __start_thread;
 
-// Temporal hack to avoid linker optimization of marking data section to initialized in the case where everything is 0 inside the data section
-// TODO: fix HAL9000 PE loader to check the section property and to initialize the data section in memory to 0
-volatile QWORD m_dummyNonZeroData = 0x0D15EA5E;
-
 void
 LogBuffer(
     IN_Z    char*                   FormatBuffer,
@@ -33,19 +29,16 @@ LogBuffer(
     STATUS status;
     QWORD bytesWritten;
 
-    // Temporal hack
-    ASSERT(m_dummyNonZeroData == 0x0D15EA5E);
-
     va_start(va, FormatBuffer);
 
     // resolve formatted buffer
     status = vsnprintf(logBuffer, LOG_BUF_MAX_SIZE, FormatBuffer, va);
     ASSERT(SUCCEEDED(status));
 
-    status = SyscallFileWrite(UM_FILE_HANDLE_STDOUT,
-                              logBuffer,
-                              strlen(logBuffer) + 1,
-                              &bytesWritten);
+    SyscallFileWrite(UM_FILE_HANDLE_STDOUT,
+                     logBuffer,
+                     strlen(logBuffer) + 1,
+                     &bytesWritten);
     ASSERT(SUCCEEDED(status));
     ASSERT(bytesWritten == strlen(logBuffer) + 1);
 }
diff --git a/src/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj b/src/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj
index 9ca1d67..d66a285 100644
--- a/src/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj
+++ b/src/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{e1bc4f68-4192-4408-b94d-b161c6133c73}</ProjectGuid>
     <RootNamespace>VirtualAllocAccessFail</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj b/src/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj
index e30b84d..96d75be 100644
--- a/src/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj
+++ b/src/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{f91940c3-0684-4512-b3c1-d68ecea7d4e0}</ProjectGuid>
     <RootNamespace>VirtualAllocHugeEager</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj b/src/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj
index 638db19..0f4e482 100644
--- a/src/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj
+++ b/src/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{a2cf4462-c6e6-441b-add4-352e0d0871b2}</ProjectGuid>
     <RootNamespace>VirtualAllocHugeLazy</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj b/src/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj
index 5571d5e..0ea955b 100644
--- a/src/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj
+++ b/src/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj
@@ -15,13 +15,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{2ecd668b-a99f-4c8a-b2fc-1fdbf1b6f25a}</ProjectGuid>
     <RootNamespace>VirtualAllocNormal</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj b/src/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj
index 9d1fdda..df59ab6 100644
--- a/src/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj
+++ b/src/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{d6919c57-7503-4f41-914e-4f0a5642d795}</ProjectGuid>
     <RootNamespace>VirtualAllocWriteExec</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj b/src/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj
index e76a547..931a44c 100644
--- a/src/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj
+++ b/src/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{c26bfeee-6078-400e-ad95-cc25b351ba4d}</ProjectGuid>
     <RootNamespace>VirtualAllocZeros</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj b/src/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj
index 70ba1e0..e294757 100644
--- a/src/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj
+++ b/src/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{833f5049-d661-4297-842c-d9c9ac8469c0}</ProjectGuid>
     <RootNamespace>VirtualFreeInvalid</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj b/src/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj
index 4a99a32..7b5e8f3 100644
--- a/src/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj
+++ b/src/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{e6b41356-895b-419d-93a4-8746c086f7e8}</ProjectGuid>
     <RootNamespace>VirtualFreeMore</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Usermode/VirtualFreeMore/main.c b/src/Usermode/VirtualFreeMore/main.c
index 8620b55..d57d8d2 100644
--- a/src/Usermode/VirtualFreeMore/main.c
+++ b/src/Usermode/VirtualFreeMore/main.c
@@ -51,7 +51,7 @@ __main(
     {
         if (pAllocatedAddress != NULL)
         {
-            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_DECOMMIT | VMM_FREE_TYPE_RELEASE);
             if (!SUCCEEDED(status))
             {
                 LOG_FUNC_ERROR("SyscallVirtualFree", status);
diff --git a/src/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj b/src/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj
index 9280e84..ab048b4 100644
--- a/src/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj
+++ b/src/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj
@@ -12,13 +12,13 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{0b6872be-9637-45b8-8404-287173bf8b35}</ProjectGuid>
     <RootNamespace>VirtualSharedNormal</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
diff --git a/src/Utils/RunTests/RunTests.vcxproj b/src/Utils/RunTests/RunTests.vcxproj
index a947ae6..5d09b72 100644
--- a/src/Utils/RunTests/RunTests.vcxproj
+++ b/src/Utils/RunTests/RunTests.vcxproj
@@ -9,10 +9,6 @@
       <Configuration>Userprog</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="VirtualMemory|x64">
-      <Configuration>VirtualMemory</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{291C9D17-6BA7-404F-8664-C60F38E061C7}</ProjectGuid>
@@ -32,12 +28,6 @@
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'" Label="Configuration">
-    <ConfigurationType>Utility</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v142</PlatformToolset>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
@@ -49,9 +39,6 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Userprog|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Threads|x64'">
     <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
@@ -61,10 +48,6 @@
     <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
     <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Threads|x64'">
     <ClCompile>
       <WarningLevel>Level3</WarningLevel>
@@ -72,7 +55,7 @@
       <SDLCheck>true</SDLCheck>
     </ClCompile>
     <PostBuildEvent>
-      <Command>"$(SolutionDir)..\postbuild\run_tests.cmd" "$(SolutionDir)" "$(SolutionDir)..\TESTS\threads" Tests.module /run /16 180</Command>
+      <Command>"$(SolutionDir)postbuild\run_tests.cmd" "$(SolutionDir)" "$(SolutionDir)..\TESTS\threads" Tests.module /run /16 180</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Userprog|x64'">
@@ -82,17 +65,7 @@
       <SDLCheck>true</SDLCheck>
     </ClCompile>
     <PostBuildEvent>
-      <Command>"$(SolutionDir)..\postbuild\run_tests.cmd" "$(SolutionDir)" "$(SolutionDir)..\TESTS\userprog" Tests.module /proctest / 180</Command>
-    </PostBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <SDLCheck>true</SDLCheck>
-    </ClCompile>
-    <PostBuildEvent>
-      <Command>"$(SolutionDir)..\postbuild\run_tests.cmd" "$(SolutionDir)" "$(SolutionDir)..\TESTS\virtualmemory" Tests.module /proctest / 180</Command>
+      <Command>$(SolutionDir)postbuild\run_tests.cmd $(SolutionDir) $(SolutionDir)..\TESTS\userprog Tests.module /proctest / 180</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
   <ItemGroup>
diff --git a/src/Volume/Volume.vcxproj b/src/Volume/Volume.vcxproj
index 95b66e2..696a2d8 100644
--- a/src/Volume/Volume.vcxproj
+++ b/src/Volume/Volume.vcxproj
@@ -23,9 +23,10 @@
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
     <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>MultiByte</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -36,7 +37,7 @@
   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
@@ -47,13 +48,6 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <RunCodeAnalysis>true</RunCodeAnalysis>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
-    <TargetExt>.lib</TargetExt>
-    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
-    <RunCodeAnalysis>true</RunCodeAnalysis>
-  </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <WarningLevel>Level4</WarningLevel>
@@ -67,7 +61,7 @@
       <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
       <OmitFramePointers>true</OmitFramePointers>
       <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
+      <StringPooling>false</StringPooling>
       <MinimalRebuild>false</MinimalRebuild>
       <ExceptionHandling>false</ExceptionHandling>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -85,36 +79,16 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
-      <WarningLevel>Level4</WarningLevel>
+      <WarningLevel>Level3</WarningLevel>
       <Optimization>MaxSpeed</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAsManaged>false</CompileAsManaged>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
-      <OmitFramePointers>
-      </OmitFramePointers>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>false</ExceptionHandling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <ControlFlowGuard>false</ControlFlowGuard>
-      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
-      <RuntimeTypeInfo>false</RuntimeTypeInfo>
-      <OpenMPSupport>false</OpenMPSupport>
-      <EnablePREfast>true</EnablePREfast>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
       <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
     </ClCompile>
-    <PostBuildEvent>
-      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
-    </PostBuildEvent>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="src\volume.c" />
diff --git a/src/Volume/src/volume.c b/src/Volume/src/volume.c
index 7402574..a918913 100644
--- a/src/Volume/src/volume.c
+++ b/src/Volume/src/volume.c
@@ -2,6 +2,7 @@
 #include "volume.h"
 #include "volume_dispatch.h"
 
+SAL_SUCCESS
 static
 STATUS
 _VolInitialize(
@@ -10,6 +11,7 @@ _VolInitialize(
     INOUT       PDRIVER_OBJECT          DriverObject
     );
 
+SAL_SUCCESS
 STATUS
 (__cdecl VolDriverEntry)(
     INOUT       PDRIVER_OBJECT      DriverObject
@@ -156,6 +158,7 @@ STATUS
     return status;
 }
 
+SAL_SUCCESS
 STATUS
 _VolInitialize(
     IN          PDEVICE_OBJECT          Disk,
diff --git a/src/Volume/src/volume_dispatch.c b/src/Volume/src/volume_dispatch.c
index 2d38be8..40288bf 100644
--- a/src/Volume/src/volume_dispatch.c
+++ b/src/Volume/src/volume_dispatch.c
@@ -27,6 +27,7 @@ _VolCheckIOParameters(
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl VolDispatchReadWrite)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -103,6 +104,7 @@ STATUS
     return STATUS_SUCCESS;
 }
 
+SAL_SUCCESS
 STATUS
 (__cdecl VolDispatchDeviceControl)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
diff --git a/src/shared/common/mem_structures.h b/src/shared/common/mem_structures.h
index f868158..9344b06 100644
--- a/src/shared/common/mem_structures.h
+++ b/src/shared/common/mem_structures.h
@@ -15,7 +15,6 @@ typedef DWORD                       VMM_ALLOC_TYPE;
 #define VMM_ALLOC_TYPE_RESERVE      0x1
 #define VMM_ALLOC_TYPE_COMMIT       0x2
 #define VMM_ALLOC_TYPE_NOT_LAZY     0x4
-#define VMM_ALLOC_TYPE_ZERO         0x8
 
 typedef DWORD                       VMM_FREE_TYPE;
 
diff --git a/src/shared/common/syscall_defs.h b/src/shared/common/syscall_defs.h
index 38c0dec..587d0e2 100644
--- a/src/shared/common/syscall_defs.h
+++ b/src/shared/common/syscall_defs.h
@@ -2,14 +2,12 @@
 
 typedef DWORD SYSCALL_IF_VERSION;
 
-#define SYSCALL_IMPLEMENTED_IF_VERSION      0x1
+#define UM_INVALID_HANDLE_VALUE 0
 
-#define UM_INVALID_HANDLE_VALUE             0
-
-#define UM_FILE_HANDLE_STDOUT               (UM_HANDLE)0x1
+#define UM_FILE_HANDLE_STDOUT   (UM_HANDLE)0x1
 
 typedef QWORD UM_HANDLE;
 
 #include "mem_structures.h"
 #include "thread_defs.h"
-#include "process_defs.h"
+#include "process_defs.h"
\ No newline at end of file
diff --git a/src/shared/common/syscall_func.h b/src/shared/common/syscall_func.h
index 115c3a4..32ea494 100644
--- a/src/shared/common/syscall_func.h
+++ b/src/shared/common/syscall_func.h
@@ -126,10 +126,10 @@ STATUS
 SyscallProcessCreate(
     IN_READS_Z(PathLength)
                 char*               ProcessPath,
-    IN          QWORD               PathLength,
+    IN          DWORD               PathLength,
     IN_READS_OPT_Z(ArgLength)
                 char*               Arguments,
-    IN          QWORD               ArgLength,
+    IN          DWORD               ArgLength,
     OUT         UM_HANDLE*          ProcessHandle
     );
 
@@ -177,44 +177,16 @@ SyscallProcessCloseHandle(
     );
 
 // SyscallIdVirtualAlloc
-//******************************************************************************
-// Function:     SyscallVirtualAlloc
-// Description:  Allocates a virtual address range, this can be used for mapping
-//               a file in memory by specifying a valid FileHandle. When Key is
-//               non-zero this creates or accesses an already existing shared
-//               memory range.
-// Returns:      STATUS
-// Parameter:    IN_OPT PVOID BaseAddress - Provides a hint on where to place
-//                                          the virtual allocation.
-// Parameter:    IN QWORD Size
-// Parameter:    IN VMM_ALLOC_TYPE AllocType
-// Parameter:    IN PAGE_RIGHTS PageRights
-// Parameter:    IN_OPT UM_HANDLE FileHandle - When non-NULL the range will be
-//                                             backed up by a file.
-// Parameter:    IN_OPT QWORD Key - When non-zero creates or accesses a system
-//                                  wide shared memory region.
-// Parameter:    OUT PVOID* AllocatedAddress - The virtual address allocated
-//******************************************************************************
 STATUS
 SyscallVirtualAlloc(
     IN_OPT      PVOID                   BaseAddress,
     IN          QWORD                   Size,
     IN          VMM_ALLOC_TYPE          AllocType,
     IN          PAGE_RIGHTS             PageRights,
-    IN_OPT      UM_HANDLE               FileHandle,
-    IN_OPT      QWORD                   Key,
-    OUT         PVOID*                  AllocatedAddress
+    IN_OPT      UM_HANDLE               FileHandle
     );
 
 // SyscallIdVirtualFree
-//******************************************************************************
-// Function:     SyscallVirtualFree
-// Description:  Frees a previously allocated virtual address range.
-// Returns:      STATUS
-// Parameter:    IN PVOID Address
-// Parameter:    QWORD Size
-// Parameter:    IN VMM_FREE_TYPE FreeType
-//******************************************************************************
 STATUS
 SyscallVirtualFree(
     IN          PVOID                   Address,
@@ -249,7 +221,7 @@ STATUS
 SyscallFileCreate(
     IN_READS_Z(PathLength)
                 char*                   Path,
-    IN          QWORD                   PathLength,
+    IN          DWORD                   PathLength,
     IN          BOOLEAN                 Directory,
     IN          BOOLEAN                 Create,
     OUT         UM_HANDLE*              FileHandle
diff --git a/src/shared/kernel/ex.h b/src/shared/kernel/ex.h
index 04e7577..c97520b 100644
--- a/src/shared/kernel/ex.h
+++ b/src/shared/kernel/ex.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#include "cl_heap.h"
+#include "heap.h"
 #include "heap_tags.h"
 
 typedef struct _SYSTEM_INFORMATION
diff --git a/src/shared/kernel/ex_event.h b/src/shared/kernel/ex_event.h
index c61f3b8..c80f81b 100644
--- a/src/shared/kernel/ex_event.h
+++ b/src/shared/kernel/ex_event.h
@@ -5,8 +5,8 @@
 
 typedef enum _EX_EVT_TYPE
 {
-    ExEventTypeNotification,        // notifies all threads
-    ExEventTypeSynchronization,     // notifies only one thread
+    ExEventTypeNotification,
+    ExEventTypeSynchronization,
 
     ExEventTypeReserved
 } EX_EVT_TYPE;
@@ -60,9 +60,9 @@ ExEventClearSignal(
 
 //******************************************************************************
 // Function:     ExEventWaitForSignal
-// Description:  Waits for an event to be signaled. If the event is not signaled
-//               the calling thread will be placed in a waiting list and its
-//               execution will be blocked.
+// Description:  Waits for an event to be signaled. If the event is signaled it
+//               will place the thread in a waiting list and block its
+//               execution.
 // Returns:      void
 // Parameter:    INOUT EX_EVENT * Event
 //******************************************************************************
diff --git a/src/shared/kernel/filesystem.h b/src/shared/kernel/filesystem.h
index 068cace..44ff802 100644
--- a/src/shared/kernel/filesystem.h
+++ b/src/shared/kernel/filesystem.h
@@ -38,8 +38,7 @@ typedef struct _FILE_OBJECT
 typedef struct _VPB_FLAGS
 {
     DWORD               Mounted     :    1;
-    DWORD               SwapSpace   :    1;
-    DWORD               Reserved    :   30;
+    DWORD               Reserved    :   31;
 } VPB_FLAGS, *PVPB_FLAGS;
 
 // Provides an association between a logical volume
diff --git a/src/shared/kernel/heap.h b/src/shared/kernel/heap.h
new file mode 100644
index 0000000..73c634a
--- /dev/null
+++ b/src/shared/kernel/heap.h
@@ -0,0 +1,79 @@
+#pragma once
+
+#include "list.h"
+#include "heap_tags.h"
+
+// memory alignment in case none is specified by the caller
+#define HEAP_DEFAULT_ALIGNMENT          16
+
+#define PoolAllocateZeroMemory          0x2 // memory allocated will be zeroed
+#define PoolAllocatePanicIfFail         0x4 // system will PANIC in case the allocation will fail
+
+
+typedef struct _HEAP_HEADER
+{
+    DWORD               Magic;              // used for error checking
+    QWORD               HeapSizeMaximum;    // the maximum size of the HEAP
+    QWORD               HeapSizeRemaining;  // the size remaining to allocated
+    QWORD               BaseAddress;        // heap structure base address
+    QWORD               FreeAddress;        // address from which to start search
+    QWORD               HeapNumberOfAllocations;
+
+    PLIST_ENTRY         EntryToRestartSearch;
+
+    // list of heap allocations
+    // this list is always ordered by address
+    LIST_ENTRY          HeapAllocations;
+} HEAP_HEADER, *PHEAP_HEADER;
+
+//******************************************************************************
+// Function:    HeapInitializeSystem
+// Description: Initializes the heap system. Needs to be called before any
+//              allocations are made.
+// Returns:     STATUS
+// Parameter:   IN PVOID BaseAddress     - address from which allocations will
+//                                         start
+// Parameter:   IN QWORD MemoryAvailable - bytes available for the heap
+//******************************************************************************
+SAL_SUCCESS
+STATUS
+HeapInitializeSystem(
+    IN                                  QWORD                   MemoryAvailable,
+    OUT_PTR                             PHEAP_HEADER*           HeapHeader
+    );
+
+//******************************************************************************
+// Function:    HeapAllocatePoolWithTag
+// Description: Allocates a number of bytes with a specified tag and returns
+//              the address.
+// Returns:     PVOID - The newly allocated memory region
+// Parameter:   IN DWORD Flags
+// Parameter:   IN DWORD AllocationSize - Number of bytes to allocate
+// Parameter:   IN DWORD Tag
+// Parameter:   IN DWORD AllocationAlignment
+//******************************************************************************
+_Always_(_When_(IsBooleanFlagOn(Flags,PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+HeapAllocatePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    );
+
+//******************************************************************************
+// Function:    HeapFreePoolWithTag
+// Description: Frees a previously allocated memory region.
+// Returns:     void
+// Parameter:   IN PVOID MemoryAddress
+// Parameter:   IN DWORD Tag - MUST match tag used for allocation
+//******************************************************************************
+void
+HeapFreePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    );
\ No newline at end of file
diff --git a/src/shared/kernel/io.h b/src/shared/kernel/io.h
index c6d91b4..3db7e0f 100644
--- a/src/shared/kernel/io.h
+++ b/src/shared/kernel/io.h
@@ -26,6 +26,11 @@ IoDeleteDevice(
     INOUT   PDEVICE_OBJECT      Device
     );
 
+void
+IoRegisterFileSystem(
+    IN      PDEVICE_OBJECT      FileSystemDevice
+    );
+
 PTR_SUCCESS
 PDRIVER_OBJECT
 IoCreateDriver(
@@ -38,7 +43,7 @@ IoGetDriverExtension(
     IN          PDEVICE_OBJECT  Device
     );
 
-void
+void 
 IoAttachDevice(
     INOUT   PDEVICE_OBJECT  SourceDevice,
     IN      PDEVICE_OBJECT  TargetDevice
@@ -72,6 +77,7 @@ IoCopyCurrentStackLocationToNext(
     INOUT   PIRP            Irp
     );
 
+SAL_SUCCESS
 STATUS
 IoCallDriver(
     IN      PDEVICE_OBJECT  Device,
@@ -85,6 +91,7 @@ IoCompleteIrp(
 
 #define IoIsIrpComplete(irp)        (TRUE==((irp)->Flags.Completed))
 
+SAL_SUCCESS
 STATUS
 IoGetPciDevicesMatchingSpecification(
     IN          PCI_SPEC        Specification,
@@ -94,6 +101,7 @@ IoGetPciDevicesMatchingSpecification(
     OUT         DWORD*           NumberOfDevices
     );
 
+SAL_SUCCESS
 STATUS
 IoGetPciDevicesMatchingLocation(
     IN          PCI_SPEC_LOCATION           Specification,
@@ -109,10 +117,11 @@ IoGetPciSecondaryBusForBridge(
     OUT         BYTE*                       Bus
     );
 
+SAL_SUCCESS
 STATUS
 IoGetDevicesByType(
     IN                      DEVICE_TYPE         DeviceType,
-    _When_(*NumberOfDevices>0,OUT_PTR)
+    _When_(*NumberOfDevices>0,OUT_PTR)      
     _When_(*NumberOfDevices==0, OUT_PTR_MAYBE_NULL)
                             PDEVICE_OBJECT**    DeviceObjects,
     OUT                     DWORD*              NumberOfDevices
@@ -130,10 +139,11 @@ IoBuildDeviceIoControlRequest(
     IN          PDEVICE_OBJECT      DeviceObject,
     IN_OPT      PVOID               InputBuffer,
     IN          DWORD               InputBufferLength,
-    OUT_OPT     PVOID               OutputBuffer,
+    IN_OPT      PVOID               OutputBuffer,
     IN          DWORD               OutputBufferLength
     );
 
+SAL_SUCCESS
 STATUS
 IoReadDeviceEx(
     IN                          PDEVICE_OBJECT          DeviceObject,
@@ -145,6 +155,7 @@ IoReadDeviceEx(
 
 #define IoReadDevice(Dev,Buf,Len,Off)                  IoReadDeviceEx((Dev),(Buf),(Len),(Off),FALSE)
 
+SAL_SUCCESS
 STATUS
 IoWriteDeviceEx(
     IN                          PDEVICE_OBJECT          DeviceObject,
@@ -156,6 +167,7 @@ IoWriteDeviceEx(
 
 #define IoWriteDevice(Dev,Buf,Len,Off)                  IoWriteDeviceEx((Dev),(Buf),(Len),(Off),FALSE)
 
+SAL_SUCCESS
 STATUS
 IoAllocateMdl(
     IN          PVOID           VirtualAddress,
@@ -182,6 +194,7 @@ IoMdlGetTranslationPair(
     IN          DWORD           Index
     );
 
+SAL_SUCCESS
 STATUS
 IoRegisterInterruptEx(
     IN          PIO_INTERRUPT           Interrupt,
@@ -234,6 +247,7 @@ IoGetCurrentDateTime(
 /////////                        FILE OPERATIONS                                        /////////
 /////////////////////////////////////////////////////////////////////////////////////////////////
 
+SAL_SUCCESS
 STATUS
 IoCreateFile(
     OUT_PTR     PFILE_OBJECT*           Handle,
@@ -243,43 +257,30 @@ IoCreateFile(
     IN          BOOLEAN                 Asynchronous
     );
 
+SAL_SUCCESS
 STATUS
 IoCloseFile(
     IN          PFILE_OBJECT            FileHandle
     );
 
+SAL_SUCCESS
 STATUS
 IoReadFile(
     IN          PFILE_OBJECT            FileHandle,
     IN          QWORD                   BytesToRead,
     IN_OPT      QWORD*                  FileOffset,
-    OUT_WRITES_BYTES(BytesToRead)
-                PVOID                   Buffer,
+    OUT         PVOID                   Buffer,
     OUT         QWORD*                  BytesRead
     );
 
-STATUS
-IoWriteFile(
-    IN          PFILE_OBJECT            FileHandle,
-    IN          QWORD                   BytesToWrite,
-    IN_OPT      QWORD*                  FileOffset,
-    IN_READS_BYTES(BytesToWrite)
-                PVOID                   Buffer,
-    OUT         QWORD*                  BytesWritten
-    );
-
-STATUS
-IoGetFileSize(
-    IN          PFILE_OBJECT            FileHandle,
-    OUT         QWORD*                  FileSize
-    );
-
+SAL_SUCCESS
 STATUS
 IoQueryInformationFile(
     IN          PFILE_OBJECT            FileHandle,
     OUT         PFILE_INFORMATION       FileInformation
     );
 
+SAL_SUCCESS
 STATUS
 IoQueryDirectoryFile(
     IN          PFILE_OBJECT                    FileHandle,
diff --git a/src/shared/kernel/io_structures.h b/src/shared/kernel/io_structures.h
index 7db53d7..f45925c 100644
--- a/src/shared/kernel/io_structures.h
+++ b/src/shared/kernel/io_structures.h
@@ -2,16 +2,9 @@
 
 #include "time.h"
 
-/// never do this at home kids
-#include "..\..\HAL9000\headers\mutex.h"
-
-#define SHORT_NAME_MAX_LENGTH       16
-
 // common packing
 #pragma pack(push,8)
 
-#pragma warning(push)
-
 // warning C4201: nonstandard extension used: nameless struct/union
 #pragma warning(disable:4201)
 
@@ -43,16 +36,16 @@ typedef struct _FILE_INFORMATION
 // IRP_MN_QUERY_DIRECTORY
 // warning C4200: nonstandard extension used: zero-sized array in struct/union
 #pragma warning(disable:4200)
-typedef
+typedef 
 _Struct_size_bytes_(sizeof(FILE_DIRECTORY_INFORMATION) + FilenameLength)
 struct _FILE_DIRECTORY_INFORMATION
 {
     DWORD                           NextEntryOffset;
     FILE_INFORMATION                BasicFileInformation;
-    char                            ShortFilename[SHORT_NAME_MAX_LENGTH];
     DWORD                           FilenameLength;
     char                            Filename[0];
 } FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;
+#pragma warning(default:4200)
 
 /////////////////////////////////////////////////////////////////////////////////////////////////
 /////////                        FUNDAMENTAL STRUCTURES                                 /////////
@@ -98,8 +91,6 @@ typedef struct _DEVICE_OBJECT
     // the R/W parameters (length and offset)
     DWORD                   DeviceAlignment;
 
-    MUTEX                   DeviceLock;
-
     // valid only for volume and file system devices
     struct _VPB*            Vpb;
 
@@ -138,7 +129,7 @@ typedef struct _IO_INTERRUPT
         {
             BYTE                Irq;
         } Legacy;
-        struct
+        struct  
         {
             BYTE                __Reserved0;
         } Lapic;
@@ -206,6 +197,7 @@ typedef struct _IRP
 
     IO_STACK_LOCATION   StackLocations[0];
 } IRP, *PIRP;
+#pragma warning(default:4200)
 
 typedef struct _MDL_TRANSLATION_PAIR
 {
@@ -213,9 +205,9 @@ typedef struct _MDL_TRANSLATION_PAIR
     DWORD               NumberOfBytes;
 } MDL_TRANSLATION_PAIR, *PMDL_TRANSLATION_PAIR;
 
-// warning C4200: nonstandard extension used: zero-sized array in struct/union
+// warning C4200: nonstandard extension used: zero-sized array in struct/union 
 #pragma warning(disable:4200)
-typedef
+typedef 
 _Struct_size_bytes_(sizeof(MDL) + NumberOfTranslationPairs * sizeof(MDL_TRANSLATION_PAIR))
 struct _MDL
 {
@@ -228,8 +220,10 @@ struct _MDL
 
     MDL_TRANSLATION_PAIR        Translations[0];
 } MDL, *PMDL;
+#pragma warning(default:4200)
 
 typedef
+SAL_SUCCESS
 STATUS
 (__cdecl FUNC_DriverDispatch)(
     INOUT       PDEVICE_OBJECT      DeviceObject,
@@ -252,6 +246,7 @@ typedef struct _DRIVER_OBJECT
 } DRIVER_OBJECT, *PDRIVER_OBJECT;
 
 typedef
+SAL_SUCCESS
 STATUS
 (__cdecl FUNC_DriverEntry)(
     INOUT       PDRIVER_OBJECT      DriverObject
@@ -284,15 +279,13 @@ typedef struct _GET_LENGTH_INFORMATION
 typedef struct _PARTITION_INFORMATION
 {
     QWORD           OffsetInDisk;
-
-    // Partition size in sectors
     QWORD           PartitionSize;
     BYTE            PartitionType;
     BOOLEAN         Bootable;
 } PARTITION_INFORMATION, *PPARTITION_INFORMATION;
 
 // IOCTL_DISK_LAYOUT_INFO
-typedef
+typedef 
 _Struct_size_bytes_(sizeof(DISK_LAYOUT_INFORMATION) + NumberOfPartitions * sizeof(PARTITION_INFORMATION))
 struct _DISK_LAYOUT_INFORMATION
 {
@@ -321,6 +314,7 @@ typedef struct _NET_GET_LINK_STATUS
 {
     BOOLEAN                 LinkUp;
 } NET_GET_LINK_STATUS, *PNET_GET_LINK_STATUS;
+#pragma warning(default:4200)
 
 #define IOCTL_DISK_GET_LENGTH_INFO          0x0
 #define IOCTL_DISK_LAYOUT_INFO              0x1
@@ -334,5 +328,5 @@ typedef struct _NET_GET_LINK_STATUS
 #define IOCTL_NET_GET_LINK_STATUS           0x9
 
 // end of common packing
-#pragma warning(pop)
-#pragma pack(pop)
+#pragma warning(default:4201)
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src/shared/kernel/log.h b/src/shared/kernel/log.h
index a2e37d3..4f72612 100644
--- a/src/shared/kernel/log.h
+++ b/src/shared/kernel/log.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#include "native/string.h"
+#include "string.h"
 #include "cpu.h"
 //#define NO_COMM
 
diff --git a/src/shared/kernel/network_packets.h b/src/shared/kernel/network_packets.h
index 14010bd..a571020 100644
--- a/src/shared/kernel/network_packets.h
+++ b/src/shared/kernel/network_packets.h
@@ -1,10 +1,6 @@
 #pragma once
 
-#pragma pack(push,1)
-
-#pragma warning(push)
-
-// warning C4201: nonstandard extension used: nameless struct/union
+// warning C4201: nonstandard extension used: nameless struct/union 
 #pragma warning(disable:4201)
 
 // warning C4200: nonstandard extension used: zero-sized array in struct/union
@@ -13,6 +9,8 @@
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
+#pragma pack(push,1)
+
 //////////////////////////////////////////////////////////////////////////////////////
 //////                               Address Types                             ///////
 //////////////////////////////////////////////////////////////////////////////////////
@@ -30,7 +28,7 @@ extern const MAC_ADDRESS MAC_BROADCAST;
 
 typedef union _IP4_ADDRESS
 {
-    struct
+    struct  
     {
         BYTE                ByteAddress[IP4_ADDRESS_SIZE];
     };
@@ -177,7 +175,7 @@ typedef struct _TCP_SEGMENT
     PORT_NUMBER         Destination;
     DWORD               SequenceNumber;
     DWORD               AckNumber;
-    struct
+    struct  
     {
         // 1st byte
         BYTE            CWR             : 1;
@@ -200,5 +198,8 @@ typedef struct _TCP_SEGMENT
 } TCP_SEGMENT, *PTCP_SEGMENT;
 STATIC_ASSERT(sizeof(TCP_SEGMENT) == TCP_SEGMENT_SIZE);
 
-#pragma warning(pop)
 #pragma pack(pop)
+
+#pragma warning(default:4214)
+#pragma warning(default:4200)
+#pragma warning(default:4201)
\ No newline at end of file
diff --git a/src/shared/kernel/pci_system.h b/src/shared/kernel/pci_system.h
index e85f86d..ea56843 100644
--- a/src/shared/kernel/pci_system.h
+++ b/src/shared/kernel/pci_system.h
@@ -3,12 +3,10 @@
 #include "pci_device.h"
 #include "list.h"
 
-#pragma warning(push)
-
 // warning C4214: nonstandard extension used: bit field types other than int
 #pragma warning(disable:4214)
 
-// warning C4201: nonstandard extension used: nameless struct/union
+// warning C4201: nonstandard extension used: nameless struct/union 
 #pragma warning(disable:4201)
 
 typedef struct _PCI_DEVICE_LIST_ENTRY
@@ -47,7 +45,8 @@ typedef struct _PCI_SPEC_LOCATION
     BOOLEAN             MatchDevice     : 1;
     BOOLEAN             MatchFunction   : 1;
 } PCI_SPEC_LOCATION, *PPCI_SPEC_LOCATION;
-#pragma warning(pop)
+#pragma warning(default:4201)
+#pragma warning(default:4214)
 
 void
 PciSystemPreinit(
@@ -59,6 +58,7 @@ PciSystemInit(
     void
     );
 
+SAL_SUCCESS
 STATUS
 PciSystemRetrieveDevices(
     INOUT   PLIST_ENTRY     PciDeviceList
@@ -70,22 +70,24 @@ PciSystemEstablishHierarchy(
     INOUT   PLIST_ENTRY     PciBridgeList
     );
 
+SAL_SUCCESS
 STATUS
 PciSystemFindDevicesMatchingSpecification(
     IN      PLIST_ENTRY     PciDeviceList,
     IN      PCI_SPEC        Specification,
-    OUT_WRITES_OPT(*NumberOfDevices)
+    OUT_WRITES_OPT(*NumberOfDevices) 
             PPCI_DEVICE_DESCRIPTION*    PciDevices,
     _When_(NULL == PciDevices, OUT)
     _When_(NULL != PciDevices, INOUT)
             DWORD*          NumberOfDevices
     );
 
+SAL_SUCCESS
 STATUS
 PciSystemFindDevicesMatchingLocation(
     IN      PLIST_ENTRY                 PciDeviceList,
     IN      PCI_SPEC_LOCATION           Specification,
-    OUT_WRITES_OPT(*NumberOfDevices)
+    OUT_WRITES_OPT(*NumberOfDevices) 
             PPCI_DEVICE_DESCRIPTION*    PciDevices,
     _When_(NULL == PciDevices, OUT)
     _When_(NULL != PciDevices, INOUT)
@@ -106,4 +108,4 @@ PciSystemWriteConfigurationSpaceGeneric(
     IN      WORD                    Register,
     IN      BYTE                    Width,
     IN      QWORD                   Value
-    );
+    );
\ No newline at end of file
